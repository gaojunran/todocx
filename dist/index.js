#!/usr/bin/env bun
// @bun
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/extend/index.js
var require_extend = __commonJS((exports, module) => {
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject = function isPlainObject(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj) {}
    return typeof key === "undefined" || hasOwn.call(obj, key);
  };
  var setProperty = function setProperty(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty(obj, name) {
    if (name === "__proto__") {
      if (!hasOwn.call(obj, name)) {
        return;
      } else if (gOPD) {
        return gOPD(obj, name).value;
      }
    }
    return obj[name];
  };
  module.exports = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (;i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);
          if (target !== copy) {
            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              setProperty(target, { name, newValue: extend(deep, clone, copy) });
            } else if (typeof copy !== "undefined") {
              setProperty(target, { name, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable2;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable2() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS((exports, module) => {
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  module.exports = function isBuffer(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  };
});

// node_modules/trie-prefix-tree/dist/config.js
var require_config = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = {
    END_WORD: "$",
    END_WORD_REPLACER: "9a219a89-91cd-42e2-abd5-eb113af08ca8",
    PERMS_MIN_LEN: 2
  };
  module.exports = exports["default"];
});

// node_modules/trie-prefix-tree/dist/append.js
var require_append = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = append;
  var _config = require_config();
  var _config2 = _interopRequireDefault(_config);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function append(trie, letter, index3, array) {
    var isEndWordLetter = letter === _config2.default.END_WORD;
    var isLastLetter = index3 === array.length - 1;
    if (isEndWordLetter && !isLastLetter) {
      trie[_config2.default.END_WORD] = 1;
      trie[_config2.default.END_WORD_REPLACER] = {};
      trie = trie[_config2.default.END_WORD_REPLACER];
    } else {
      trie[letter] = trie[letter] || {};
      trie = trie[letter];
    }
    if (isLastLetter) {
      trie[_config2.default.END_WORD] = 1;
    }
    return trie;
  }
  module.exports = exports["default"];
});

// node_modules/trie-prefix-tree/dist/create.js
var require_create = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports.default = create;
  var _append = require_append();
  var _append2 = _interopRequireDefault(_append);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function create(input) {
    if (!Array.isArray(input)) {
      throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
    }
    var trie = input.reduce(function(accumulator, item) {
      item.toLowerCase().split("").reduce(_append2.default, accumulator);
      return accumulator;
    }, {});
    return trie;
  }
  module.exports = exports["default"];
});

// node_modules/trie-prefix-tree/dist/utils.js
var require_utils = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = {
    objectCopy: function objectCopy(obj) {
      if (typeof obj === "undefined") {
        return {};
      }
      return JSON.parse(JSON.stringify(obj));
    },
    stringify: function stringify(obj) {
      var spacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      if (typeof obj === "undefined") {
        return "";
      }
      return JSON.stringify(obj, null, spacer);
    }
  };
  module.exports = exports["default"];
});

// node_modules/trie-prefix-tree/dist/checkPrefix.js
var require_checkPrefix = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = checkPrefix;
  var _utils = require_utils();
  var _utils2 = _interopRequireDefault(_utils);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function checkPrefix(prefixNode, prefix) {
    var input = prefix.toLowerCase().split("");
    var prefixFound = input.every(function(letter, index3) {
      if (!prefixNode[letter]) {
        return false;
      }
      return prefixNode = prefixNode[letter];
    });
    return {
      prefixFound,
      prefixNode
    };
  }
  module.exports = exports["default"];
});

// node_modules/trie-prefix-tree/dist/recursePrefix.js
var require_recursePrefix = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = recursePrefix;
  var _config = require_config();
  var _config2 = _interopRequireDefault(_config);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var pushInOrder = function pushInOrder(word, prefixes) {
    var i = 0;
    while (i < prefixes.length) {
      if (word < prefixes[i]) {
        break;
      }
      i += 1;
    }
    prefixes.splice(i, 0, word);
    return prefixes;
  };
  function recursePrefix(node2, prefix, sorted) {
    var prefixes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var word = prefix;
    for (var branch in node2) {
      var currentLetter = branch;
      if (branch === _config2.default.END_WORD && typeof node2[branch] === "number") {
        if (sorted) {
          pushInOrder(word, prefixes);
        } else {
          prefixes.push(word);
        }
        word = "";
      } else if (branch === _config2.default.END_WORD_REPLACER) {
        currentLetter = _config2.default.END_WORD;
      }
      recursePrefix(node2[branch], prefix + currentLetter, sorted, prefixes);
    }
    return prefixes;
  }
  module.exports = exports["default"];
});

// node_modules/trie-prefix-tree/dist/recurseRandomWord.js
var require_recurseRandomWord = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = recurseRandomWord;
  var _config = require_config();
  var _config2 = _interopRequireDefault(_config);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function recurseRandomWord(node2, prefix) {
    var word = prefix;
    var branches = Object.keys(node2);
    var branch = branches[Math.floor(Math.random() * branches.length)];
    if (branch === _config2.default.END_WORD) {
      return word;
    }
    return recurseRandomWord(node2[branch], prefix + branch);
  }
  module.exports = exports["default"];
});

// node_modules/trie-prefix-tree/dist/permutations.js
var require_permutations = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports.default = permutations;
  var _config = require_config();
  var _config2 = _interopRequireDefault(_config);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function permutations(letters, trie) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      type: "anagram"
    };
    if (typeof letters !== "string") {
      throw "Permutations expects string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
    }
    var words = [];
    var permute = function permute(word, node2) {
      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      var wordIsEmpty = word.length === 0;
      var wordFound = words.indexOf(prefix) !== -1;
      var endWordFound = node2[_config2.default.END_WORD] === 1;
      if (wordIsEmpty && endWordFound && !wordFound) {
        words.push(prefix);
      }
      for (var i = 0, len = word.length;i < len; i++) {
        var letter = word[i];
        if (opts.type === "sub-anagram") {
          if (endWordFound && !(words.indexOf(prefix) !== -1)) {
            words.push(prefix);
          }
        }
        if (node2[letter]) {
          var remaining = word.substring(0, i) + word.substring(i + 1, len);
          permute(remaining, node2[letter], prefix + letter, words);
        }
      }
      return words.sort();
    };
    return permute(letters, trie);
  }
  module.exports = exports["default"];
});

// node_modules/trie-prefix-tree/dist/index.js
var require_dist = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports.default = function(input) {
    if (!Array.isArray(input)) {
      throw "Expected parameter Array, received " + (typeof input === "undefined" ? "undefined" : _typeof(input));
    }
    var trie = (0, _create2.default)([].concat(_toConsumableArray(input)));
    return {
      tree: function tree() {
        return trie;
      },
      dump: function dump() {
        var spacer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return _utils2.default.stringify(trie, spacer);
      },
      addWord: function addWord(word) {
        if (typeof word !== "string" || word === "") {
          throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
        }
        var reducer = function reducer() {
          return _append2.default.apply(undefined, arguments);
        };
        var input2 = word.toLowerCase().split("");
        input2.reduce(reducer, trie);
        return this;
      },
      removeWord: function removeWord(word) {
        if (typeof word !== "string" || word === "") {
          throw "Expected parameter string, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
        }
        var _checkPrefix = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix.prefixFound, prefixNode = _checkPrefix.prefixNode;
        if (prefixFound) {
          delete prefixNode[_config2.default.END_WORD];
        }
        return this;
      },
      isPrefix: function isPrefix(prefix) {
        if (typeof prefix !== "string") {
          throw "Expected string prefix, received " + (typeof prefix === "undefined" ? "undefined" : _typeof(prefix));
        }
        var _checkPrefix2 = (0, _checkPrefix6.default)(trie, prefix), prefixFound = _checkPrefix2.prefixFound;
        return prefixFound;
      },
      getPrefix: function getPrefix(strPrefix) {
        var sorted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (typeof strPrefix !== "string") {
          throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
        }
        if (typeof sorted !== "boolean") {
          throw "Expected sort parameter as boolean, received " + (typeof sorted === "undefined" ? "undefined" : _typeof(sorted));
        }
        if (!this.isPrefix(strPrefix)) {
          return [];
        }
        var prefixNode = strPrefix.length ? (0, _checkPrefix6.default)(trie, strPrefix).prefixNode : trie;
        return (0, _recursePrefix2.default)(prefixNode, strPrefix, sorted);
      },
      getRandomWordWithPrefix: function getRandomWordWithPrefix(strPrefix) {
        if (typeof strPrefix !== "string") {
          throw "Expected string prefix, received " + (typeof strPrefix === "undefined" ? "undefined" : _typeof(strPrefix));
        }
        if (!this.isPrefix(strPrefix)) {
          return "";
        }
        var _checkPrefix3 = (0, _checkPrefix6.default)(trie, strPrefix), prefixNode = _checkPrefix3.prefixNode;
        return (0, _recurseRandomWord2.default)(prefixNode, strPrefix);
      },
      countPrefix: function countPrefix(strPrefix) {
        var prefixes = this.getPrefix(strPrefix);
        return prefixes.length;
      },
      getWords: function getWords() {
        var sorted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return this.getPrefix("", sorted);
      },
      hasWord: function hasWord(word) {
        if (typeof word !== "string") {
          throw "Expected string word, received " + (typeof word === "undefined" ? "undefined" : _typeof(word));
        }
        var _checkPrefix4 = (0, _checkPrefix6.default)(trie, word), prefixFound = _checkPrefix4.prefixFound, prefixNode = _checkPrefix4.prefixNode;
        if (prefixFound) {
          return prefixNode[_config2.default.END_WORD] === 1;
        }
        return false;
      },
      getAnagrams: function getAnagrams(letters) {
        if (typeof letters !== "string") {
          throw "Anagrams expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
        }
        if (letters.length < PERMS_MIN_LEN) {
          throw "getAnagrams expects at least " + PERMS_MIN_LEN + " letters";
        }
        return (0, _permutations2.default)(letters, trie, {
          type: "anagram"
        });
      },
      getSubAnagrams: function getSubAnagrams(letters) {
        if (typeof letters !== "string") {
          throw "Expected string letters, received " + (typeof letters === "undefined" ? "undefined" : _typeof(letters));
        }
        if (letters.length < PERMS_MIN_LEN) {
          throw "getSubAnagrams expects at least " + PERMS_MIN_LEN + " letters";
        }
        return (0, _permutations2.default)(letters, trie, {
          type: "sub-anagram"
        });
      }
    };
  };
  var _create = require_create();
  var _create2 = _interopRequireDefault(_create);
  var _append = require_append();
  var _append2 = _interopRequireDefault(_append);
  var _checkPrefix5 = require_checkPrefix();
  var _checkPrefix6 = _interopRequireDefault(_checkPrefix5);
  var _recursePrefix = require_recursePrefix();
  var _recursePrefix2 = _interopRequireDefault(_recursePrefix);
  var _recurseRandomWord = require_recurseRandomWord();
  var _recurseRandomWord2 = _interopRequireDefault(_recurseRandomWord);
  var _utils = require_utils();
  var _utils2 = _interopRequireDefault(_utils);
  var _config = require_config();
  var _config2 = _interopRequireDefault(_config);
  var _permutations = require_permutations();
  var _permutations2 = _interopRequireDefault(_permutations);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  var PERMS_MIN_LEN = _config2.default.PERMS_MIN_LEN;
  module.exports = exports["default"];
});

// node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS((exports, module) => {
  module.exports = function isArrayish(obj) {
    if (!obj || typeof obj === "string") {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
  };
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS((exports, module) => {
  var isArrayish = require_is_arrayish();
  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;
  var swizzle = module.exports = function swizzle(args) {
    var results = [];
    for (var i = 0, len = args.length;i < len; i++) {
      var arg2 = args[i];
      if (isArrayish(arg2)) {
        results = concat.call(results, slice.call(arg2));
      } else {
        results.push(arg2);
      }
    }
    return results;
  };
  swizzle.wrap = function(fn) {
    return function() {
      return fn(swizzle(arguments));
    };
  };
});

// node_modules/color-string/index.js
var require_color_string = __commonJS((exports, module) => {
  var colorNames = require_color_name();
  var swizzle = require_simple_swizzle();
  var hasOwnProperty2 = Object.hasOwnProperty;
  var reverseNames = Object.create(null);
  for (name in colorNames) {
    if (hasOwnProperty2.call(colorNames, name)) {
      reverseNames[colorNames[name]] = name;
    }
  }
  var name;
  var cs = module.exports = {
    to: {},
    get: {}
  };
  cs.get = function(string3) {
    var prefix = string3.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix) {
      case "hsl":
        val = cs.get.hsl(string3);
        model = "hsl";
        break;
      case "hwb":
        val = cs.get.hwb(string3);
        model = "hwb";
        break;
      default:
        val = cs.get.rgb(string3);
        model = "rgb";
        break;
    }
    if (!val) {
      return null;
    }
    return { model, value: val };
  };
  cs.get.rgb = function(string3) {
    if (!string3) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match2;
    var i;
    var hexAlpha;
    if (match2 = string3.match(hex)) {
      hexAlpha = match2[2];
      match2 = match2[1];
      for (i = 0;i < 3; i++) {
        var i2 = i * 2;
        rgb[i] = parseInt(match2.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match2 = string3.match(abbr)) {
      match2 = match2[1];
      hexAlpha = match2[3];
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match2[i] + match2[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match2 = string3.match(rgba)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match2[i + 1], 0);
      }
      if (match2[4]) {
        if (match2[5]) {
          rgb[3] = parseFloat(match2[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match2[4]);
        }
      }
    } else if (match2 = string3.match(per)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match2[i + 1]) * 2.55);
      }
      if (match2[4]) {
        if (match2[5]) {
          rgb[3] = parseFloat(match2[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match2[4]);
        }
      }
    } else if (match2 = string3.match(keyword)) {
      if (match2[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty2.call(colorNames, match2[1])) {
        return null;
      }
      rgb = colorNames[match2[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0;i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string3) {
    if (!string3) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match2 = string3.match(hsl);
    if (match2) {
      var alpha = parseFloat(match2[4]);
      var h = (parseFloat(match2[1]) % 360 + 360) % 360;
      var s2 = clamp(parseFloat(match2[2]), 0, 100);
      var l = clamp(parseFloat(match2[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s2, l, a];
    }
    return null;
  };
  cs.get.hwb = function(string3) {
    if (!string3) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match2 = string3.match(hwb);
    if (match2) {
      var alpha = parseFloat(match2[4]);
      var h = (parseFloat(match2[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match2[2]), 0, 100);
      var b = clamp(parseFloat(match2[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
    return null;
  };
  cs.to.hex = function() {
    var rgba = swizzle(arguments);
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function() {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function() {
    var rgba = swizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function() {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function() {
    var hwba = swizzle(arguments);
    var a = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
  };
  cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
  function clamp(num, min, max) {
    return Math.min(Math.max(min, num), max);
  }
  function hexDouble(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert5 = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  module.exports = convert5;
  for (const model of Object.keys(convert5)) {
    if (!("channels" in convert5[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert5[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert5[model].labels.length !== convert5[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert5[model];
    delete convert5[model].channels;
    delete convert5[model].labels;
    Object.defineProperty(convert5[model], "channels", { value: channels });
    Object.defineProperty(convert5[model], "labels", { value: labels });
  }
  convert5.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s2;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s2 = 0;
    } else if (l <= 0.5) {
      s2 = delta / (max + min);
    } else {
      s2 = delta / (2 - max - min);
    }
    return [h, s2 * 100, l * 100];
  };
  convert5.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s2;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s2 = 0;
    } else {
      s2 = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s2 * 100,
      v * 100
    ];
  };
  convert5.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert5.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert5.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert5.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert5.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert5.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert5.rgb.lab = function(rgb) {
    const xyz = convert5.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert5.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s2 === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s2);
    } else {
      t2 = l + s2 - l * s2;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert5.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s2 = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s2;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s2 *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s2) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
    return [h, sv * 100, v * 100];
  };
  convert5.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s2 = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s2);
    const q = 255 * v * (1 - s2 * f);
    const t = 255 * v * (1 - s2 * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert5.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s2) * v;
    const lmin = (2 - s2) * vmin;
    sl = s2 * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert5.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert5.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert5.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert5.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert5.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert5.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert5.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert5.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert5.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert5.hsv.ansi16 = function(args) {
    return convert5.rgb.ansi16(convert5.hsv.rgb(args), args[2]);
  };
  convert5.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert5.ansi16.rgb = function(args) {
    let color4 = args % 10;
    if (color4 === 0 || color4 === 7) {
      if (args > 50) {
        color4 += 3.5;
      }
      color4 = color4 / 10.5 * 255;
      return [color4, color4, color4];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color4 & 1) * mult * 255;
    const g = (color4 >> 1 & 1) * mult * 255;
    const b = (color4 >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert5.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert5.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string3 = integer.toString(16).toUpperCase();
    return "000000".substring(string3.length) + string3;
  };
  convert5.hex.rgb = function(args) {
    const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match2) {
      return [0, 0, 0];
    }
    let colorString = match2[0];
    if (match2[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert5.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert5.hsl.hcg = function(hsl) {
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s2 * l : 2 * s2 * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert5.hsv.hcg = function(hsv) {
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s2 * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert5.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert5.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert5.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s2 = 0;
    if (l > 0 && l < 0.5) {
      s2 = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s2 = c / (2 * (1 - l));
    }
    return [hcg[0], s2 * 100, l * 100];
  };
  convert5.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert5.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert5.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert5.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert5.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert5.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert5.gray.hsv = convert5.gray.hsl;
  convert5.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert5.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert5.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert5.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string3 = integer.toString(16).toUpperCase();
    return "000000".substring(string3.length) + string3;
  };
  convert5.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var conversions = require_conversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue2 = [fromModel];
    graph[fromModel].distance = 0;
    while (queue2.length) {
      const current = queue2.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0;i < len; i++) {
        const adjacent = adjacents[i];
        const node2 = graph[adjacent];
        if (node2.distance === -1) {
          node2.distance = graph[current].distance + 1;
          node2.parent = current;
          queue2.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link2(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link2(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  module.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0;i < len; i++) {
      const toModel = models[i];
      const node2 = graph[toModel];
      if (node2.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert5 = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert5[fromModel] = {};
    Object.defineProperty(convert5[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert5[fromModel], "labels", { value: conversions[fromModel].labels });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert5[fromModel][toModel] = wrapRounded(fn);
      convert5[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert5;
});

// node_modules/color/index.js
var require_color = __commonJS((exports, module) => {
  var colorString = require_color_string();
  var convert5 = require_color_convert();
  var skippedModels = [
    "keyword",
    "gray",
    "hex"
  ];
  var hashedModelKeys = {};
  for (const model of Object.keys(convert5)) {
    hashedModelKeys[[...convert5[model].labels].sort().join("")] = model;
  }
  var limiters = {};
  function Color2(object, model) {
    if (!(this instanceof Color2)) {
      return new Color2(object, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in convert5)) {
      throw new Error("Unknown model: " + model);
    }
    let i;
    let channels;
    if (object == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (object instanceof Color2) {
      this.model = object.model;
      this.color = [...object.color];
      this.valpha = object.valpha;
    } else if (typeof object === "string") {
      const result = colorString.get(object);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + object);
      }
      this.model = result.model;
      channels = convert5[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (object.length > 0) {
      this.model = model || "rgb";
      channels = convert5[this.model].channels;
      const newArray = Array.prototype.slice.call(object, 0, channels);
      this.color = zeroArray(newArray, channels);
      this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
    } else if (typeof object === "number") {
      this.model = "rgb";
      this.color = [
        object >> 16 & 255,
        object >> 8 & 255,
        object & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      const keys2 = Object.keys(object);
      if ("alpha" in object) {
        keys2.splice(keys2.indexOf("alpha"), 1);
        this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
      }
      const hashedKeys = keys2.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(object));
      }
      this.model = hashedModelKeys[hashedKeys];
      const { labels } = convert5[this.model];
      const color4 = [];
      for (i = 0;i < labels.length; i++) {
        color4.push(object[labels[i]]);
      }
      this.color = zeroArray(color4);
    }
    if (limiters[this.model]) {
      channels = convert5[this.model].channels;
      for (i = 0;i < channels; i++) {
        const limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  }
  Color2.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(places) {
      let self2 = this.model in colorString.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return colorString.to[self2.model](args);
    },
    percentString(places) {
      const self2 = this.rgb().round(typeof places === "number" ? places : 1);
      const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return colorString.to.rgb.percent(args);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      const result = {};
      const { channels } = convert5[this.model];
      const { labels } = convert5[this.model];
      for (let i = 0;i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray() {
      const rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject() {
      const rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round(places) {
      places = Math.max(places || 0, 0);
      return new Color2([...this.color.map(roundToPlace(places)), this.valpha], this.model);
    },
    alpha(value) {
      if (value !== undefined) {
        return new Color2([...this.color, Math.max(0, Math.min(1, value))], this.model);
      }
      return this.valpha;
    },
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(95.047)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(108.833)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword(value) {
      if (value !== undefined) {
        return new Color2(value);
      }
      return convert5[this.model].keyword(this.color);
    },
    hex(value) {
      if (value !== undefined) {
        return new Color2(value);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    hexa(value) {
      if (value !== undefined) {
        return new Color2(value);
      }
      const rgbArray = this.rgb().round().color;
      let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
      if (alphaHex.length === 1) {
        alphaHex = "0" + alphaHex;
      }
      return colorString.to.hex(rgbArray) + alphaHex;
    },
    rgbNumber() {
      const rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity() {
      const rgb = this.rgb().color;
      const lum = [];
      for (const [i, element2] of rgb.entries()) {
        const chan = element2 / 255;
        lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast(color22) {
      const lum1 = this.luminosity();
      const lum2 = color22.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level(color22) {
      const contrastRatio = this.contrast(color22);
      if (contrastRatio >= 7) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark() {
      const rgb = this.rgb().color;
      const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
      return yiq < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      const rgb = this.rgb();
      for (let i = 0;i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten(ratio) {
      const hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken(ratio) {
      const hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten(ratio) {
      const hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken(ratio) {
      const hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale() {
      const rgb = this.rgb().color;
      const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color2.rgb(value, value, value);
    },
    fade(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate(degrees) {
      const hsl = this.hsl();
      let hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      const color1 = mixinColor.rgb();
      const color22 = this.rgb();
      const p = weight === undefined ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = color1.alpha() - color22.alpha();
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      const w2 = 1 - w1;
      return Color2.rgb(w1 * color1.red() + w2 * color22.red(), w1 * color1.green() + w2 * color22.green(), w1 * color1.blue() + w2 * color22.blue(), color1.alpha() * p + color22.alpha() * (1 - p));
    }
  };
  for (const model of Object.keys(convert5)) {
    if (skippedModels.includes(model)) {
      continue;
    }
    const { channels } = convert5[model];
    Color2.prototype[model] = function(...args) {
      if (this.model === model) {
        return new Color2(this);
      }
      if (args.length > 0) {
        return new Color2(args, model);
      }
      return new Color2([...assertArray(convert5[this.model][model].raw(this.color)), this.valpha], model);
    };
    Color2[model] = function(...args) {
      let color4 = args[0];
      if (typeof color4 === "number") {
        color4 = zeroArray(args, channels);
      }
      return new Color2(color4, model);
    };
  }
  function roundTo(number, places) {
    return Number(number.toFixed(places));
  }
  function roundToPlace(places) {
    return function(number) {
      return roundTo(number, places);
    };
  }
  function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    for (const m of model) {
      (limiters[m] || (limiters[m] = []))[channel] = modifier;
    }
    model = model[0];
    return function(value) {
      let result;
      if (value !== undefined) {
        if (modifier) {
          value = modifier(value);
        }
        result = this[model]();
        result.color[channel] = value;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  }
  function maxfn(max) {
    return function(v) {
      return Math.max(0, Math.min(max, v));
    };
  }
  function assertArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  function zeroArray(array, length) {
    for (let i = 0;i < length; i++) {
      if (typeof array[i] !== "number") {
        array[i] = 0;
      }
    }
    return array;
  }
  module.exports = Color2;
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs4 = __require("fs");
  function checkPathExt(path2, options2) {
    var pathext = options2.pathExt !== undefined ? options2.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0;i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path2, options2) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path2, options2);
  }
  function isexe(path2, options2, cb) {
    fs4.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path2, options2));
    });
  }
  function sync(path2, options2) {
    return checkStat(fs4.statSync(path2), path2, options2);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs4 = __require("fs");
  function isexe(path2, options2, cb) {
    fs4.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options2));
    });
  }
  function sync(path2, options2) {
    return checkStat(fs4.statSync(path2), options2);
  }
  function checkStat(stat, options2) {
    return stat.isFile() && checkMode(stat, options2);
  }
  function checkMode(stat, options2) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options2.uid !== undefined ? options2.uid : process.getuid && process.getuid();
    var myGid = options2.gid !== undefined ? options2.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports, module) => {
  var fs4 = __require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module.exports = isexe;
  isexe.sync = sync;
  function isexe(path2, options2, cb) {
    if (typeof options2 === "function") {
      cb = options2;
      options2 = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve2, reject) {
        isexe(path2, options2 || {}, function(er, is5) {
          if (er) {
            reject(er);
          } else {
            resolve2(is5);
          }
        });
      });
    }
    core(path2, options2 || {}, function(er, is5) {
      if (er) {
        if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
          er = null;
          is5 = false;
        }
      }
      cb(er, is5);
    });
  }
  function sync(path2, options2) {
    try {
      return core.sync(path2, options2 || {});
    } catch (er) {
      if (options2 && options2.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path2 = __require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve2, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve2(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve2(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve2, reject) => {
      if (ii === pathExt.length)
        return resolve2(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, { pathExt: pathExtExe }, (er, is5) => {
        if (!er && is5) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve2(p + ext);
        }
        return resolve2(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0;i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0;j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is5 = isexe.sync(cur, { pathExt: pathExtExe });
          if (is5) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {}
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module.exports = which;
  which.sync = whichSync;
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports, module) => {
  var pathKey = (options2 = {}) => {
    const environment = options2.env || process.env;
    const platform = options2.platform || process.platform;
    if (platform !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module.exports = pathKey;
  module.exports.default = pathKey;
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports, module) => {
  var path2 = __require("path");
  var which = require_which();
  var getPathKey = require_path_key();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {}
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env[getPathKey({ env })],
        pathExt: withoutPathExt ? path2.delimiter : undefined
      });
    } catch (e) {} finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module.exports = resolveCommand;
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports, module) => {
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg2) {
    arg2 = arg2.replace(metaCharsRegExp, "^$1");
    return arg2;
  }
  function escapeArgument(arg2, doubleEscapeMetaChars) {
    arg2 = `${arg2}`;
    arg2 = arg2.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
    arg2 = arg2.replace(/(?=(\\+?)?)\1$/, "$1$1");
    arg2 = `"${arg2}"`;
    arg2 = arg2.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg2 = arg2.replace(metaCharsRegExp, "^$1");
    }
    return arg2;
  }
  exports.command = escapeCommand;
  exports.argument = escapeArgument;
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports, module) => {
  module.exports = /^#!(.*)/;
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports, module) => {
  var shebangRegex = require_shebang_regex();
  module.exports = (string3 = "") => {
    const match2 = string3.match(shebangRegex);
    if (!match2) {
      return null;
    }
    const [path2, argument] = match2[0].replace(/#! ?/, "").split(" ");
    const binary = path2.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports, module) => {
  var fs4 = __require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    const buffer3 = Buffer.alloc(size);
    let fd;
    try {
      fd = fs4.openSync(command, "r");
      fs4.readSync(fd, buffer3, 0, size, 0);
      fs4.closeSync(fd);
    } catch (e) {}
    return shebangCommand(buffer3.toString());
  }
  module.exports = readShebang;
});

// node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var path2 = __require("path");
  var resolveCommand = require_resolveCommand();
  var escape = require_escape();
  var readShebang = require_readShebang();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path2.normalize(parsed.command);
      parsed.command = escape.command(parsed.command);
      parsed.args = parsed.args.map((arg2) => escape.argument(arg2, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse3(command, args, options2) {
    if (args && !Array.isArray(args)) {
      options2 = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options2 = Object.assign({}, options2);
    const parsed = {
      command,
      args,
      options: options2,
      file: undefined,
      original: {
        command,
        args
      }
    };
    return options2.shell ? parsed : parseNonShell(parsed);
  }
  module.exports = parse3;
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports, module) => {
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed);
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports, module) => {
  var cp = __require("child_process");
  var parse3 = require_parse();
  var enoent = require_enoent();
  function spawn(command, args, options2) {
    const parsed = parse3(command, args, options2);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options2) {
    const parsed = parse3(command, args, options2);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module.exports = spawn;
  module.exports.spawn = spawn;
  module.exports.sync = spawnSync;
  module.exports._parse = parse3;
  module.exports._enoent = enoent;
});

// node_modules/merge-stream/index.js
var require_merge_stream = __commonJS((exports, module) => {
  var { PassThrough } = __require("stream");
  module.exports = function() {
    var sources = [];
    var output = new PassThrough({ objectMode: true });
    output.setMaxListeners(0);
    output.add = add;
    output.isEmpty = isEmpty;
    output.on("unpipe", remove);
    Array.prototype.slice.call(arguments).forEach(add);
    return output;
    function add(source) {
      if (Array.isArray(source)) {
        source.forEach(add);
        return this;
      }
      sources.push(source);
      source.once("end", remove.bind(null, source));
      source.once("error", output.emit.bind(output, "error"));
      source.pipe(output, { end: false });
      return this;
    }
    function isEmpty() {
      return sources.length == 0;
    }
    function remove(source) {
      sources = sources.filter(function(it) {
        return it !== source;
      });
      if (!sources.length && output.readable) {
        output.end();
      }
    }
  };
});

// node_modules/commander/lib/error.js
var require_error = __commonJS((exports) => {
  class CommanderError extends Error {
    constructor(exitCode, code3, message) {
      super(message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
      this.code = code3;
      this.exitCode = exitCode;
      this.nestedError = undefined;
    }
  }

  class InvalidArgumentError extends CommanderError {
    constructor(message) {
      super(1, "commander.invalidArgument", message);
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
    }
  }
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS((exports) => {
  var { InvalidArgumentError } = require_error();

  class Argument {
    constructor(name, description) {
      this.description = description || "";
      this.variadic = false;
      this.parseArg = undefined;
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.argChoices = undefined;
      switch (name[0]) {
        case "<":
          this.required = true;
          this._name = name.slice(1, -1);
          break;
        case "[":
          this.required = false;
          this._name = name.slice(1, -1);
          break;
        default:
          this.required = true;
          this._name = name;
          break;
      }
      if (this._name.endsWith("...")) {
        this.variadic = true;
        this._name = this._name.slice(0, -3);
      }
    }
    name() {
      return this._name;
    }
    _collectValue(value, previous3) {
      if (previous3 === this.defaultValue || !Array.isArray(previous3)) {
        return [value];
      }
      previous3.push(value);
      return previous3;
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    choices(values2) {
      this.argChoices = values2.slice();
      this.parseArg = (arg2, previous3) => {
        if (!this.argChoices.includes(arg2)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._collectValue(arg2, previous3);
        }
        return arg2;
      };
      return this;
    }
    argRequired() {
      this.required = true;
      return this;
    }
    argOptional() {
      this.required = false;
      return this;
    }
  }
  function humanReadableArgName(arg2) {
    const nameOutput = arg2.name() + (arg2.variadic === true ? "..." : "");
    return arg2.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
  }
  exports.Argument = Argument;
  exports.humanReadableArgName = humanReadableArgName;
});

// node_modules/commander/lib/help.js
var require_help = __commonJS((exports) => {
  var { humanReadableArgName } = require_argument();

  class Help {
    constructor() {
      this.helpWidth = undefined;
      this.minWidthToWrap = 40;
      this.sortSubcommands = false;
      this.sortOptions = false;
      this.showGlobalOptions = false;
    }
    prepareContext(contextOptions) {
      this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;
    }
    visibleCommands(cmd) {
      const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
      const helpCommand = cmd._getHelpCommand();
      if (helpCommand && !helpCommand._hidden) {
        visibleCommands.push(helpCommand);
      }
      if (this.sortSubcommands) {
        visibleCommands.sort((a, b) => {
          return a.name().localeCompare(b.name());
        });
      }
      return visibleCommands;
    }
    compareOptions(a, b) {
      const getSortKey = (option) => {
        return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
      };
      return getSortKey(a).localeCompare(getSortKey(b));
    }
    visibleOptions(cmd) {
      const visibleOptions = cmd.options.filter((option) => !option.hidden);
      const helpOption = cmd._getHelpOption();
      if (helpOption && !helpOption.hidden) {
        const removeShort = helpOption.short && cmd._findOption(helpOption.short);
        const removeLong = helpOption.long && cmd._findOption(helpOption.long);
        if (!removeShort && !removeLong) {
          visibleOptions.push(helpOption);
        } else if (helpOption.long && !removeLong) {
          visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
        } else if (helpOption.short && !removeShort) {
          visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
        }
      }
      if (this.sortOptions) {
        visibleOptions.sort(this.compareOptions);
      }
      return visibleOptions;
    }
    visibleGlobalOptions(cmd) {
      if (!this.showGlobalOptions)
        return [];
      const globalOptions = [];
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
        globalOptions.push(...visibleOptions);
      }
      if (this.sortOptions) {
        globalOptions.sort(this.compareOptions);
      }
      return globalOptions;
    }
    visibleArguments(cmd) {
      if (cmd._argsDescription) {
        cmd.registeredArguments.forEach((argument) => {
          argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
        });
      }
      if (cmd.registeredArguments.find((argument) => argument.description)) {
        return cmd.registeredArguments;
      }
      return [];
    }
    subcommandTerm(cmd) {
      const args = cmd.registeredArguments.map((arg2) => humanReadableArgName(arg2)).join(" ");
      return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
    }
    optionTerm(option) {
      return option.flags;
    }
    argumentTerm(argument) {
      return argument.name();
    }
    longestSubcommandTermLength(cmd, helper2) {
      return helper2.visibleCommands(cmd).reduce((max, command) => {
        return Math.max(max, this.displayWidth(helper2.styleSubcommandTerm(helper2.subcommandTerm(command))));
      }, 0);
    }
    longestOptionTermLength(cmd, helper2) {
      return helper2.visibleOptions(cmd).reduce((max, option) => {
        return Math.max(max, this.displayWidth(helper2.styleOptionTerm(helper2.optionTerm(option))));
      }, 0);
    }
    longestGlobalOptionTermLength(cmd, helper2) {
      return helper2.visibleGlobalOptions(cmd).reduce((max, option) => {
        return Math.max(max, this.displayWidth(helper2.styleOptionTerm(helper2.optionTerm(option))));
      }, 0);
    }
    longestArgumentTermLength(cmd, helper2) {
      return helper2.visibleArguments(cmd).reduce((max, argument) => {
        return Math.max(max, this.displayWidth(helper2.styleArgumentTerm(helper2.argumentTerm(argument))));
      }, 0);
    }
    commandUsage(cmd) {
      let cmdName = cmd._name;
      if (cmd._aliases[0]) {
        cmdName = cmdName + "|" + cmd._aliases[0];
      }
      let ancestorCmdNames = "";
      for (let ancestorCmd = cmd.parent;ancestorCmd; ancestorCmd = ancestorCmd.parent) {
        ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
      }
      return ancestorCmdNames + cmdName + " " + cmd.usage();
    }
    commandDescription(cmd) {
      return cmd.description();
    }
    subcommandDescription(cmd) {
      return cmd.summary() || cmd.description();
    }
    optionDescription(option) {
      const extraInfo = [];
      if (option.argChoices) {
        extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (option.defaultValue !== undefined) {
        const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
        if (showDefault) {
          extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
        }
      }
      if (option.presetArg !== undefined && option.optional) {
        extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
      }
      if (option.envVar !== undefined) {
        extraInfo.push(`env: ${option.envVar}`);
      }
      if (extraInfo.length > 0) {
        const extraDescription = `(${extraInfo.join(", ")})`;
        if (option.description) {
          return `${option.description} ${extraDescription}`;
        }
        return extraDescription;
      }
      return option.description;
    }
    argumentDescription(argument) {
      const extraInfo = [];
      if (argument.argChoices) {
        extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
      }
      if (argument.defaultValue !== undefined) {
        extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
      }
      if (extraInfo.length > 0) {
        const extraDescription = `(${extraInfo.join(", ")})`;
        if (argument.description) {
          return `${argument.description} ${extraDescription}`;
        }
        return extraDescription;
      }
      return argument.description;
    }
    formatItemList(heading2, items, helper2) {
      if (items.length === 0)
        return [];
      return [helper2.styleTitle(heading2), ...items, ""];
    }
    groupItems(unsortedItems, visibleItems, getGroup) {
      const result = new Map;
      unsortedItems.forEach((item) => {
        const group = getGroup(item);
        if (!result.has(group))
          result.set(group, []);
      });
      visibleItems.forEach((item) => {
        const group = getGroup(item);
        if (!result.has(group)) {
          result.set(group, []);
        }
        result.get(group).push(item);
      });
      return result;
    }
    formatHelp(cmd, helper2) {
      const termWidth = helper2.padWidth(cmd, helper2);
      const helpWidth = helper2.helpWidth ?? 80;
      function callFormatItem(term, description) {
        return helper2.formatItem(term, termWidth, description, helper2);
      }
      let output = [
        `${helper2.styleTitle("Usage:")} ${helper2.styleUsage(helper2.commandUsage(cmd))}`,
        ""
      ];
      const commandDescription = helper2.commandDescription(cmd);
      if (commandDescription.length > 0) {
        output = output.concat([
          helper2.boxWrap(helper2.styleCommandDescription(commandDescription), helpWidth),
          ""
        ]);
      }
      const argumentList = helper2.visibleArguments(cmd).map((argument) => {
        return callFormatItem(helper2.styleArgumentTerm(helper2.argumentTerm(argument)), helper2.styleArgumentDescription(helper2.argumentDescription(argument)));
      });
      output = output.concat(this.formatItemList("Arguments:", argumentList, helper2));
      const optionGroups = this.groupItems(cmd.options, helper2.visibleOptions(cmd), (option) => option.helpGroupHeading ?? "Options:");
      optionGroups.forEach((options2, group) => {
        const optionList = options2.map((option) => {
          return callFormatItem(helper2.styleOptionTerm(helper2.optionTerm(option)), helper2.styleOptionDescription(helper2.optionDescription(option)));
        });
        output = output.concat(this.formatItemList(group, optionList, helper2));
      });
      if (helper2.showGlobalOptions) {
        const globalOptionList = helper2.visibleGlobalOptions(cmd).map((option) => {
          return callFormatItem(helper2.styleOptionTerm(helper2.optionTerm(option)), helper2.styleOptionDescription(helper2.optionDescription(option)));
        });
        output = output.concat(this.formatItemList("Global Options:", globalOptionList, helper2));
      }
      const commandGroups = this.groupItems(cmd.commands, helper2.visibleCommands(cmd), (sub) => sub.helpGroup() || "Commands:");
      commandGroups.forEach((commands, group) => {
        const commandList = commands.map((sub) => {
          return callFormatItem(helper2.styleSubcommandTerm(helper2.subcommandTerm(sub)), helper2.styleSubcommandDescription(helper2.subcommandDescription(sub)));
        });
        output = output.concat(this.formatItemList(group, commandList, helper2));
      });
      return output.join(`
`);
    }
    displayWidth(str) {
      return stripColor(str).length;
    }
    styleTitle(str) {
      return str;
    }
    styleUsage(str) {
      return str.split(" ").map((word) => {
        if (word === "[options]")
          return this.styleOptionText(word);
        if (word === "[command]")
          return this.styleSubcommandText(word);
        if (word[0] === "[" || word[0] === "<")
          return this.styleArgumentText(word);
        return this.styleCommandText(word);
      }).join(" ");
    }
    styleCommandDescription(str) {
      return this.styleDescriptionText(str);
    }
    styleOptionDescription(str) {
      return this.styleDescriptionText(str);
    }
    styleSubcommandDescription(str) {
      return this.styleDescriptionText(str);
    }
    styleArgumentDescription(str) {
      return this.styleDescriptionText(str);
    }
    styleDescriptionText(str) {
      return str;
    }
    styleOptionTerm(str) {
      return this.styleOptionText(str);
    }
    styleSubcommandTerm(str) {
      return str.split(" ").map((word) => {
        if (word === "[options]")
          return this.styleOptionText(word);
        if (word[0] === "[" || word[0] === "<")
          return this.styleArgumentText(word);
        return this.styleSubcommandText(word);
      }).join(" ");
    }
    styleArgumentTerm(str) {
      return this.styleArgumentText(str);
    }
    styleOptionText(str) {
      return str;
    }
    styleArgumentText(str) {
      return str;
    }
    styleSubcommandText(str) {
      return str;
    }
    styleCommandText(str) {
      return str;
    }
    padWidth(cmd, helper2) {
      return Math.max(helper2.longestOptionTermLength(cmd, helper2), helper2.longestGlobalOptionTermLength(cmd, helper2), helper2.longestSubcommandTermLength(cmd, helper2), helper2.longestArgumentTermLength(cmd, helper2));
    }
    preformatted(str) {
      return /\n[^\S\r\n]/.test(str);
    }
    formatItem(term, termWidth, description, helper2) {
      const itemIndent = 2;
      const itemIndentStr = " ".repeat(itemIndent);
      if (!description)
        return itemIndentStr + term;
      const paddedTerm = term.padEnd(termWidth + term.length - helper2.displayWidth(term));
      const spacerWidth = 2;
      const helpWidth = this.helpWidth ?? 80;
      const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;
      let formattedDescription;
      if (remainingWidth < this.minWidthToWrap || helper2.preformatted(description)) {
        formattedDescription = description;
      } else {
        const wrappedDescription = helper2.boxWrap(description, remainingWidth);
        formattedDescription = wrappedDescription.replace(/\n/g, `
` + " ".repeat(termWidth + spacerWidth));
      }
      return itemIndentStr + paddedTerm + " ".repeat(spacerWidth) + formattedDescription.replace(/\n/g, `
${itemIndentStr}`);
    }
    boxWrap(str, width) {
      if (width < this.minWidthToWrap)
        return str;
      const rawLines = str.split(/\r\n|\n/);
      const chunkPattern = /[\s]*[^\s]+/g;
      const wrappedLines = [];
      rawLines.forEach((line) => {
        const chunks = line.match(chunkPattern);
        if (chunks === null) {
          wrappedLines.push("");
          return;
        }
        let sumChunks = [chunks.shift()];
        let sumWidth = this.displayWidth(sumChunks[0]);
        chunks.forEach((chunk) => {
          const visibleWidth = this.displayWidth(chunk);
          if (sumWidth + visibleWidth <= width) {
            sumChunks.push(chunk);
            sumWidth += visibleWidth;
            return;
          }
          wrappedLines.push(sumChunks.join(""));
          const nextChunk = chunk.trimStart();
          sumChunks = [nextChunk];
          sumWidth = this.displayWidth(nextChunk);
        });
        wrappedLines.push(sumChunks.join(""));
      });
      return wrappedLines.join(`
`);
    }
  }
  function stripColor(str) {
    const sgrPattern = /\x1b\[\d*(;\d*)*m/g;
    return str.replace(sgrPattern, "");
  }
  exports.Help = Help;
  exports.stripColor = stripColor;
});

// node_modules/commander/lib/option.js
var require_option = __commonJS((exports) => {
  var { InvalidArgumentError } = require_error();

  class Option {
    constructor(flags, description) {
      this.flags = flags;
      this.description = description || "";
      this.required = flags.includes("<");
      this.optional = flags.includes("[");
      this.variadic = /\w\.\.\.[>\]]$/.test(flags);
      this.mandatory = false;
      const optionFlags = splitOptionFlags(flags);
      this.short = optionFlags.shortFlag;
      this.long = optionFlags.longFlag;
      this.negate = false;
      if (this.long) {
        this.negate = this.long.startsWith("--no-");
      }
      this.defaultValue = undefined;
      this.defaultValueDescription = undefined;
      this.presetArg = undefined;
      this.envVar = undefined;
      this.parseArg = undefined;
      this.hidden = false;
      this.argChoices = undefined;
      this.conflictsWith = [];
      this.implied = undefined;
      this.helpGroupHeading = undefined;
    }
    default(value, description) {
      this.defaultValue = value;
      this.defaultValueDescription = description;
      return this;
    }
    preset(arg2) {
      this.presetArg = arg2;
      return this;
    }
    conflicts(names) {
      this.conflictsWith = this.conflictsWith.concat(names);
      return this;
    }
    implies(impliedOptionValues) {
      let newImplied = impliedOptionValues;
      if (typeof impliedOptionValues === "string") {
        newImplied = { [impliedOptionValues]: true };
      }
      this.implied = Object.assign(this.implied || {}, newImplied);
      return this;
    }
    env(name) {
      this.envVar = name;
      return this;
    }
    argParser(fn) {
      this.parseArg = fn;
      return this;
    }
    makeOptionMandatory(mandatory = true) {
      this.mandatory = !!mandatory;
      return this;
    }
    hideHelp(hide = true) {
      this.hidden = !!hide;
      return this;
    }
    _collectValue(value, previous3) {
      if (previous3 === this.defaultValue || !Array.isArray(previous3)) {
        return [value];
      }
      previous3.push(value);
      return previous3;
    }
    choices(values2) {
      this.argChoices = values2.slice();
      this.parseArg = (arg2, previous3) => {
        if (!this.argChoices.includes(arg2)) {
          throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
        }
        if (this.variadic) {
          return this._collectValue(arg2, previous3);
        }
        return arg2;
      };
      return this;
    }
    name() {
      if (this.long) {
        return this.long.replace(/^--/, "");
      }
      return this.short.replace(/^-/, "");
    }
    attributeName() {
      if (this.negate) {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      return camelcase(this.name());
    }
    helpGroup(heading2) {
      this.helpGroupHeading = heading2;
      return this;
    }
    is(arg2) {
      return this.short === arg2 || this.long === arg2;
    }
    isBoolean() {
      return !this.required && !this.optional && !this.negate;
    }
  }

  class DualOptions {
    constructor(options2) {
      this.positiveOptions = new Map;
      this.negativeOptions = new Map;
      this.dualOptions = new Set;
      options2.forEach((option) => {
        if (option.negate) {
          this.negativeOptions.set(option.attributeName(), option);
        } else {
          this.positiveOptions.set(option.attributeName(), option);
        }
      });
      this.negativeOptions.forEach((value, key) => {
        if (this.positiveOptions.has(key)) {
          this.dualOptions.add(key);
        }
      });
    }
    valueFromOption(value, option) {
      const optionKey = option.attributeName();
      if (!this.dualOptions.has(optionKey))
        return true;
      const preset = this.negativeOptions.get(optionKey).presetArg;
      const negativeValue = preset !== undefined ? preset : false;
      return option.negate === (negativeValue === value);
    }
  }
  function camelcase(str) {
    return str.split("-").reduce((str2, word) => {
      return str2 + word[0].toUpperCase() + word.slice(1);
    });
  }
  function splitOptionFlags(flags) {
    let shortFlag;
    let longFlag;
    const shortFlagExp = /^-[^-]$/;
    const longFlagExp = /^--[^-]/;
    const flagParts = flags.split(/[ |,]+/).concat("guard");
    if (shortFlagExp.test(flagParts[0]))
      shortFlag = flagParts.shift();
    if (longFlagExp.test(flagParts[0]))
      longFlag = flagParts.shift();
    if (!shortFlag && shortFlagExp.test(flagParts[0]))
      shortFlag = flagParts.shift();
    if (!shortFlag && longFlagExp.test(flagParts[0])) {
      shortFlag = longFlag;
      longFlag = flagParts.shift();
    }
    if (flagParts[0].startsWith("-")) {
      const unsupportedFlag = flagParts[0];
      const baseError = `option creation failed due to '${unsupportedFlag}' in option flags '${flags}'`;
      if (/^-[^-][^-]/.test(unsupportedFlag))
        throw new Error(`${baseError}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);
      if (shortFlagExp.test(unsupportedFlag))
        throw new Error(`${baseError}
- too many short flags`);
      if (longFlagExp.test(unsupportedFlag))
        throw new Error(`${baseError}
- too many long flags`);
      throw new Error(`${baseError}
- unrecognised flag format`);
    }
    if (shortFlag === undefined && longFlag === undefined)
      throw new Error(`option creation failed due to no flags found in '${flags}'.`);
    return { shortFlag, longFlag };
  }
  exports.Option = Option;
  exports.DualOptions = DualOptions;
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS((exports) => {
  var maxDistance = 3;
  function editDistance(a, b) {
    if (Math.abs(a.length - b.length) > maxDistance)
      return Math.max(a.length, b.length);
    const d = [];
    for (let i = 0;i <= a.length; i++) {
      d[i] = [i];
    }
    for (let j = 0;j <= b.length; j++) {
      d[0][j] = j;
    }
    for (let j = 1;j <= b.length; j++) {
      for (let i = 1;i <= a.length; i++) {
        let cost = 1;
        if (a[i - 1] === b[j - 1]) {
          cost = 0;
        } else {
          cost = 1;
        }
        d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
        }
      }
    }
    return d[a.length][b.length];
  }
  function suggestSimilar(word, candidates) {
    if (!candidates || candidates.length === 0)
      return "";
    candidates = Array.from(new Set(candidates));
    const searchingOptions = word.startsWith("--");
    if (searchingOptions) {
      word = word.slice(2);
      candidates = candidates.map((candidate) => candidate.slice(2));
    }
    let similar = [];
    let bestDistance = maxDistance;
    const minSimilarity = 0.4;
    candidates.forEach((candidate) => {
      if (candidate.length <= 1)
        return;
      const distance = editDistance(word, candidate);
      const length = Math.max(word.length, candidate.length);
      const similarity = (length - distance) / length;
      if (similarity > minSimilarity) {
        if (distance < bestDistance) {
          bestDistance = distance;
          similar = [candidate];
        } else if (distance === bestDistance) {
          similar.push(candidate);
        }
      }
    });
    similar.sort((a, b) => a.localeCompare(b));
    if (searchingOptions) {
      similar = similar.map((candidate) => `--${candidate}`);
    }
    if (similar.length > 1) {
      return `
(Did you mean one of ${similar.join(", ")}?)`;
    }
    if (similar.length === 1) {
      return `
(Did you mean ${similar[0]}?)`;
    }
    return "";
  }
  exports.suggestSimilar = suggestSimilar;
});

// node_modules/commander/lib/command.js
var require_command = __commonJS((exports) => {
  var EventEmitter2 = __require("node:events").EventEmitter;
  var childProcess4 = __require("node:child_process");
  var path7 = __require("node:path");
  var fs6 = __require("node:fs");
  var process16 = __require("node:process");
  var { Argument, humanReadableArgName } = require_argument();
  var { CommanderError } = require_error();
  var { Help, stripColor } = require_help();
  var { Option, DualOptions } = require_option();
  var { suggestSimilar } = require_suggestSimilar();

  class Command extends EventEmitter2 {
    constructor(name) {
      super();
      this.commands = [];
      this.options = [];
      this.parent = null;
      this._allowUnknownOption = false;
      this._allowExcessArguments = false;
      this.registeredArguments = [];
      this._args = this.registeredArguments;
      this.args = [];
      this.rawArgs = [];
      this.processedArgs = [];
      this._scriptPath = null;
      this._name = name || "";
      this._optionValues = {};
      this._optionValueSources = {};
      this._storeOptionsAsProperties = false;
      this._actionHandler = null;
      this._executableHandler = false;
      this._executableFile = null;
      this._executableDir = null;
      this._defaultCommandName = null;
      this._exitCallback = null;
      this._aliases = [];
      this._combineFlagAndOptionalValue = true;
      this._description = "";
      this._summary = "";
      this._argsDescription = undefined;
      this._enablePositionalOptions = false;
      this._passThroughOptions = false;
      this._lifeCycleHooks = {};
      this._showHelpAfterError = false;
      this._showSuggestionAfterError = true;
      this._savedState = null;
      this._outputConfiguration = {
        writeOut: (str) => process16.stdout.write(str),
        writeErr: (str) => process16.stderr.write(str),
        outputError: (str, write) => write(str),
        getOutHelpWidth: () => process16.stdout.isTTY ? process16.stdout.columns : undefined,
        getErrHelpWidth: () => process16.stderr.isTTY ? process16.stderr.columns : undefined,
        getOutHasColors: () => useColor() ?? (process16.stdout.isTTY && process16.stdout.hasColors?.()),
        getErrHasColors: () => useColor() ?? (process16.stderr.isTTY && process16.stderr.hasColors?.()),
        stripColor: (str) => stripColor(str)
      };
      this._hidden = false;
      this._helpOption = undefined;
      this._addImplicitHelpCommand = undefined;
      this._helpCommand = undefined;
      this._helpConfiguration = {};
      this._helpGroupHeading = undefined;
      this._defaultCommandGroup = undefined;
      this._defaultOptionGroup = undefined;
    }
    copyInheritedSettings(sourceCommand) {
      this._outputConfiguration = sourceCommand._outputConfiguration;
      this._helpOption = sourceCommand._helpOption;
      this._helpCommand = sourceCommand._helpCommand;
      this._helpConfiguration = sourceCommand._helpConfiguration;
      this._exitCallback = sourceCommand._exitCallback;
      this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
      this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
      this._allowExcessArguments = sourceCommand._allowExcessArguments;
      this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
      this._showHelpAfterError = sourceCommand._showHelpAfterError;
      this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
      return this;
    }
    _getCommandAndAncestors() {
      const result = [];
      for (let command = this;command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
      let desc = actionOptsOrExecDesc;
      let opts = execOpts;
      if (typeof desc === "object" && desc !== null) {
        opts = desc;
        desc = null;
      }
      opts = opts || {};
      const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
      const cmd = this.createCommand(name);
      if (desc) {
        cmd.description(desc);
        cmd._executableHandler = true;
      }
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      cmd._hidden = !!(opts.noHelp || opts.hidden);
      cmd._executableFile = opts.executableFile || null;
      if (args)
        cmd.arguments(args);
      this._registerCommand(cmd);
      cmd.parent = this;
      cmd.copyInheritedSettings(this);
      if (desc)
        return this;
      return cmd;
    }
    createCommand(name) {
      return new Command(name);
    }
    createHelp() {
      return Object.assign(new Help, this.configureHelp());
    }
    configureHelp(configuration) {
      if (configuration === undefined)
        return this._helpConfiguration;
      this._helpConfiguration = configuration;
      return this;
    }
    configureOutput(configuration) {
      if (configuration === undefined)
        return this._outputConfiguration;
      this._outputConfiguration = {
        ...this._outputConfiguration,
        ...configuration
      };
      return this;
    }
    showHelpAfterError(displayHelp = true) {
      if (typeof displayHelp !== "string")
        displayHelp = !!displayHelp;
      this._showHelpAfterError = displayHelp;
      return this;
    }
    showSuggestionAfterError(displaySuggestion = true) {
      this._showSuggestionAfterError = !!displaySuggestion;
      return this;
    }
    addCommand(cmd, opts) {
      if (!cmd._name) {
        throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
      }
      opts = opts || {};
      if (opts.isDefault)
        this._defaultCommandName = cmd._name;
      if (opts.noHelp || opts.hidden)
        cmd._hidden = true;
      this._registerCommand(cmd);
      cmd.parent = this;
      cmd._checkForBrokenPassThrough();
      return this;
    }
    createArgument(name, description) {
      return new Argument(name, description);
    }
    argument(name, description, parseArg, defaultValue) {
      const argument = this.createArgument(name, description);
      if (typeof parseArg === "function") {
        argument.default(defaultValue).argParser(parseArg);
      } else {
        argument.default(parseArg);
      }
      this.addArgument(argument);
      return this;
    }
    arguments(names) {
      names.trim().split(/ +/).forEach((detail) => {
        this.argument(detail);
      });
      return this;
    }
    addArgument(argument) {
      const previousArgument = this.registeredArguments.slice(-1)[0];
      if (previousArgument?.variadic) {
        throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
      }
      if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
        throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
      }
      this.registeredArguments.push(argument);
      return this;
    }
    helpCommand(enableOrNameAndArgs, description) {
      if (typeof enableOrNameAndArgs === "boolean") {
        this._addImplicitHelpCommand = enableOrNameAndArgs;
        if (enableOrNameAndArgs && this._defaultCommandGroup) {
          this._initCommandGroup(this._getHelpCommand());
        }
        return this;
      }
      const nameAndArgs = enableOrNameAndArgs ?? "help [command]";
      const [, helpName, helpArgs] = nameAndArgs.match(/([^ ]+) *(.*)/);
      const helpDescription = description ?? "display help for command";
      const helpCommand = this.createCommand(helpName);
      helpCommand.helpOption(false);
      if (helpArgs)
        helpCommand.arguments(helpArgs);
      if (helpDescription)
        helpCommand.description(helpDescription);
      this._addImplicitHelpCommand = true;
      this._helpCommand = helpCommand;
      if (enableOrNameAndArgs || description)
        this._initCommandGroup(helpCommand);
      return this;
    }
    addHelpCommand(helpCommand, deprecatedDescription) {
      if (typeof helpCommand !== "object") {
        this.helpCommand(helpCommand, deprecatedDescription);
        return this;
      }
      this._addImplicitHelpCommand = true;
      this._helpCommand = helpCommand;
      this._initCommandGroup(helpCommand);
      return this;
    }
    _getHelpCommand() {
      const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
      if (hasImplicitHelpCommand) {
        if (this._helpCommand === undefined) {
          this.helpCommand(undefined, undefined);
        }
        return this._helpCommand;
      }
      return null;
    }
    hook(event, listener) {
      const allowedValues = ["preSubcommand", "preAction", "postAction"];
      if (!allowedValues.includes(event)) {
        throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      if (this._lifeCycleHooks[event]) {
        this._lifeCycleHooks[event].push(listener);
      } else {
        this._lifeCycleHooks[event] = [listener];
      }
      return this;
    }
    exitOverride(fn) {
      if (fn) {
        this._exitCallback = fn;
      } else {
        this._exitCallback = (err) => {
          if (err.code !== "commander.executeSubCommandAsync") {
            throw err;
          } else {}
        };
      }
      return this;
    }
    _exit(exitCode, code3, message) {
      if (this._exitCallback) {
        this._exitCallback(new CommanderError(exitCode, code3, message));
      }
      process16.exit(exitCode);
    }
    action(fn) {
      const listener = (args) => {
        const expectedArgsCount = this.registeredArguments.length;
        const actionArgs = args.slice(0, expectedArgsCount);
        if (this._storeOptionsAsProperties) {
          actionArgs[expectedArgsCount] = this;
        } else {
          actionArgs[expectedArgsCount] = this.opts();
        }
        actionArgs.push(this);
        return fn.apply(this, actionArgs);
      };
      this._actionHandler = listener;
      return this;
    }
    createOption(flags, description) {
      return new Option(flags, description);
    }
    _callParseArg(target, value, previous3, invalidArgumentMessage) {
      try {
        return target.parseArg(value, previous3);
      } catch (err) {
        if (err.code === "commander.invalidArgument") {
          const message = `${invalidArgumentMessage} ${err.message}`;
          this.error(message, { exitCode: err.exitCode, code: err.code });
        }
        throw err;
      }
    }
    _registerOption(option) {
      const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
      if (matchingOption) {
        const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
        throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
      }
      this._initOptionGroup(option);
      this.options.push(option);
    }
    _registerCommand(command) {
      const knownBy = (cmd) => {
        return [cmd.name()].concat(cmd.aliases());
      };
      const alreadyUsed = knownBy(command).find((name) => this._findCommand(name));
      if (alreadyUsed) {
        const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
        const newCmd = knownBy(command).join("|");
        throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
      }
      this._initCommandGroup(command);
      this.commands.push(command);
    }
    addOption(option) {
      this._registerOption(option);
      const oname = option.name();
      const name = option.attributeName();
      if (option.negate) {
        const positiveLongFlag = option.long.replace(/^--no-/, "--");
        if (!this._findOption(positiveLongFlag)) {
          this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, "default");
        }
      } else if (option.defaultValue !== undefined) {
        this.setOptionValueWithSource(name, option.defaultValue, "default");
      }
      const handleOptionValue = (val, invalidValueMessage, valueSource) => {
        if (val == null && option.presetArg !== undefined) {
          val = option.presetArg;
        }
        const oldValue = this.getOptionValue(name);
        if (val !== null && option.parseArg) {
          val = this._callParseArg(option, val, oldValue, invalidValueMessage);
        } else if (val !== null && option.variadic) {
          val = option._collectValue(val, oldValue);
        }
        if (val == null) {
          if (option.negate) {
            val = false;
          } else if (option.isBoolean() || option.optional) {
            val = true;
          } else {
            val = "";
          }
        }
        this.setOptionValueWithSource(name, val, valueSource);
      };
      this.on("option:" + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, "cli");
      });
      if (option.envVar) {
        this.on("optionEnv:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "env");
        });
      }
      return this;
    }
    _optionEx(config, flags, description, fn, defaultValue) {
      if (typeof flags === "object" && flags instanceof Option) {
        throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
      }
      const option = this.createOption(flags, description);
      option.makeOptionMandatory(!!config.mandatory);
      if (typeof fn === "function") {
        option.default(defaultValue).argParser(fn);
      } else if (fn instanceof RegExp) {
        const regex = fn;
        fn = (val, def) => {
          const m = regex.exec(val);
          return m ? m[0] : def;
        };
        option.default(defaultValue).argParser(fn);
      } else {
        option.default(fn);
      }
      return this.addOption(option);
    }
    option(flags, description, parseArg, defaultValue) {
      return this._optionEx({}, flags, description, parseArg, defaultValue);
    }
    requiredOption(flags, description, parseArg, defaultValue) {
      return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
    }
    combineFlagAndOptionalValue(combine = true) {
      this._combineFlagAndOptionalValue = !!combine;
      return this;
    }
    allowUnknownOption(allowUnknown = true) {
      this._allowUnknownOption = !!allowUnknown;
      return this;
    }
    allowExcessArguments(allowExcess = true) {
      this._allowExcessArguments = !!allowExcess;
      return this;
    }
    enablePositionalOptions(positional = true) {
      this._enablePositionalOptions = !!positional;
      return this;
    }
    passThroughOptions(passThrough = true) {
      this._passThroughOptions = !!passThrough;
      this._checkForBrokenPassThrough();
      return this;
    }
    _checkForBrokenPassThrough() {
      if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
        throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
      }
    }
    storeOptionsAsProperties(storeAsProperties = true) {
      if (this.options.length) {
        throw new Error("call .storeOptionsAsProperties() before adding options");
      }
      if (Object.keys(this._optionValues).length) {
        throw new Error("call .storeOptionsAsProperties() before setting option values");
      }
      this._storeOptionsAsProperties = !!storeAsProperties;
      return this;
    }
    getOptionValue(key) {
      if (this._storeOptionsAsProperties) {
        return this[key];
      }
      return this._optionValues[key];
    }
    setOptionValue(key, value) {
      return this.setOptionValueWithSource(key, value, undefined);
    }
    setOptionValueWithSource(key, value, source) {
      if (this._storeOptionsAsProperties) {
        this[key] = value;
      } else {
        this._optionValues[key] = value;
      }
      this._optionValueSources[key] = source;
      return this;
    }
    getOptionValueSource(key) {
      return this._optionValueSources[key];
    }
    getOptionValueSourceWithGlobals(key) {
      let source;
      this._getCommandAndAncestors().forEach((cmd) => {
        if (cmd.getOptionValueSource(key) !== undefined) {
          source = cmd.getOptionValueSource(key);
        }
      });
      return source;
    }
    _prepareUserArgs(argv, parseOptions) {
      if (argv !== undefined && !Array.isArray(argv)) {
        throw new Error("first parameter to parse must be array or undefined");
      }
      parseOptions = parseOptions || {};
      if (argv === undefined && parseOptions.from === undefined) {
        if (process16.versions?.electron) {
          parseOptions.from = "electron";
        }
        const execArgv = process16.execArgv ?? [];
        if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) {
          parseOptions.from = "eval";
        }
      }
      if (argv === undefined) {
        argv = process16.argv;
      }
      this.rawArgs = argv.slice();
      let userArgs;
      switch (parseOptions.from) {
        case undefined:
        case "node":
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
          break;
        case "electron":
          if (process16.defaultApp) {
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
          } else {
            userArgs = argv.slice(1);
          }
          break;
        case "user":
          userArgs = argv.slice(0);
          break;
        case "eval":
          userArgs = argv.slice(1);
          break;
        default:
          throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
      }
      if (!this._name && this._scriptPath)
        this.nameFromFilename(this._scriptPath);
      this._name = this._name || "program";
      return userArgs;
    }
    parse(argv, parseOptions) {
      this._prepareForParse();
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      this._parseCommand([], userArgs);
      return this;
    }
    async parseAsync(argv, parseOptions) {
      this._prepareForParse();
      const userArgs = this._prepareUserArgs(argv, parseOptions);
      await this._parseCommand([], userArgs);
      return this;
    }
    _prepareForParse() {
      if (this._savedState === null) {
        this.saveStateBeforeParse();
      } else {
        this.restoreStateBeforeParse();
      }
    }
    saveStateBeforeParse() {
      this._savedState = {
        _name: this._name,
        _optionValues: { ...this._optionValues },
        _optionValueSources: { ...this._optionValueSources }
      };
    }
    restoreStateBeforeParse() {
      if (this._storeOptionsAsProperties)
        throw new Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);
      this._name = this._savedState._name;
      this._scriptPath = null;
      this.rawArgs = [];
      this._optionValues = { ...this._savedState._optionValues };
      this._optionValueSources = { ...this._savedState._optionValueSources };
      this.args = [];
      this.processedArgs = [];
    }
    _checkForMissingExecutable(executableFile, executableDir, subcommandName) {
      if (fs6.existsSync(executableFile))
        return;
      const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
      const executableMissing = `'${executableFile}' does not exist
 - if '${subcommandName}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
      throw new Error(executableMissing);
    }
    _executeSubCommand(subcommand, args) {
      args = args.slice();
      let launchWithNode = false;
      const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
      function findFile(baseDir, baseName) {
        const localBin = path7.resolve(baseDir, baseName);
        if (fs6.existsSync(localBin))
          return localBin;
        if (sourceExt.includes(path7.extname(baseName)))
          return;
        const foundExt = sourceExt.find((ext) => fs6.existsSync(`${localBin}${ext}`));
        if (foundExt)
          return `${localBin}${foundExt}`;
        return;
      }
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
      let executableDir = this._executableDir || "";
      if (this._scriptPath) {
        let resolvedScriptPath;
        try {
          resolvedScriptPath = fs6.realpathSync(this._scriptPath);
        } catch {
          resolvedScriptPath = this._scriptPath;
        }
        executableDir = path7.resolve(path7.dirname(resolvedScriptPath), executableDir);
      }
      if (executableDir) {
        let localFile = findFile(executableDir, executableFile);
        if (!localFile && !subcommand._executableFile && this._scriptPath) {
          const legacyName = path7.basename(this._scriptPath, path7.extname(this._scriptPath));
          if (legacyName !== this._name) {
            localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
          }
        }
        executableFile = localFile || executableFile;
      }
      launchWithNode = sourceExt.includes(path7.extname(executableFile));
      let proc;
      if (process16.platform !== "win32") {
        if (launchWithNode) {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process16.execArgv).concat(args);
          proc = childProcess4.spawn(process16.argv[0], args, { stdio: "inherit" });
        } else {
          proc = childProcess4.spawn(executableFile, args, { stdio: "inherit" });
        }
      } else {
        this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
        args.unshift(executableFile);
        args = incrementNodeInspectorPort(process16.execArgv).concat(args);
        proc = childProcess4.spawn(process16.execPath, args, { stdio: "inherit" });
      }
      if (!proc.killed) {
        const signals2 = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
        signals2.forEach((signal) => {
          process16.on(signal, () => {
            if (proc.killed === false && proc.exitCode === null) {
              proc.kill(signal);
            }
          });
        });
      }
      const exitCallback = this._exitCallback;
      proc.on("close", (code3) => {
        code3 = code3 ?? 1;
        if (!exitCallback) {
          process16.exit(code3);
        } else {
          exitCallback(new CommanderError(code3, "commander.executeSubCommandAsync", "(close)"));
        }
      });
      proc.on("error", (err) => {
        if (err.code === "ENOENT") {
          this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
        } else if (err.code === "EACCES") {
          throw new Error(`'${executableFile}' not executable`);
        }
        if (!exitCallback) {
          process16.exit(1);
        } else {
          const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
          wrappedError.nestedError = err;
          exitCallback(wrappedError);
        }
      });
      this.runningCommand = proc;
    }
    _dispatchSubcommand(commandName, operands, unknown) {
      const subCommand = this._findCommand(commandName);
      if (!subCommand)
        this.help({ error: true });
      subCommand._prepareForParse();
      let promiseChain;
      promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
      promiseChain = this._chainOrCall(promiseChain, () => {
        if (subCommand._executableHandler) {
          this._executeSubCommand(subCommand, operands.concat(unknown));
        } else {
          return subCommand._parseCommand(operands, unknown);
        }
      });
      return promiseChain;
    }
    _dispatchHelpCommand(subcommandName) {
      if (!subcommandName) {
        this.help();
      }
      const subCommand = this._findCommand(subcommandName);
      if (subCommand && !subCommand._executableHandler) {
        subCommand.help();
      }
      return this._dispatchSubcommand(subcommandName, [], [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]);
    }
    _checkNumberOfArguments() {
      this.registeredArguments.forEach((arg2, i) => {
        if (arg2.required && this.args[i] == null) {
          this.missingArgument(arg2.name());
        }
      });
      if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
        return;
      }
      if (this.args.length > this.registeredArguments.length) {
        this._excessArguments(this.args);
      }
    }
    _processArguments() {
      const myParseArg = (argument, value, previous3) => {
        let parsedValue = value;
        if (value !== null && argument.parseArg) {
          const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
          parsedValue = this._callParseArg(argument, value, previous3, invalidValueMessage);
        }
        return parsedValue;
      };
      this._checkNumberOfArguments();
      const processedArgs = [];
      this.registeredArguments.forEach((declaredArg, index3) => {
        let value = declaredArg.defaultValue;
        if (declaredArg.variadic) {
          if (index3 < this.args.length) {
            value = this.args.slice(index3);
            if (declaredArg.parseArg) {
              value = value.reduce((processed, v) => {
                return myParseArg(declaredArg, v, processed);
              }, declaredArg.defaultValue);
            }
          } else if (value === undefined) {
            value = [];
          }
        } else if (index3 < this.args.length) {
          value = this.args[index3];
          if (declaredArg.parseArg) {
            value = myParseArg(declaredArg, value, declaredArg.defaultValue);
          }
        }
        processedArgs[index3] = value;
      });
      this.processedArgs = processedArgs;
    }
    _chainOrCall(promise, fn) {
      if (promise?.then && typeof promise.then === "function") {
        return promise.then(() => fn());
      }
      return fn();
    }
    _chainOrCallHooks(promise, event) {
      let result = promise;
      const hooks = [];
      this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== undefined).forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
      if (event === "postAction") {
        hooks.reverse();
      }
      hooks.forEach((hookDetail) => {
        result = this._chainOrCall(result, () => {
          return hookDetail.callback(hookDetail.hookedCommand, this);
        });
      });
      return result;
    }
    _chainOrCallSubCommandHook(promise, subCommand, event) {
      let result = promise;
      if (this._lifeCycleHooks[event] !== undefined) {
        this._lifeCycleHooks[event].forEach((hook) => {
          result = this._chainOrCall(result, () => {
            return hook(this, subCommand);
          });
        });
      }
      return result;
    }
    _parseCommand(operands, unknown) {
      const parsed = this.parseOptions(unknown);
      this._parseOptionsEnv();
      this._parseOptionsImplied();
      operands = operands.concat(parsed.operands);
      unknown = parsed.unknown;
      this.args = operands.concat(unknown);
      if (operands && this._findCommand(operands[0])) {
        return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
      }
      if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
        return this._dispatchHelpCommand(operands[1]);
      }
      if (this._defaultCommandName) {
        this._outputHelpIfRequested(unknown);
        return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
      }
      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
        this.help({ error: true });
      }
      this._outputHelpIfRequested(parsed.unknown);
      this._checkForMissingMandatoryOptions();
      this._checkForConflictingOptions();
      const checkForUnknownOptions = () => {
        if (parsed.unknown.length > 0) {
          this.unknownOption(parsed.unknown[0]);
        }
      };
      const commandEvent = `command:${this.name()}`;
      if (this._actionHandler) {
        checkForUnknownOptions();
        this._processArguments();
        let promiseChain;
        promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
        promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
        if (this.parent) {
          promiseChain = this._chainOrCall(promiseChain, () => {
            this.parent.emit(commandEvent, operands, unknown);
          });
        }
        promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
        return promiseChain;
      }
      if (this.parent?.listenerCount(commandEvent)) {
        checkForUnknownOptions();
        this._processArguments();
        this.parent.emit(commandEvent, operands, unknown);
      } else if (operands.length) {
        if (this._findCommand("*")) {
          return this._dispatchSubcommand("*", operands, unknown);
        }
        if (this.listenerCount("command:*")) {
          this.emit("command:*", operands, unknown);
        } else if (this.commands.length) {
          this.unknownCommand();
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      } else if (this.commands.length) {
        checkForUnknownOptions();
        this.help({ error: true });
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    }
    _findCommand(name) {
      if (!name)
        return;
      return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
    }
    _findOption(arg2) {
      return this.options.find((option) => option.is(arg2));
    }
    _checkForMissingMandatoryOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd.options.forEach((anOption) => {
          if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
            cmd.missingMandatoryOptionValue(anOption);
          }
        });
      });
    }
    _checkForConflictingLocalOptions() {
      const definedNonDefaultOptions = this.options.filter((option) => {
        const optionKey = option.attributeName();
        if (this.getOptionValue(optionKey) === undefined) {
          return false;
        }
        return this.getOptionValueSource(optionKey) !== "default";
      });
      const optionsWithConflicting = definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0);
      optionsWithConflicting.forEach((option) => {
        const conflictingAndDefined = definedNonDefaultOptions.find((defined) => option.conflictsWith.includes(defined.attributeName()));
        if (conflictingAndDefined) {
          this._conflictingOption(option, conflictingAndDefined);
        }
      });
    }
    _checkForConflictingOptions() {
      this._getCommandAndAncestors().forEach((cmd) => {
        cmd._checkForConflictingLocalOptions();
      });
    }
    parseOptions(args) {
      const operands = [];
      const unknown = [];
      let dest = operands;
      function maybeOption(arg2) {
        return arg2.length > 1 && arg2[0] === "-";
      }
      const negativeNumberArg = (arg2) => {
        if (!/^-\d*\.?\d+(e[+-]?\d+)?$/.test(arg2))
          return false;
        return !this._getCommandAndAncestors().some((cmd) => cmd.options.map((opt) => opt.short).some((short) => /^-\d$/.test(short)));
      };
      let activeVariadicOption = null;
      let activeGroup = null;
      let i = 0;
      while (i < args.length || activeGroup) {
        const arg2 = activeGroup ?? args[i++];
        activeGroup = null;
        if (arg2 === "--") {
          if (dest === unknown)
            dest.push(arg2);
          dest.push(...args.slice(i));
          break;
        }
        if (activeVariadicOption && (!maybeOption(arg2) || negativeNumberArg(arg2))) {
          this.emit(`option:${activeVariadicOption.name()}`, arg2);
          continue;
        }
        activeVariadicOption = null;
        if (maybeOption(arg2)) {
          const option = this._findOption(arg2);
          if (option) {
            if (option.required) {
              const value = args[i++];
              if (value === undefined)
                this.optionMissingArgument(option);
              this.emit(`option:${option.name()}`, value);
            } else if (option.optional) {
              let value = null;
              if (i < args.length && (!maybeOption(args[i]) || negativeNumberArg(args[i]))) {
                value = args[i++];
              }
              this.emit(`option:${option.name()}`, value);
            } else {
              this.emit(`option:${option.name()}`);
            }
            activeVariadicOption = option.variadic ? option : null;
            continue;
          }
        }
        if (arg2.length > 2 && arg2[0] === "-" && arg2[1] !== "-") {
          const option = this._findOption(`-${arg2[1]}`);
          if (option) {
            if (option.required || option.optional && this._combineFlagAndOptionalValue) {
              this.emit(`option:${option.name()}`, arg2.slice(2));
            } else {
              this.emit(`option:${option.name()}`);
              activeGroup = `-${arg2.slice(2)}`;
            }
            continue;
          }
        }
        if (/^--[^=]+=/.test(arg2)) {
          const index3 = arg2.indexOf("=");
          const option = this._findOption(arg2.slice(0, index3));
          if (option && (option.required || option.optional)) {
            this.emit(`option:${option.name()}`, arg2.slice(index3 + 1));
            continue;
          }
        }
        if (dest === operands && maybeOption(arg2) && !(this.commands.length === 0 && negativeNumberArg(arg2))) {
          dest = unknown;
        }
        if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
          if (this._findCommand(arg2)) {
            operands.push(arg2);
            unknown.push(...args.slice(i));
            break;
          } else if (this._getHelpCommand() && arg2 === this._getHelpCommand().name()) {
            operands.push(arg2, ...args.slice(i));
            break;
          } else if (this._defaultCommandName) {
            unknown.push(arg2, ...args.slice(i));
            break;
          }
        }
        if (this._passThroughOptions) {
          dest.push(arg2, ...args.slice(i));
          break;
        }
        dest.push(arg2);
      }
      return { operands, unknown };
    }
    opts() {
      if (this._storeOptionsAsProperties) {
        const result = {};
        const len = this.options.length;
        for (let i = 0;i < len; i++) {
          const key = this.options[i].attributeName();
          result[key] = key === this._versionOptionName ? this._version : this[key];
        }
        return result;
      }
      return this._optionValues;
    }
    optsWithGlobals() {
      return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
    }
    error(message, errorOptions) {
      this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
      if (typeof this._showHelpAfterError === "string") {
        this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
      } else if (this._showHelpAfterError) {
        this._outputConfiguration.writeErr(`
`);
        this.outputHelp({ error: true });
      }
      const config = errorOptions || {};
      const exitCode = config.exitCode || 1;
      const code3 = config.code || "commander.error";
      this._exit(exitCode, code3, message);
    }
    _parseOptionsEnv() {
      this.options.forEach((option) => {
        if (option.envVar && option.envVar in process16.env) {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === undefined || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
            if (option.required || option.optional) {
              this.emit(`optionEnv:${option.name()}`, process16.env[option.envVar]);
            } else {
              this.emit(`optionEnv:${option.name()}`);
            }
          }
        }
      });
    }
    _parseOptionsImplied() {
      const dualHelper = new DualOptions(this.options);
      const hasCustomOptionValue = (optionKey) => {
        return this.getOptionValue(optionKey) !== undefined && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
      };
      this.options.filter((option) => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
        Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
          this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
        });
      });
    }
    missingArgument(name) {
      const message = `error: missing required argument '${name}'`;
      this.error(message, { code: "commander.missingArgument" });
    }
    optionMissingArgument(option) {
      const message = `error: option '${option.flags}' argument missing`;
      this.error(message, { code: "commander.optionMissingArgument" });
    }
    missingMandatoryOptionValue(option) {
      const message = `error: required option '${option.flags}' not specified`;
      this.error(message, { code: "commander.missingMandatoryOptionValue" });
    }
    _conflictingOption(option, conflictingOption) {
      const findBestOptionFromValue = (option2) => {
        const optionKey = option2.attributeName();
        const optionValue = this.getOptionValue(optionKey);
        const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
        const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
        if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {
          return negativeOption;
        }
        return positiveOption || option2;
      };
      const getErrorMessage = (option2) => {
        const bestOption = findBestOptionFromValue(option2);
        const optionKey = bestOption.attributeName();
        const source = this.getOptionValueSource(optionKey);
        if (source === "env") {
          return `environment variable '${bestOption.envVar}'`;
        }
        return `option '${bestOption.flags}'`;
      };
      const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
      this.error(message, { code: "commander.conflictingOption" });
    }
    unknownOption(flag) {
      if (this._allowUnknownOption)
        return;
      let suggestion = "";
      if (flag.startsWith("--") && this._showSuggestionAfterError) {
        let candidateFlags = [];
        let command = this;
        do {
          const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
          candidateFlags = candidateFlags.concat(moreFlags);
          command = command.parent;
        } while (command && !command._enablePositionalOptions);
        suggestion = suggestSimilar(flag, candidateFlags);
      }
      const message = `error: unknown option '${flag}'${suggestion}`;
      this.error(message, { code: "commander.unknownOption" });
    }
    _excessArguments(receivedArgs) {
      if (this._allowExcessArguments)
        return;
      const expected = this.registeredArguments.length;
      const s2 = expected === 1 ? "" : "s";
      const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
      const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s2} but got ${receivedArgs.length}.`;
      this.error(message, { code: "commander.excessArguments" });
    }
    unknownCommand() {
      const unknownName = this.args[0];
      let suggestion = "";
      if (this._showSuggestionAfterError) {
        const candidateNames = [];
        this.createHelp().visibleCommands(this).forEach((command) => {
          candidateNames.push(command.name());
          if (command.alias())
            candidateNames.push(command.alias());
        });
        suggestion = suggestSimilar(unknownName, candidateNames);
      }
      const message = `error: unknown command '${unknownName}'${suggestion}`;
      this.error(message, { code: "commander.unknownCommand" });
    }
    version(str, flags, description) {
      if (str === undefined)
        return this._version;
      this._version = str;
      flags = flags || "-V, --version";
      description = description || "output the version number";
      const versionOption = this.createOption(flags, description);
      this._versionOptionName = versionOption.attributeName();
      this._registerOption(versionOption);
      this.on("option:" + versionOption.name(), () => {
        this._outputConfiguration.writeOut(`${str}
`);
        this._exit(0, "commander.version", str);
      });
      return this;
    }
    description(str, argsDescription) {
      if (str === undefined && argsDescription === undefined)
        return this._description;
      this._description = str;
      if (argsDescription) {
        this._argsDescription = argsDescription;
      }
      return this;
    }
    summary(str) {
      if (str === undefined)
        return this._summary;
      this._summary = str;
      return this;
    }
    alias(alias) {
      if (alias === undefined)
        return this._aliases[0];
      let command = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
        command = this.commands[this.commands.length - 1];
      }
      if (alias === command._name)
        throw new Error("Command alias can't be the same as its name");
      const matchingCommand = this.parent?._findCommand(alias);
      if (matchingCommand) {
        const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
        throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
      }
      command._aliases.push(alias);
      return this;
    }
    aliases(aliases2) {
      if (aliases2 === undefined)
        return this._aliases;
      aliases2.forEach((alias) => this.alias(alias));
      return this;
    }
    usage(str) {
      if (str === undefined) {
        if (this._usage)
          return this._usage;
        const args = this.registeredArguments.map((arg2) => {
          return humanReadableArgName(arg2);
        });
        return [].concat(this.options.length || this._helpOption !== null ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
      }
      this._usage = str;
      return this;
    }
    name(str) {
      if (str === undefined)
        return this._name;
      this._name = str;
      return this;
    }
    helpGroup(heading2) {
      if (heading2 === undefined)
        return this._helpGroupHeading ?? "";
      this._helpGroupHeading = heading2;
      return this;
    }
    commandsGroup(heading2) {
      if (heading2 === undefined)
        return this._defaultCommandGroup ?? "";
      this._defaultCommandGroup = heading2;
      return this;
    }
    optionsGroup(heading2) {
      if (heading2 === undefined)
        return this._defaultOptionGroup ?? "";
      this._defaultOptionGroup = heading2;
      return this;
    }
    _initOptionGroup(option) {
      if (this._defaultOptionGroup && !option.helpGroupHeading)
        option.helpGroup(this._defaultOptionGroup);
    }
    _initCommandGroup(cmd) {
      if (this._defaultCommandGroup && !cmd.helpGroup())
        cmd.helpGroup(this._defaultCommandGroup);
    }
    nameFromFilename(filename) {
      this._name = path7.basename(filename, path7.extname(filename));
      return this;
    }
    executableDir(path8) {
      if (path8 === undefined)
        return this._executableDir;
      this._executableDir = path8;
      return this;
    }
    helpInformation(contextOptions) {
      const helper2 = this.createHelp();
      const context = this._getOutputContext(contextOptions);
      helper2.prepareContext({
        error: context.error,
        helpWidth: context.helpWidth,
        outputHasColors: context.hasColors
      });
      const text5 = helper2.formatHelp(this, helper2);
      if (context.hasColors)
        return text5;
      return this._outputConfiguration.stripColor(text5);
    }
    _getOutputContext(contextOptions) {
      contextOptions = contextOptions || {};
      const error = !!contextOptions.error;
      let baseWrite;
      let hasColors;
      let helpWidth;
      if (error) {
        baseWrite = (str) => this._outputConfiguration.writeErr(str);
        hasColors = this._outputConfiguration.getErrHasColors();
        helpWidth = this._outputConfiguration.getErrHelpWidth();
      } else {
        baseWrite = (str) => this._outputConfiguration.writeOut(str);
        hasColors = this._outputConfiguration.getOutHasColors();
        helpWidth = this._outputConfiguration.getOutHelpWidth();
      }
      const write = (str) => {
        if (!hasColors)
          str = this._outputConfiguration.stripColor(str);
        return baseWrite(str);
      };
      return { error, write, hasColors, helpWidth };
    }
    outputHelp(contextOptions) {
      let deprecatedCallback;
      if (typeof contextOptions === "function") {
        deprecatedCallback = contextOptions;
        contextOptions = undefined;
      }
      const outputContext = this._getOutputContext(contextOptions);
      const eventContext = {
        error: outputContext.error,
        write: outputContext.write,
        command: this
      };
      this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", eventContext));
      this.emit("beforeHelp", eventContext);
      let helpInformation = this.helpInformation({ error: outputContext.error });
      if (deprecatedCallback) {
        helpInformation = deprecatedCallback(helpInformation);
        if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
          throw new Error("outputHelp callback must return a string or a Buffer");
        }
      }
      outputContext.write(helpInformation);
      if (this._getHelpOption()?.long) {
        this.emit(this._getHelpOption().long);
      }
      this.emit("afterHelp", eventContext);
      this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", eventContext));
    }
    helpOption(flags, description) {
      if (typeof flags === "boolean") {
        if (flags) {
          if (this._helpOption === null)
            this._helpOption = undefined;
          if (this._defaultOptionGroup) {
            this._initOptionGroup(this._getHelpOption());
          }
        } else {
          this._helpOption = null;
        }
        return this;
      }
      this._helpOption = this.createOption(flags ?? "-h, --help", description ?? "display help for command");
      if (flags || description)
        this._initOptionGroup(this._helpOption);
      return this;
    }
    _getHelpOption() {
      if (this._helpOption === undefined) {
        this.helpOption(undefined, undefined);
      }
      return this._helpOption;
    }
    addHelpOption(option) {
      this._helpOption = option;
      this._initOptionGroup(option);
      return this;
    }
    help(contextOptions) {
      this.outputHelp(contextOptions);
      let exitCode = Number(process16.exitCode ?? 0);
      if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
        exitCode = 1;
      }
      this._exit(exitCode, "commander.help", "(outputHelp)");
    }
    addHelpText(position3, text5) {
      const allowedValues = ["beforeAll", "before", "after", "afterAll"];
      if (!allowedValues.includes(position3)) {
        throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
      }
      const helpEvent = `${position3}Help`;
      this.on(helpEvent, (context) => {
        let helpStr;
        if (typeof text5 === "function") {
          helpStr = text5({ error: context.error, command: context.command });
        } else {
          helpStr = text5;
        }
        if (helpStr) {
          context.write(`${helpStr}
`);
        }
      });
      return this;
    }
    _outputHelpIfRequested(args) {
      const helpOption = this._getHelpOption();
      const helpRequested = helpOption && args.find((arg2) => helpOption.is(arg2));
      if (helpRequested) {
        this.outputHelp();
        this._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
  }
  function incrementNodeInspectorPort(args) {
    return args.map((arg2) => {
      if (!arg2.startsWith("--inspect")) {
        return arg2;
      }
      let debugOption;
      let debugHost = "127.0.0.1";
      let debugPort = "9229";
      let match2;
      if ((match2 = arg2.match(/^(--inspect(-brk)?)$/)) !== null) {
        debugOption = match2[1];
      } else if ((match2 = arg2.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match2[1];
        if (/^\d+$/.test(match2[3])) {
          debugPort = match2[3];
        } else {
          debugHost = match2[3];
        }
      } else if ((match2 = arg2.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        debugOption = match2[1];
        debugHost = match2[3];
        debugPort = match2[4];
      }
      if (debugOption && debugPort !== "0") {
        return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
      }
      return arg2;
    });
  }
  function useColor() {
    if (process16.env.NO_COLOR || process16.env.FORCE_COLOR === "0" || process16.env.FORCE_COLOR === "false")
      return false;
    if (process16.env.FORCE_COLOR || process16.env.CLICOLOR_FORCE !== undefined)
      return true;
    return;
  }
  exports.Command = Command;
  exports.useColor = useColor;
});

// node_modules/commander/index.js
var require_commander = __commonJS((exports) => {
  var { Argument } = require_argument();
  var { Command } = require_command();
  var { CommanderError, InvalidArgumentError } = require_error();
  var { Help } = require_help();
  var { Option } = require_option();
  exports.program = new Command;
  exports.createCommand = (name) => new Command(name);
  exports.createOption = (flags, description) => new Option(flags, description);
  exports.createArgument = (name, description) => new Argument(name, description);
  exports.Command = Command;
  exports.Option = Option;
  exports.Argument = Argument;
  exports.Help = Help;
  exports.CommanderError = CommanderError;
  exports.InvalidArgumentError = InvalidArgumentError;
  exports.InvalidOptionArgumentError = InvalidArgumentError;
});

// index.ts
import * as fs6 from "fs";
import * as path7 from "path";

// node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// node_modules/unified/lib/index.js
var import_extend = __toESM(require_extend(), 1);

// node_modules/devlop/lib/development.js
var codesWarned = new Set;

class AssertionError extends Error {
  name = "Assertion";
  code = "ERR_ASSERTION";
  constructor(message, actual, expected, operator, generated) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
}
function ok(value, message) {
  assert(Boolean(value), false, true, "ok", "Expected value to be truthy", message);
}
function assert(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(userMessage || defaultMessage, actual, expected, operator, !userMessage);
  }
}

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index < values.length) {
        if (output[index] === null || output[index] === undefined) {
          output[index] = values[index];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError("Expected `middelware` to be a function, not " + middelware);
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = error;
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
// node_modules/vfile-message/lib/index.js
class VFileMessage extends Error {
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = undefined;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || undefined;
    this.cause = options.cause || undefined;
    this.column = start ? start.column : undefined;
    this.fatal = undefined;
    this.file = "";
    this.message = reason;
    this.line = start ? start.line : undefined;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || undefined;
    this.reason = this.message;
    this.ruleId = options.ruleId || undefined;
    this.source = options.source || undefined;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual = undefined;
    this.expected = undefined;
    this.note = undefined;
    this.url = undefined;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = undefined;
VFileMessage.prototype.line = undefined;
VFileMessage.prototype.ancestors = undefined;
VFileMessage.prototype.cause = undefined;
VFileMessage.prototype.fatal = undefined;
VFileMessage.prototype.place = undefined;
VFileMessage.prototype.ruleId = undefined;
VFileMessage.prototype.source = undefined;
// node_modules/vfile/lib/minpath.js
import { default as default2 } from "node:path";

// node_modules/vfile/lib/minproc.js
import { default as default3 } from "node:process";

// node_modules/vfile/lib/minurl.js
import { fileURLToPath } from "node:url";

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return Boolean(fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && fileUrlOrPath.auth === undefined);
}
// node_modules/vfile/lib/index.js
var order = [
  "history",
  "path",
  "basename",
  "stem",
  "extname",
  "dirname"
];

class VFile {
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : default3.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const field2 = order[index2];
      if (field2 in options && options[field2] !== undefined && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  get basename() {
    return typeof this.path === "string" ? default2.basename(this.path) : undefined;
  }
  set basename(basename) {
    assertNonEmpty(basename, "basename");
    assertPart(basename, "basename");
    this.path = default2.join(this.dirname || "", basename);
  }
  get dirname() {
    return typeof this.path === "string" ? default2.dirname(this.path) : undefined;
  }
  set dirname(dirname) {
    assertPath(this.basename, "dirname");
    this.path = default2.join(dirname || "", this.basename);
  }
  get extname() {
    return typeof this.path === "string" ? default2.extname(this.path) : undefined;
  }
  set extname(extname) {
    assertPart(extname, "extname");
    assertPath(this.dirname, "extname");
    if (extname) {
      if (extname.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = default2.join(this.dirname, this.stem + (extname || ""));
  }
  get path() {
    return this.history[this.history.length - 1];
  }
  set path(path) {
    if (isUrl(path)) {
      path = fileURLToPath(path);
    }
    assertNonEmpty(path, "path");
    if (this.path !== path) {
      this.history.push(path);
    }
  }
  get stem() {
    return typeof this.path === "string" ? default2.basename(this.path, this.extname) : undefined;
  }
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = default2.join(this.dirname || "", stem + (this.extname || ""));
  }
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = undefined;
    return message;
  }
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(causeOrReason, optionsOrParentOrPlace, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  toString(encoding) {
    if (this.value === undefined) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || undefined);
    return decoder.decode(this.value);
  }
}
function assertPart(part, name) {
  if (part && part.includes(default2.sep)) {
    throw new Error("`" + name + "` cannot be a path: did not expect `" + default2.sep + "`");
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath(path, name) {
  if (!path) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function isUint8Array(value) {
  return Boolean(value && typeof value === "object" && "byteLength" in value && "byteOffset" in value);
}
// node_modules/unified/lib/callable-instance.js
var CallableInstance = function(property) {
  const self2 = this;
  const constr = self2.constructor;
  const proto = constr.prototype;
  const value = proto[property];
  const apply = function() {
    return value.apply(apply, arguments);
  };
  Object.setPrototypeOf(apply, proto);
  return apply;
};

// node_modules/unified/lib/index.js
var own = {}.hasOwnProperty;

class Processor extends CallableInstance {
  constructor() {
    super("copy");
    this.Compiler = undefined;
    this.Parser = undefined;
    this.attachers = [];
    this.compiler = undefined;
    this.freezeIndex = -1;
    this.frozen = undefined;
    this.namespace = {};
    this.parser = undefined;
    this.transformers = trough();
  }
  copy() {
    const destination = new Processor;
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data(import_extend.default(true, {}, this.namespace));
    return destination;
  }
  data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key] = value;
        return this;
      }
      return own.call(this.namespace, key) && this.namespace[key] || undefined;
    }
    if (key) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key;
      return this;
    }
    return this.namespace;
  }
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = this;
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = undefined;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(undefined, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = self2.parse(realFile);
      self2.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = tree;
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(error, file2);
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(undefined, file2);
        }
      }
    }
  }
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = undefined;
    }
    return done ? executor(undefined, done) : new Promise(executor);
    function executor(resolve, reject) {
      ok(typeof file !== "function", "`file` cant be a `done` anymore, we checked");
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = outputTree || tree;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(undefined, resultingTree, file2);
        }
      }
    }
  }
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler);
    assertNode(tree);
    return compiler(tree, realFile);
  }
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === undefined) {} else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = value2;
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = import_extend.default(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === undefined) {} else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
          primary = import_extend.default(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
}
var unified = new Processor().freeze();
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error("Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
  }
}
function assertNode(node) {
  if (!isPlainObject(node) || typeof node.type !== "string") {
    throw new TypeError("Expected node, got `" + node + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(value && typeof value === "object" && "message" in value && "messages" in value);
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array2(value);
}
function isUint8Array2(value) {
  return Boolean(value && typeof value === "object" && "byteLength" in value && "byteOffset" in value);
}
// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}
// node_modules/character-entities/index.js
var characterEntities = {
  AElig: "",
  AMP: "&",
  Aacute: "",
  Abreve: "",
  Acirc: "",
  Acy: "",
  Afr: "\uD835\uDD04",
  Agrave: "",
  Alpha: "",
  Amacr: "",
  And: "",
  Aogon: "",
  Aopf: "\uD835\uDD38",
  ApplyFunction: "",
  Aring: "",
  Ascr: "\uD835\uDC9C",
  Assign: "",
  Atilde: "",
  Auml: "",
  Backslash: "",
  Barv: "",
  Barwed: "",
  Bcy: "",
  Because: "",
  Bernoullis: "",
  Beta: "",
  Bfr: "\uD835\uDD05",
  Bopf: "\uD835\uDD39",
  Breve: "",
  Bscr: "",
  Bumpeq: "",
  CHcy: "",
  COPY: "",
  Cacute: "",
  Cap: "",
  CapitalDifferentialD: "",
  Cayleys: "",
  Ccaron: "",
  Ccedil: "",
  Ccirc: "",
  Cconint: "",
  Cdot: "",
  Cedilla: "",
  CenterDot: "",
  Cfr: "",
  Chi: "",
  CircleDot: "",
  CircleMinus: "",
  CirclePlus: "",
  CircleTimes: "",
  ClockwiseContourIntegral: "",
  CloseCurlyDoubleQuote: "",
  CloseCurlyQuote: "",
  Colon: "",
  Colone: "",
  Congruent: "",
  Conint: "",
  ContourIntegral: "",
  Copf: "",
  Coproduct: "",
  CounterClockwiseContourIntegral: "",
  Cross: "",
  Cscr: "\uD835\uDC9E",
  Cup: "",
  CupCap: "",
  DD: "",
  DDotrahd: "",
  DJcy: "",
  DScy: "",
  DZcy: "",
  Dagger: "",
  Darr: "",
  Dashv: "",
  Dcaron: "",
  Dcy: "",
  Del: "",
  Delta: "",
  Dfr: "\uD835\uDD07",
  DiacriticalAcute: "",
  DiacriticalDot: "",
  DiacriticalDoubleAcute: "",
  DiacriticalGrave: "`",
  DiacriticalTilde: "",
  Diamond: "",
  DifferentialD: "",
  Dopf: "\uD835\uDD3B",
  Dot: "",
  DotDot: "",
  DotEqual: "",
  DoubleContourIntegral: "",
  DoubleDot: "",
  DoubleDownArrow: "",
  DoubleLeftArrow: "",
  DoubleLeftRightArrow: "",
  DoubleLeftTee: "",
  DoubleLongLeftArrow: "",
  DoubleLongLeftRightArrow: "",
  DoubleLongRightArrow: "",
  DoubleRightArrow: "",
  DoubleRightTee: "",
  DoubleUpArrow: "",
  DoubleUpDownArrow: "",
  DoubleVerticalBar: "",
  DownArrow: "",
  DownArrowBar: "",
  DownArrowUpArrow: "",
  DownBreve: "",
  DownLeftRightVector: "",
  DownLeftTeeVector: "",
  DownLeftVector: "",
  DownLeftVectorBar: "",
  DownRightTeeVector: "",
  DownRightVector: "",
  DownRightVectorBar: "",
  DownTee: "",
  DownTeeArrow: "",
  Downarrow: "",
  Dscr: "\uD835\uDC9F",
  Dstrok: "",
  ENG: "",
  ETH: "",
  Eacute: "",
  Ecaron: "",
  Ecirc: "",
  Ecy: "",
  Edot: "",
  Efr: "\uD835\uDD08",
  Egrave: "",
  Element: "",
  Emacr: "",
  EmptySmallSquare: "",
  EmptyVerySmallSquare: "",
  Eogon: "",
  Eopf: "\uD835\uDD3C",
  Epsilon: "",
  Equal: "",
  EqualTilde: "",
  Equilibrium: "",
  Escr: "",
  Esim: "",
  Eta: "",
  Euml: "",
  Exists: "",
  ExponentialE: "",
  Fcy: "",
  Ffr: "\uD835\uDD09",
  FilledSmallSquare: "",
  FilledVerySmallSquare: "",
  Fopf: "\uD835\uDD3D",
  ForAll: "",
  Fouriertrf: "",
  Fscr: "",
  GJcy: "",
  GT: ">",
  Gamma: "",
  Gammad: "",
  Gbreve: "",
  Gcedil: "",
  Gcirc: "",
  Gcy: "",
  Gdot: "",
  Gfr: "\uD835\uDD0A",
  Gg: "",
  Gopf: "\uD835\uDD3E",
  GreaterEqual: "",
  GreaterEqualLess: "",
  GreaterFullEqual: "",
  GreaterGreater: "",
  GreaterLess: "",
  GreaterSlantEqual: "",
  GreaterTilde: "",
  Gscr: "\uD835\uDCA2",
  Gt: "",
  HARDcy: "",
  Hacek: "",
  Hat: "^",
  Hcirc: "",
  Hfr: "",
  HilbertSpace: "",
  Hopf: "",
  HorizontalLine: "",
  Hscr: "",
  Hstrok: "",
  HumpDownHump: "",
  HumpEqual: "",
  IEcy: "",
  IJlig: "",
  IOcy: "",
  Iacute: "",
  Icirc: "",
  Icy: "",
  Idot: "",
  Ifr: "",
  Igrave: "",
  Im: "",
  Imacr: "",
  ImaginaryI: "",
  Implies: "",
  Int: "",
  Integral: "",
  Intersection: "",
  InvisibleComma: "",
  InvisibleTimes: "",
  Iogon: "",
  Iopf: "\uD835\uDD40",
  Iota: "",
  Iscr: "",
  Itilde: "",
  Iukcy: "",
  Iuml: "",
  Jcirc: "",
  Jcy: "",
  Jfr: "\uD835\uDD0D",
  Jopf: "\uD835\uDD41",
  Jscr: "\uD835\uDCA5",
  Jsercy: "",
  Jukcy: "",
  KHcy: "",
  KJcy: "",
  Kappa: "",
  Kcedil: "",
  Kcy: "",
  Kfr: "\uD835\uDD0E",
  Kopf: "\uD835\uDD42",
  Kscr: "\uD835\uDCA6",
  LJcy: "",
  LT: "<",
  Lacute: "",
  Lambda: "",
  Lang: "",
  Laplacetrf: "",
  Larr: "",
  Lcaron: "",
  Lcedil: "",
  Lcy: "",
  LeftAngleBracket: "",
  LeftArrow: "",
  LeftArrowBar: "",
  LeftArrowRightArrow: "",
  LeftCeiling: "",
  LeftDoubleBracket: "",
  LeftDownTeeVector: "",
  LeftDownVector: "",
  LeftDownVectorBar: "",
  LeftFloor: "",
  LeftRightArrow: "",
  LeftRightVector: "",
  LeftTee: "",
  LeftTeeArrow: "",
  LeftTeeVector: "",
  LeftTriangle: "",
  LeftTriangleBar: "",
  LeftTriangleEqual: "",
  LeftUpDownVector: "",
  LeftUpTeeVector: "",
  LeftUpVector: "",
  LeftUpVectorBar: "",
  LeftVector: "",
  LeftVectorBar: "",
  Leftarrow: "",
  Leftrightarrow: "",
  LessEqualGreater: "",
  LessFullEqual: "",
  LessGreater: "",
  LessLess: "",
  LessSlantEqual: "",
  LessTilde: "",
  Lfr: "\uD835\uDD0F",
  Ll: "",
  Lleftarrow: "",
  Lmidot: "",
  LongLeftArrow: "",
  LongLeftRightArrow: "",
  LongRightArrow: "",
  Longleftarrow: "",
  Longleftrightarrow: "",
  Longrightarrow: "",
  Lopf: "\uD835\uDD43",
  LowerLeftArrow: "",
  LowerRightArrow: "",
  Lscr: "",
  Lsh: "",
  Lstrok: "",
  Lt: "",
  Map: "",
  Mcy: "",
  MediumSpace: "",
  Mellintrf: "",
  Mfr: "\uD835\uDD10",
  MinusPlus: "",
  Mopf: "\uD835\uDD44",
  Mscr: "",
  Mu: "",
  NJcy: "",
  Nacute: "",
  Ncaron: "",
  Ncedil: "",
  Ncy: "",
  NegativeMediumSpace: "",
  NegativeThickSpace: "",
  NegativeThinSpace: "",
  NegativeVeryThinSpace: "",
  NestedGreaterGreater: "",
  NestedLessLess: "",
  NewLine: `
`,
  Nfr: "\uD835\uDD11",
  NoBreak: "",
  NonBreakingSpace: "",
  Nopf: "",
  Not: "",
  NotCongruent: "",
  NotCupCap: "",
  NotDoubleVerticalBar: "",
  NotElement: "",
  NotEqual: "",
  NotEqualTilde: "",
  NotExists: "",
  NotGreater: "",
  NotGreaterEqual: "",
  NotGreaterFullEqual: "",
  NotGreaterGreater: "",
  NotGreaterLess: "",
  NotGreaterSlantEqual: "",
  NotGreaterTilde: "",
  NotHumpDownHump: "",
  NotHumpEqual: "",
  NotLeftTriangle: "",
  NotLeftTriangleBar: "",
  NotLeftTriangleEqual: "",
  NotLess: "",
  NotLessEqual: "",
  NotLessGreater: "",
  NotLessLess: "",
  NotLessSlantEqual: "",
  NotLessTilde: "",
  NotNestedGreaterGreater: "",
  NotNestedLessLess: "",
  NotPrecedes: "",
  NotPrecedesEqual: "",
  NotPrecedesSlantEqual: "",
  NotReverseElement: "",
  NotRightTriangle: "",
  NotRightTriangleBar: "",
  NotRightTriangleEqual: "",
  NotSquareSubset: "",
  NotSquareSubsetEqual: "",
  NotSquareSuperset: "",
  NotSquareSupersetEqual: "",
  NotSubset: "",
  NotSubsetEqual: "",
  NotSucceeds: "",
  NotSucceedsEqual: "",
  NotSucceedsSlantEqual: "",
  NotSucceedsTilde: "",
  NotSuperset: "",
  NotSupersetEqual: "",
  NotTilde: "",
  NotTildeEqual: "",
  NotTildeFullEqual: "",
  NotTildeTilde: "",
  NotVerticalBar: "",
  Nscr: "\uD835\uDCA9",
  Ntilde: "",
  Nu: "",
  OElig: "",
  Oacute: "",
  Ocirc: "",
  Ocy: "",
  Odblac: "",
  Ofr: "\uD835\uDD12",
  Ograve: "",
  Omacr: "",
  Omega: "",
  Omicron: "",
  Oopf: "\uD835\uDD46",
  OpenCurlyDoubleQuote: "",
  OpenCurlyQuote: "",
  Or: "",
  Oscr: "\uD835\uDCAA",
  Oslash: "",
  Otilde: "",
  Otimes: "",
  Ouml: "",
  OverBar: "",
  OverBrace: "",
  OverBracket: "",
  OverParenthesis: "",
  PartialD: "",
  Pcy: "",
  Pfr: "\uD835\uDD13",
  Phi: "",
  Pi: "",
  PlusMinus: "",
  Poincareplane: "",
  Popf: "",
  Pr: "",
  Precedes: "",
  PrecedesEqual: "",
  PrecedesSlantEqual: "",
  PrecedesTilde: "",
  Prime: "",
  Product: "",
  Proportion: "",
  Proportional: "",
  Pscr: "\uD835\uDCAB",
  Psi: "",
  QUOT: '"',
  Qfr: "\uD835\uDD14",
  Qopf: "",
  Qscr: "\uD835\uDCAC",
  RBarr: "",
  REG: "",
  Racute: "",
  Rang: "",
  Rarr: "",
  Rarrtl: "",
  Rcaron: "",
  Rcedil: "",
  Rcy: "",
  Re: "",
  ReverseElement: "",
  ReverseEquilibrium: "",
  ReverseUpEquilibrium: "",
  Rfr: "",
  Rho: "",
  RightAngleBracket: "",
  RightArrow: "",
  RightArrowBar: "",
  RightArrowLeftArrow: "",
  RightCeiling: "",
  RightDoubleBracket: "",
  RightDownTeeVector: "",
  RightDownVector: "",
  RightDownVectorBar: "",
  RightFloor: "",
  RightTee: "",
  RightTeeArrow: "",
  RightTeeVector: "",
  RightTriangle: "",
  RightTriangleBar: "",
  RightTriangleEqual: "",
  RightUpDownVector: "",
  RightUpTeeVector: "",
  RightUpVector: "",
  RightUpVectorBar: "",
  RightVector: "",
  RightVectorBar: "",
  Rightarrow: "",
  Ropf: "",
  RoundImplies: "",
  Rrightarrow: "",
  Rscr: "",
  Rsh: "",
  RuleDelayed: "",
  SHCHcy: "",
  SHcy: "",
  SOFTcy: "",
  Sacute: "",
  Sc: "",
  Scaron: "",
  Scedil: "",
  Scirc: "",
  Scy: "",
  Sfr: "\uD835\uDD16",
  ShortDownArrow: "",
  ShortLeftArrow: "",
  ShortRightArrow: "",
  ShortUpArrow: "",
  Sigma: "",
  SmallCircle: "",
  Sopf: "\uD835\uDD4A",
  Sqrt: "",
  Square: "",
  SquareIntersection: "",
  SquareSubset: "",
  SquareSubsetEqual: "",
  SquareSuperset: "",
  SquareSupersetEqual: "",
  SquareUnion: "",
  Sscr: "\uD835\uDCAE",
  Star: "",
  Sub: "",
  Subset: "",
  SubsetEqual: "",
  Succeeds: "",
  SucceedsEqual: "",
  SucceedsSlantEqual: "",
  SucceedsTilde: "",
  SuchThat: "",
  Sum: "",
  Sup: "",
  Superset: "",
  SupersetEqual: "",
  Supset: "",
  THORN: "",
  TRADE: "",
  TSHcy: "",
  TScy: "",
  Tab: "\t",
  Tau: "",
  Tcaron: "",
  Tcedil: "",
  Tcy: "",
  Tfr: "\uD835\uDD17",
  Therefore: "",
  Theta: "",
  ThickSpace: "",
  ThinSpace: "",
  Tilde: "",
  TildeEqual: "",
  TildeFullEqual: "",
  TildeTilde: "",
  Topf: "\uD835\uDD4B",
  TripleDot: "",
  Tscr: "\uD835\uDCAF",
  Tstrok: "",
  Uacute: "",
  Uarr: "",
  Uarrocir: "",
  Ubrcy: "",
  Ubreve: "",
  Ucirc: "",
  Ucy: "",
  Udblac: "",
  Ufr: "\uD835\uDD18",
  Ugrave: "",
  Umacr: "",
  UnderBar: "_",
  UnderBrace: "",
  UnderBracket: "",
  UnderParenthesis: "",
  Union: "",
  UnionPlus: "",
  Uogon: "",
  Uopf: "\uD835\uDD4C",
  UpArrow: "",
  UpArrowBar: "",
  UpArrowDownArrow: "",
  UpDownArrow: "",
  UpEquilibrium: "",
  UpTee: "",
  UpTeeArrow: "",
  Uparrow: "",
  Updownarrow: "",
  UpperLeftArrow: "",
  UpperRightArrow: "",
  Upsi: "",
  Upsilon: "",
  Uring: "",
  Uscr: "\uD835\uDCB0",
  Utilde: "",
  Uuml: "",
  VDash: "",
  Vbar: "",
  Vcy: "",
  Vdash: "",
  Vdashl: "",
  Vee: "",
  Verbar: "",
  Vert: "",
  VerticalBar: "",
  VerticalLine: "|",
  VerticalSeparator: "",
  VerticalTilde: "",
  VeryThinSpace: "",
  Vfr: "\uD835\uDD19",
  Vopf: "\uD835\uDD4D",
  Vscr: "\uD835\uDCB1",
  Vvdash: "",
  Wcirc: "",
  Wedge: "",
  Wfr: "\uD835\uDD1A",
  Wopf: "\uD835\uDD4E",
  Wscr: "\uD835\uDCB2",
  Xfr: "\uD835\uDD1B",
  Xi: "",
  Xopf: "\uD835\uDD4F",
  Xscr: "\uD835\uDCB3",
  YAcy: "",
  YIcy: "",
  YUcy: "",
  Yacute: "",
  Ycirc: "",
  Ycy: "",
  Yfr: "\uD835\uDD1C",
  Yopf: "\uD835\uDD50",
  Yscr: "\uD835\uDCB4",
  Yuml: "",
  ZHcy: "",
  Zacute: "",
  Zcaron: "",
  Zcy: "",
  Zdot: "",
  ZeroWidthSpace: "",
  Zeta: "",
  Zfr: "",
  Zopf: "",
  Zscr: "\uD835\uDCB5",
  aacute: "",
  abreve: "",
  ac: "",
  acE: "",
  acd: "",
  acirc: "",
  acute: "",
  acy: "",
  aelig: "",
  af: "",
  afr: "\uD835\uDD1E",
  agrave: "",
  alefsym: "",
  aleph: "",
  alpha: "",
  amacr: "",
  amalg: "",
  amp: "&",
  and: "",
  andand: "",
  andd: "",
  andslope: "",
  andv: "",
  ang: "",
  ange: "",
  angle: "",
  angmsd: "",
  angmsdaa: "",
  angmsdab: "",
  angmsdac: "",
  angmsdad: "",
  angmsdae: "",
  angmsdaf: "",
  angmsdag: "",
  angmsdah: "",
  angrt: "",
  angrtvb: "",
  angrtvbd: "",
  angsph: "",
  angst: "",
  angzarr: "",
  aogon: "",
  aopf: "\uD835\uDD52",
  ap: "",
  apE: "",
  apacir: "",
  ape: "",
  apid: "",
  apos: "'",
  approx: "",
  approxeq: "",
  aring: "",
  ascr: "\uD835\uDCB6",
  ast: "*",
  asymp: "",
  asympeq: "",
  atilde: "",
  auml: "",
  awconint: "",
  awint: "",
  bNot: "",
  backcong: "",
  backepsilon: "",
  backprime: "",
  backsim: "",
  backsimeq: "",
  barvee: "",
  barwed: "",
  barwedge: "",
  bbrk: "",
  bbrktbrk: "",
  bcong: "",
  bcy: "",
  bdquo: "",
  becaus: "",
  because: "",
  bemptyv: "",
  bepsi: "",
  bernou: "",
  beta: "",
  beth: "",
  between: "",
  bfr: "\uD835\uDD1F",
  bigcap: "",
  bigcirc: "",
  bigcup: "",
  bigodot: "",
  bigoplus: "",
  bigotimes: "",
  bigsqcup: "",
  bigstar: "",
  bigtriangledown: "",
  bigtriangleup: "",
  biguplus: "",
  bigvee: "",
  bigwedge: "",
  bkarow: "",
  blacklozenge: "",
  blacksquare: "",
  blacktriangle: "",
  blacktriangledown: "",
  blacktriangleleft: "",
  blacktriangleright: "",
  blank: "",
  blk12: "",
  blk14: "",
  blk34: "",
  block: "",
  bne: "=",
  bnequiv: "",
  bnot: "",
  bopf: "\uD835\uDD53",
  bot: "",
  bottom: "",
  bowtie: "",
  boxDL: "",
  boxDR: "",
  boxDl: "",
  boxDr: "",
  boxH: "",
  boxHD: "",
  boxHU: "",
  boxHd: "",
  boxHu: "",
  boxUL: "",
  boxUR: "",
  boxUl: "",
  boxUr: "",
  boxV: "",
  boxVH: "",
  boxVL: "",
  boxVR: "",
  boxVh: "",
  boxVl: "",
  boxVr: "",
  boxbox: "",
  boxdL: "",
  boxdR: "",
  boxdl: "",
  boxdr: "",
  boxh: "",
  boxhD: "",
  boxhU: "",
  boxhd: "",
  boxhu: "",
  boxminus: "",
  boxplus: "",
  boxtimes: "",
  boxuL: "",
  boxuR: "",
  boxul: "",
  boxur: "",
  boxv: "",
  boxvH: "",
  boxvL: "",
  boxvR: "",
  boxvh: "",
  boxvl: "",
  boxvr: "",
  bprime: "",
  breve: "",
  brvbar: "",
  bscr: "\uD835\uDCB7",
  bsemi: "",
  bsim: "",
  bsime: "",
  bsol: "\\",
  bsolb: "",
  bsolhsub: "",
  bull: "",
  bullet: "",
  bump: "",
  bumpE: "",
  bumpe: "",
  bumpeq: "",
  cacute: "",
  cap: "",
  capand: "",
  capbrcup: "",
  capcap: "",
  capcup: "",
  capdot: "",
  caps: "",
  caret: "",
  caron: "",
  ccaps: "",
  ccaron: "",
  ccedil: "",
  ccirc: "",
  ccups: "",
  ccupssm: "",
  cdot: "",
  cedil: "",
  cemptyv: "",
  cent: "",
  centerdot: "",
  cfr: "\uD835\uDD20",
  chcy: "",
  check: "",
  checkmark: "",
  chi: "",
  cir: "",
  cirE: "",
  circ: "",
  circeq: "",
  circlearrowleft: "",
  circlearrowright: "",
  circledR: "",
  circledS: "",
  circledast: "",
  circledcirc: "",
  circleddash: "",
  cire: "",
  cirfnint: "",
  cirmid: "",
  cirscir: "",
  clubs: "",
  clubsuit: "",
  colon: ":",
  colone: "",
  coloneq: "",
  comma: ",",
  commat: "@",
  comp: "",
  compfn: "",
  complement: "",
  complexes: "",
  cong: "",
  congdot: "",
  conint: "",
  copf: "\uD835\uDD54",
  coprod: "",
  copy: "",
  copysr: "",
  crarr: "",
  cross: "",
  cscr: "\uD835\uDCB8",
  csub: "",
  csube: "",
  csup: "",
  csupe: "",
  ctdot: "",
  cudarrl: "",
  cudarrr: "",
  cuepr: "",
  cuesc: "",
  cularr: "",
  cularrp: "",
  cup: "",
  cupbrcap: "",
  cupcap: "",
  cupcup: "",
  cupdot: "",
  cupor: "",
  cups: "",
  curarr: "",
  curarrm: "",
  curlyeqprec: "",
  curlyeqsucc: "",
  curlyvee: "",
  curlywedge: "",
  curren: "",
  curvearrowleft: "",
  curvearrowright: "",
  cuvee: "",
  cuwed: "",
  cwconint: "",
  cwint: "",
  cylcty: "",
  dArr: "",
  dHar: "",
  dagger: "",
  daleth: "",
  darr: "",
  dash: "",
  dashv: "",
  dbkarow: "",
  dblac: "",
  dcaron: "",
  dcy: "",
  dd: "",
  ddagger: "",
  ddarr: "",
  ddotseq: "",
  deg: "",
  delta: "",
  demptyv: "",
  dfisht: "",
  dfr: "\uD835\uDD21",
  dharl: "",
  dharr: "",
  diam: "",
  diamond: "",
  diamondsuit: "",
  diams: "",
  die: "",
  digamma: "",
  disin: "",
  div: "",
  divide: "",
  divideontimes: "",
  divonx: "",
  djcy: "",
  dlcorn: "",
  dlcrop: "",
  dollar: "$",
  dopf: "\uD835\uDD55",
  dot: "",
  doteq: "",
  doteqdot: "",
  dotminus: "",
  dotplus: "",
  dotsquare: "",
  doublebarwedge: "",
  downarrow: "",
  downdownarrows: "",
  downharpoonleft: "",
  downharpoonright: "",
  drbkarow: "",
  drcorn: "",
  drcrop: "",
  dscr: "\uD835\uDCB9",
  dscy: "",
  dsol: "",
  dstrok: "",
  dtdot: "",
  dtri: "",
  dtrif: "",
  duarr: "",
  duhar: "",
  dwangle: "",
  dzcy: "",
  dzigrarr: "",
  eDDot: "",
  eDot: "",
  eacute: "",
  easter: "",
  ecaron: "",
  ecir: "",
  ecirc: "",
  ecolon: "",
  ecy: "",
  edot: "",
  ee: "",
  efDot: "",
  efr: "\uD835\uDD22",
  eg: "",
  egrave: "",
  egs: "",
  egsdot: "",
  el: "",
  elinters: "",
  ell: "",
  els: "",
  elsdot: "",
  emacr: "",
  empty: "",
  emptyset: "",
  emptyv: "",
  emsp13: "",
  emsp14: "",
  emsp: "",
  eng: "",
  ensp: "",
  eogon: "",
  eopf: "\uD835\uDD56",
  epar: "",
  eparsl: "",
  eplus: "",
  epsi: "",
  epsilon: "",
  epsiv: "",
  eqcirc: "",
  eqcolon: "",
  eqsim: "",
  eqslantgtr: "",
  eqslantless: "",
  equals: "=",
  equest: "",
  equiv: "",
  equivDD: "",
  eqvparsl: "",
  erDot: "",
  erarr: "",
  escr: "",
  esdot: "",
  esim: "",
  eta: "",
  eth: "",
  euml: "",
  euro: "",
  excl: "!",
  exist: "",
  expectation: "",
  exponentiale: "",
  fallingdotseq: "",
  fcy: "",
  female: "",
  ffilig: "",
  fflig: "",
  ffllig: "",
  ffr: "\uD835\uDD23",
  filig: "",
  fjlig: "fj",
  flat: "",
  fllig: "",
  fltns: "",
  fnof: "",
  fopf: "\uD835\uDD57",
  forall: "",
  fork: "",
  forkv: "",
  fpartint: "",
  frac12: "",
  frac13: "",
  frac14: "",
  frac15: "",
  frac16: "",
  frac18: "",
  frac23: "",
  frac25: "",
  frac34: "",
  frac35: "",
  frac38: "",
  frac45: "",
  frac56: "",
  frac58: "",
  frac78: "",
  frasl: "",
  frown: "",
  fscr: "\uD835\uDCBB",
  gE: "",
  gEl: "",
  gacute: "",
  gamma: "",
  gammad: "",
  gap: "",
  gbreve: "",
  gcirc: "",
  gcy: "",
  gdot: "",
  ge: "",
  gel: "",
  geq: "",
  geqq: "",
  geqslant: "",
  ges: "",
  gescc: "",
  gesdot: "",
  gesdoto: "",
  gesdotol: "",
  gesl: "",
  gesles: "",
  gfr: "\uD835\uDD24",
  gg: "",
  ggg: "",
  gimel: "",
  gjcy: "",
  gl: "",
  glE: "",
  gla: "",
  glj: "",
  gnE: "",
  gnap: "",
  gnapprox: "",
  gne: "",
  gneq: "",
  gneqq: "",
  gnsim: "",
  gopf: "\uD835\uDD58",
  grave: "`",
  gscr: "",
  gsim: "",
  gsime: "",
  gsiml: "",
  gt: ">",
  gtcc: "",
  gtcir: "",
  gtdot: "",
  gtlPar: "",
  gtquest: "",
  gtrapprox: "",
  gtrarr: "",
  gtrdot: "",
  gtreqless: "",
  gtreqqless: "",
  gtrless: "",
  gtrsim: "",
  gvertneqq: "",
  gvnE: "",
  hArr: "",
  hairsp: "",
  half: "",
  hamilt: "",
  hardcy: "",
  harr: "",
  harrcir: "",
  harrw: "",
  hbar: "",
  hcirc: "",
  hearts: "",
  heartsuit: "",
  hellip: "",
  hercon: "",
  hfr: "\uD835\uDD25",
  hksearow: "",
  hkswarow: "",
  hoarr: "",
  homtht: "",
  hookleftarrow: "",
  hookrightarrow: "",
  hopf: "\uD835\uDD59",
  horbar: "",
  hscr: "\uD835\uDCBD",
  hslash: "",
  hstrok: "",
  hybull: "",
  hyphen: "",
  iacute: "",
  ic: "",
  icirc: "",
  icy: "",
  iecy: "",
  iexcl: "",
  iff: "",
  ifr: "\uD835\uDD26",
  igrave: "",
  ii: "",
  iiiint: "",
  iiint: "",
  iinfin: "",
  iiota: "",
  ijlig: "",
  imacr: "",
  image: "",
  imagline: "",
  imagpart: "",
  imath: "",
  imof: "",
  imped: "",
  in: "",
  incare: "",
  infin: "",
  infintie: "",
  inodot: "",
  int: "",
  intcal: "",
  integers: "",
  intercal: "",
  intlarhk: "",
  intprod: "",
  iocy: "",
  iogon: "",
  iopf: "\uD835\uDD5A",
  iota: "",
  iprod: "",
  iquest: "",
  iscr: "\uD835\uDCBE",
  isin: "",
  isinE: "",
  isindot: "",
  isins: "",
  isinsv: "",
  isinv: "",
  it: "",
  itilde: "",
  iukcy: "",
  iuml: "",
  jcirc: "",
  jcy: "",
  jfr: "\uD835\uDD27",
  jmath: "",
  jopf: "\uD835\uDD5B",
  jscr: "\uD835\uDCBF",
  jsercy: "",
  jukcy: "",
  kappa: "",
  kappav: "",
  kcedil: "",
  kcy: "",
  kfr: "\uD835\uDD28",
  kgreen: "",
  khcy: "",
  kjcy: "",
  kopf: "\uD835\uDD5C",
  kscr: "\uD835\uDCC0",
  lAarr: "",
  lArr: "",
  lAtail: "",
  lBarr: "",
  lE: "",
  lEg: "",
  lHar: "",
  lacute: "",
  laemptyv: "",
  lagran: "",
  lambda: "",
  lang: "",
  langd: "",
  langle: "",
  lap: "",
  laquo: "",
  larr: "",
  larrb: "",
  larrbfs: "",
  larrfs: "",
  larrhk: "",
  larrlp: "",
  larrpl: "",
  larrsim: "",
  larrtl: "",
  lat: "",
  latail: "",
  late: "",
  lates: "",
  lbarr: "",
  lbbrk: "",
  lbrace: "{",
  lbrack: "[",
  lbrke: "",
  lbrksld: "",
  lbrkslu: "",
  lcaron: "",
  lcedil: "",
  lceil: "",
  lcub: "{",
  lcy: "",
  ldca: "",
  ldquo: "",
  ldquor: "",
  ldrdhar: "",
  ldrushar: "",
  ldsh: "",
  le: "",
  leftarrow: "",
  leftarrowtail: "",
  leftharpoondown: "",
  leftharpoonup: "",
  leftleftarrows: "",
  leftrightarrow: "",
  leftrightarrows: "",
  leftrightharpoons: "",
  leftrightsquigarrow: "",
  leftthreetimes: "",
  leg: "",
  leq: "",
  leqq: "",
  leqslant: "",
  les: "",
  lescc: "",
  lesdot: "",
  lesdoto: "",
  lesdotor: "",
  lesg: "",
  lesges: "",
  lessapprox: "",
  lessdot: "",
  lesseqgtr: "",
  lesseqqgtr: "",
  lessgtr: "",
  lesssim: "",
  lfisht: "",
  lfloor: "",
  lfr: "\uD835\uDD29",
  lg: "",
  lgE: "",
  lhard: "",
  lharu: "",
  lharul: "",
  lhblk: "",
  ljcy: "",
  ll: "",
  llarr: "",
  llcorner: "",
  llhard: "",
  lltri: "",
  lmidot: "",
  lmoust: "",
  lmoustache: "",
  lnE: "",
  lnap: "",
  lnapprox: "",
  lne: "",
  lneq: "",
  lneqq: "",
  lnsim: "",
  loang: "",
  loarr: "",
  lobrk: "",
  longleftarrow: "",
  longleftrightarrow: "",
  longmapsto: "",
  longrightarrow: "",
  looparrowleft: "",
  looparrowright: "",
  lopar: "",
  lopf: "\uD835\uDD5D",
  loplus: "",
  lotimes: "",
  lowast: "",
  lowbar: "_",
  loz: "",
  lozenge: "",
  lozf: "",
  lpar: "(",
  lparlt: "",
  lrarr: "",
  lrcorner: "",
  lrhar: "",
  lrhard: "",
  lrm: "",
  lrtri: "",
  lsaquo: "",
  lscr: "\uD835\uDCC1",
  lsh: "",
  lsim: "",
  lsime: "",
  lsimg: "",
  lsqb: "[",
  lsquo: "",
  lsquor: "",
  lstrok: "",
  lt: "<",
  ltcc: "",
  ltcir: "",
  ltdot: "",
  lthree: "",
  ltimes: "",
  ltlarr: "",
  ltquest: "",
  ltrPar: "",
  ltri: "",
  ltrie: "",
  ltrif: "",
  lurdshar: "",
  luruhar: "",
  lvertneqq: "",
  lvnE: "",
  mDDot: "",
  macr: "",
  male: "",
  malt: "",
  maltese: "",
  map: "",
  mapsto: "",
  mapstodown: "",
  mapstoleft: "",
  mapstoup: "",
  marker: "",
  mcomma: "",
  mcy: "",
  mdash: "",
  measuredangle: "",
  mfr: "\uD835\uDD2A",
  mho: "",
  micro: "",
  mid: "",
  midast: "*",
  midcir: "",
  middot: "",
  minus: "",
  minusb: "",
  minusd: "",
  minusdu: "",
  mlcp: "",
  mldr: "",
  mnplus: "",
  models: "",
  mopf: "\uD835\uDD5E",
  mp: "",
  mscr: "\uD835\uDCC2",
  mstpos: "",
  mu: "",
  multimap: "",
  mumap: "",
  nGg: "",
  nGt: "",
  nGtv: "",
  nLeftarrow: "",
  nLeftrightarrow: "",
  nLl: "",
  nLt: "",
  nLtv: "",
  nRightarrow: "",
  nVDash: "",
  nVdash: "",
  nabla: "",
  nacute: "",
  nang: "",
  nap: "",
  napE: "",
  napid: "",
  napos: "",
  napprox: "",
  natur: "",
  natural: "",
  naturals: "",
  nbsp: "",
  nbump: "",
  nbumpe: "",
  ncap: "",
  ncaron: "",
  ncedil: "",
  ncong: "",
  ncongdot: "",
  ncup: "",
  ncy: "",
  ndash: "",
  ne: "",
  neArr: "",
  nearhk: "",
  nearr: "",
  nearrow: "",
  nedot: "",
  nequiv: "",
  nesear: "",
  nesim: "",
  nexist: "",
  nexists: "",
  nfr: "\uD835\uDD2B",
  ngE: "",
  nge: "",
  ngeq: "",
  ngeqq: "",
  ngeqslant: "",
  nges: "",
  ngsim: "",
  ngt: "",
  ngtr: "",
  nhArr: "",
  nharr: "",
  nhpar: "",
  ni: "",
  nis: "",
  nisd: "",
  niv: "",
  njcy: "",
  nlArr: "",
  nlE: "",
  nlarr: "",
  nldr: "",
  nle: "",
  nleftarrow: "",
  nleftrightarrow: "",
  nleq: "",
  nleqq: "",
  nleqslant: "",
  nles: "",
  nless: "",
  nlsim: "",
  nlt: "",
  nltri: "",
  nltrie: "",
  nmid: "",
  nopf: "\uD835\uDD5F",
  not: "",
  notin: "",
  notinE: "",
  notindot: "",
  notinva: "",
  notinvb: "",
  notinvc: "",
  notni: "",
  notniva: "",
  notnivb: "",
  notnivc: "",
  npar: "",
  nparallel: "",
  nparsl: "",
  npart: "",
  npolint: "",
  npr: "",
  nprcue: "",
  npre: "",
  nprec: "",
  npreceq: "",
  nrArr: "",
  nrarr: "",
  nrarrc: "",
  nrarrw: "",
  nrightarrow: "",
  nrtri: "",
  nrtrie: "",
  nsc: "",
  nsccue: "",
  nsce: "",
  nscr: "\uD835\uDCC3",
  nshortmid: "",
  nshortparallel: "",
  nsim: "",
  nsime: "",
  nsimeq: "",
  nsmid: "",
  nspar: "",
  nsqsube: "",
  nsqsupe: "",
  nsub: "",
  nsubE: "",
  nsube: "",
  nsubset: "",
  nsubseteq: "",
  nsubseteqq: "",
  nsucc: "",
  nsucceq: "",
  nsup: "",
  nsupE: "",
  nsupe: "",
  nsupset: "",
  nsupseteq: "",
  nsupseteqq: "",
  ntgl: "",
  ntilde: "",
  ntlg: "",
  ntriangleleft: "",
  ntrianglelefteq: "",
  ntriangleright: "",
  ntrianglerighteq: "",
  nu: "",
  num: "#",
  numero: "",
  numsp: "",
  nvDash: "",
  nvHarr: "",
  nvap: "",
  nvdash: "",
  nvge: "",
  nvgt: ">",
  nvinfin: "",
  nvlArr: "",
  nvle: "",
  nvlt: "<",
  nvltrie: "",
  nvrArr: "",
  nvrtrie: "",
  nvsim: "",
  nwArr: "",
  nwarhk: "",
  nwarr: "",
  nwarrow: "",
  nwnear: "",
  oS: "",
  oacute: "",
  oast: "",
  ocir: "",
  ocirc: "",
  ocy: "",
  odash: "",
  odblac: "",
  odiv: "",
  odot: "",
  odsold: "",
  oelig: "",
  ofcir: "",
  ofr: "\uD835\uDD2C",
  ogon: "",
  ograve: "",
  ogt: "",
  ohbar: "",
  ohm: "",
  oint: "",
  olarr: "",
  olcir: "",
  olcross: "",
  oline: "",
  olt: "",
  omacr: "",
  omega: "",
  omicron: "",
  omid: "",
  ominus: "",
  oopf: "\uD835\uDD60",
  opar: "",
  operp: "",
  oplus: "",
  or: "",
  orarr: "",
  ord: "",
  order: "",
  orderof: "",
  ordf: "",
  ordm: "",
  origof: "",
  oror: "",
  orslope: "",
  orv: "",
  oscr: "",
  oslash: "",
  osol: "",
  otilde: "",
  otimes: "",
  otimesas: "",
  ouml: "",
  ovbar: "",
  par: "",
  para: "",
  parallel: "",
  parsim: "",
  parsl: "",
  part: "",
  pcy: "",
  percnt: "%",
  period: ".",
  permil: "",
  perp: "",
  pertenk: "",
  pfr: "\uD835\uDD2D",
  phi: "",
  phiv: "",
  phmmat: "",
  phone: "",
  pi: "",
  pitchfork: "",
  piv: "",
  planck: "",
  planckh: "",
  plankv: "",
  plus: "+",
  plusacir: "",
  plusb: "",
  pluscir: "",
  plusdo: "",
  plusdu: "",
  pluse: "",
  plusmn: "",
  plussim: "",
  plustwo: "",
  pm: "",
  pointint: "",
  popf: "\uD835\uDD61",
  pound: "",
  pr: "",
  prE: "",
  prap: "",
  prcue: "",
  pre: "",
  prec: "",
  precapprox: "",
  preccurlyeq: "",
  preceq: "",
  precnapprox: "",
  precneqq: "",
  precnsim: "",
  precsim: "",
  prime: "",
  primes: "",
  prnE: "",
  prnap: "",
  prnsim: "",
  prod: "",
  profalar: "",
  profline: "",
  profsurf: "",
  prop: "",
  propto: "",
  prsim: "",
  prurel: "",
  pscr: "\uD835\uDCC5",
  psi: "",
  puncsp: "",
  qfr: "\uD835\uDD2E",
  qint: "",
  qopf: "\uD835\uDD62",
  qprime: "",
  qscr: "\uD835\uDCC6",
  quaternions: "",
  quatint: "",
  quest: "?",
  questeq: "",
  quot: '"',
  rAarr: "",
  rArr: "",
  rAtail: "",
  rBarr: "",
  rHar: "",
  race: "",
  racute: "",
  radic: "",
  raemptyv: "",
  rang: "",
  rangd: "",
  range: "",
  rangle: "",
  raquo: "",
  rarr: "",
  rarrap: "",
  rarrb: "",
  rarrbfs: "",
  rarrc: "",
  rarrfs: "",
  rarrhk: "",
  rarrlp: "",
  rarrpl: "",
  rarrsim: "",
  rarrtl: "",
  rarrw: "",
  ratail: "",
  ratio: "",
  rationals: "",
  rbarr: "",
  rbbrk: "",
  rbrace: "}",
  rbrack: "]",
  rbrke: "",
  rbrksld: "",
  rbrkslu: "",
  rcaron: "",
  rcedil: "",
  rceil: "",
  rcub: "}",
  rcy: "",
  rdca: "",
  rdldhar: "",
  rdquo: "",
  rdquor: "",
  rdsh: "",
  real: "",
  realine: "",
  realpart: "",
  reals: "",
  rect: "",
  reg: "",
  rfisht: "",
  rfloor: "",
  rfr: "\uD835\uDD2F",
  rhard: "",
  rharu: "",
  rharul: "",
  rho: "",
  rhov: "",
  rightarrow: "",
  rightarrowtail: "",
  rightharpoondown: "",
  rightharpoonup: "",
  rightleftarrows: "",
  rightleftharpoons: "",
  rightrightarrows: "",
  rightsquigarrow: "",
  rightthreetimes: "",
  ring: "",
  risingdotseq: "",
  rlarr: "",
  rlhar: "",
  rlm: "",
  rmoust: "",
  rmoustache: "",
  rnmid: "",
  roang: "",
  roarr: "",
  robrk: "",
  ropar: "",
  ropf: "\uD835\uDD63",
  roplus: "",
  rotimes: "",
  rpar: ")",
  rpargt: "",
  rppolint: "",
  rrarr: "",
  rsaquo: "",
  rscr: "\uD835\uDCC7",
  rsh: "",
  rsqb: "]",
  rsquo: "",
  rsquor: "",
  rthree: "",
  rtimes: "",
  rtri: "",
  rtrie: "",
  rtrif: "",
  rtriltri: "",
  ruluhar: "",
  rx: "",
  sacute: "",
  sbquo: "",
  sc: "",
  scE: "",
  scap: "",
  scaron: "",
  sccue: "",
  sce: "",
  scedil: "",
  scirc: "",
  scnE: "",
  scnap: "",
  scnsim: "",
  scpolint: "",
  scsim: "",
  scy: "",
  sdot: "",
  sdotb: "",
  sdote: "",
  seArr: "",
  searhk: "",
  searr: "",
  searrow: "",
  sect: "",
  semi: ";",
  seswar: "",
  setminus: "",
  setmn: "",
  sext: "",
  sfr: "\uD835\uDD30",
  sfrown: "",
  sharp: "",
  shchcy: "",
  shcy: "",
  shortmid: "",
  shortparallel: "",
  shy: "",
  sigma: "",
  sigmaf: "",
  sigmav: "",
  sim: "",
  simdot: "",
  sime: "",
  simeq: "",
  simg: "",
  simgE: "",
  siml: "",
  simlE: "",
  simne: "",
  simplus: "",
  simrarr: "",
  slarr: "",
  smallsetminus: "",
  smashp: "",
  smeparsl: "",
  smid: "",
  smile: "",
  smt: "",
  smte: "",
  smtes: "",
  softcy: "",
  sol: "/",
  solb: "",
  solbar: "",
  sopf: "\uD835\uDD64",
  spades: "",
  spadesuit: "",
  spar: "",
  sqcap: "",
  sqcaps: "",
  sqcup: "",
  sqcups: "",
  sqsub: "",
  sqsube: "",
  sqsubset: "",
  sqsubseteq: "",
  sqsup: "",
  sqsupe: "",
  sqsupset: "",
  sqsupseteq: "",
  squ: "",
  square: "",
  squarf: "",
  squf: "",
  srarr: "",
  sscr: "\uD835\uDCC8",
  ssetmn: "",
  ssmile: "",
  sstarf: "",
  star: "",
  starf: "",
  straightepsilon: "",
  straightphi: "",
  strns: "",
  sub: "",
  subE: "",
  subdot: "",
  sube: "",
  subedot: "",
  submult: "",
  subnE: "",
  subne: "",
  subplus: "",
  subrarr: "",
  subset: "",
  subseteq: "",
  subseteqq: "",
  subsetneq: "",
  subsetneqq: "",
  subsim: "",
  subsub: "",
  subsup: "",
  succ: "",
  succapprox: "",
  succcurlyeq: "",
  succeq: "",
  succnapprox: "",
  succneqq: "",
  succnsim: "",
  succsim: "",
  sum: "",
  sung: "",
  sup1: "",
  sup2: "",
  sup3: "",
  sup: "",
  supE: "",
  supdot: "",
  supdsub: "",
  supe: "",
  supedot: "",
  suphsol: "",
  suphsub: "",
  suplarr: "",
  supmult: "",
  supnE: "",
  supne: "",
  supplus: "",
  supset: "",
  supseteq: "",
  supseteqq: "",
  supsetneq: "",
  supsetneqq: "",
  supsim: "",
  supsub: "",
  supsup: "",
  swArr: "",
  swarhk: "",
  swarr: "",
  swarrow: "",
  swnwar: "",
  szlig: "",
  target: "",
  tau: "",
  tbrk: "",
  tcaron: "",
  tcedil: "",
  tcy: "",
  tdot: "",
  telrec: "",
  tfr: "\uD835\uDD31",
  there4: "",
  therefore: "",
  theta: "",
  thetasym: "",
  thetav: "",
  thickapprox: "",
  thicksim: "",
  thinsp: "",
  thkap: "",
  thksim: "",
  thorn: "",
  tilde: "",
  times: "",
  timesb: "",
  timesbar: "",
  timesd: "",
  tint: "",
  toea: "",
  top: "",
  topbot: "",
  topcir: "",
  topf: "\uD835\uDD65",
  topfork: "",
  tosa: "",
  tprime: "",
  trade: "",
  triangle: "",
  triangledown: "",
  triangleleft: "",
  trianglelefteq: "",
  triangleq: "",
  triangleright: "",
  trianglerighteq: "",
  tridot: "",
  trie: "",
  triminus: "",
  triplus: "",
  trisb: "",
  tritime: "",
  trpezium: "",
  tscr: "\uD835\uDCC9",
  tscy: "",
  tshcy: "",
  tstrok: "",
  twixt: "",
  twoheadleftarrow: "",
  twoheadrightarrow: "",
  uArr: "",
  uHar: "",
  uacute: "",
  uarr: "",
  ubrcy: "",
  ubreve: "",
  ucirc: "",
  ucy: "",
  udarr: "",
  udblac: "",
  udhar: "",
  ufisht: "",
  ufr: "\uD835\uDD32",
  ugrave: "",
  uharl: "",
  uharr: "",
  uhblk: "",
  ulcorn: "",
  ulcorner: "",
  ulcrop: "",
  ultri: "",
  umacr: "",
  uml: "",
  uogon: "",
  uopf: "\uD835\uDD66",
  uparrow: "",
  updownarrow: "",
  upharpoonleft: "",
  upharpoonright: "",
  uplus: "",
  upsi: "",
  upsih: "",
  upsilon: "",
  upuparrows: "",
  urcorn: "",
  urcorner: "",
  urcrop: "",
  uring: "",
  urtri: "",
  uscr: "\uD835\uDCCA",
  utdot: "",
  utilde: "",
  utri: "",
  utrif: "",
  uuarr: "",
  uuml: "",
  uwangle: "",
  vArr: "",
  vBar: "",
  vBarv: "",
  vDash: "",
  vangrt: "",
  varepsilon: "",
  varkappa: "",
  varnothing: "",
  varphi: "",
  varpi: "",
  varpropto: "",
  varr: "",
  varrho: "",
  varsigma: "",
  varsubsetneq: "",
  varsubsetneqq: "",
  varsupsetneq: "",
  varsupsetneqq: "",
  vartheta: "",
  vartriangleleft: "",
  vartriangleright: "",
  vcy: "",
  vdash: "",
  vee: "",
  veebar: "",
  veeeq: "",
  vellip: "",
  verbar: "|",
  vert: "|",
  vfr: "\uD835\uDD33",
  vltri: "",
  vnsub: "",
  vnsup: "",
  vopf: "\uD835\uDD67",
  vprop: "",
  vrtri: "",
  vscr: "\uD835\uDCCB",
  vsubnE: "",
  vsubne: "",
  vsupnE: "",
  vsupne: "",
  vzigzag: "",
  wcirc: "",
  wedbar: "",
  wedge: "",
  wedgeq: "",
  weierp: "",
  wfr: "\uD835\uDD34",
  wopf: "\uD835\uDD68",
  wp: "",
  wr: "",
  wreath: "",
  wscr: "\uD835\uDCCC",
  xcap: "",
  xcirc: "",
  xcup: "",
  xdtri: "",
  xfr: "\uD835\uDD35",
  xhArr: "",
  xharr: "",
  xi: "",
  xlArr: "",
  xlarr: "",
  xmap: "",
  xnis: "",
  xodot: "",
  xopf: "\uD835\uDD69",
  xoplus: "",
  xotime: "",
  xrArr: "",
  xrarr: "",
  xscr: "\uD835\uDCCD",
  xsqcup: "",
  xuplus: "",
  xutri: "",
  xvee: "",
  xwedge: "",
  yacute: "",
  yacy: "",
  ycirc: "",
  ycy: "",
  yen: "",
  yfr: "\uD835\uDD36",
  yicy: "",
  yopf: "\uD835\uDD6A",
  yscr: "\uD835\uDCCE",
  yucy: "",
  yuml: "",
  zacute: "",
  zcaron: "",
  zcy: "",
  zdot: "",
  zeetrf: "",
  zeta: "",
  zfr: "\uD835\uDD37",
  zhcy: "",
  zigrarr: "",
  zopf: "\uD835\uDD6B",
  zscr: "\uD835\uDCCF",
  zwj: "",
  zwnj: ""
};

// node_modules/decode-named-character-reference/index.js
var own2 = {}.hasOwnProperty;
function decodeNamedCharacterReference(value) {
  return own2.call(characterEntities, value) ? characterEntities[value] : false;
}

// node_modules/micromark-util-symbol/lib/codes.js
var codes = {
  carriageReturn: -5,
  lineFeed: -4,
  carriageReturnLineFeed: -3,
  horizontalTab: -2,
  virtualSpace: -1,
  eof: null,
  nul: 0,
  soh: 1,
  stx: 2,
  etx: 3,
  eot: 4,
  enq: 5,
  ack: 6,
  bel: 7,
  bs: 8,
  ht: 9,
  lf: 10,
  vt: 11,
  ff: 12,
  cr: 13,
  so: 14,
  si: 15,
  dle: 16,
  dc1: 17,
  dc2: 18,
  dc3: 19,
  dc4: 20,
  nak: 21,
  syn: 22,
  etb: 23,
  can: 24,
  em: 25,
  sub: 26,
  esc: 27,
  fs: 28,
  gs: 29,
  rs: 30,
  us: 31,
  space: 32,
  exclamationMark: 33,
  quotationMark: 34,
  numberSign: 35,
  dollarSign: 36,
  percentSign: 37,
  ampersand: 38,
  apostrophe: 39,
  leftParenthesis: 40,
  rightParenthesis: 41,
  asterisk: 42,
  plusSign: 43,
  comma: 44,
  dash: 45,
  dot: 46,
  slash: 47,
  digit0: 48,
  digit1: 49,
  digit2: 50,
  digit3: 51,
  digit4: 52,
  digit5: 53,
  digit6: 54,
  digit7: 55,
  digit8: 56,
  digit9: 57,
  colon: 58,
  semicolon: 59,
  lessThan: 60,
  equalsTo: 61,
  greaterThan: 62,
  questionMark: 63,
  atSign: 64,
  uppercaseA: 65,
  uppercaseB: 66,
  uppercaseC: 67,
  uppercaseD: 68,
  uppercaseE: 69,
  uppercaseF: 70,
  uppercaseG: 71,
  uppercaseH: 72,
  uppercaseI: 73,
  uppercaseJ: 74,
  uppercaseK: 75,
  uppercaseL: 76,
  uppercaseM: 77,
  uppercaseN: 78,
  uppercaseO: 79,
  uppercaseP: 80,
  uppercaseQ: 81,
  uppercaseR: 82,
  uppercaseS: 83,
  uppercaseT: 84,
  uppercaseU: 85,
  uppercaseV: 86,
  uppercaseW: 87,
  uppercaseX: 88,
  uppercaseY: 89,
  uppercaseZ: 90,
  leftSquareBracket: 91,
  backslash: 92,
  rightSquareBracket: 93,
  caret: 94,
  underscore: 95,
  graveAccent: 96,
  lowercaseA: 97,
  lowercaseB: 98,
  lowercaseC: 99,
  lowercaseD: 100,
  lowercaseE: 101,
  lowercaseF: 102,
  lowercaseG: 103,
  lowercaseH: 104,
  lowercaseI: 105,
  lowercaseJ: 106,
  lowercaseK: 107,
  lowercaseL: 108,
  lowercaseM: 109,
  lowercaseN: 110,
  lowercaseO: 111,
  lowercaseP: 112,
  lowercaseQ: 113,
  lowercaseR: 114,
  lowercaseS: 115,
  lowercaseT: 116,
  lowercaseU: 117,
  lowercaseV: 118,
  lowercaseW: 119,
  lowercaseX: 120,
  lowercaseY: 121,
  lowercaseZ: 122,
  leftCurlyBrace: 123,
  verticalBar: 124,
  rightCurlyBrace: 125,
  tilde: 126,
  del: 127,
  byteOrderMarker: 65279,
  replacementCharacter: 65533
};
// node_modules/micromark-util-symbol/lib/constants.js
var constants = {
  attentionSideAfter: 2,
  attentionSideBefore: 1,
  atxHeadingOpeningFenceSizeMax: 6,
  autolinkDomainSizeMax: 63,
  autolinkSchemeSizeMax: 32,
  cdataOpeningString: "CDATA[",
  characterGroupPunctuation: 2,
  characterGroupWhitespace: 1,
  characterReferenceDecimalSizeMax: 7,
  characterReferenceHexadecimalSizeMax: 6,
  characterReferenceNamedSizeMax: 31,
  codeFencedSequenceSizeMin: 3,
  contentTypeContent: "content",
  contentTypeDocument: "document",
  contentTypeFlow: "flow",
  contentTypeString: "string",
  contentTypeText: "text",
  hardBreakPrefixSizeMin: 2,
  htmlBasic: 6,
  htmlCdata: 5,
  htmlComment: 2,
  htmlComplete: 7,
  htmlDeclaration: 4,
  htmlInstruction: 3,
  htmlRawSizeMax: 8,
  htmlRaw: 1,
  linkResourceDestinationBalanceMax: 32,
  linkReferenceSizeMax: 999,
  listItemValueSizeMax: 10,
  numericBaseDecimal: 10,
  numericBaseHexadecimal: 16,
  tabSize: 4,
  thematicBreakMarkerCountMin: 3,
  v8MaxSafeChunkSize: 1e4
};
// node_modules/micromark-util-symbol/lib/types.js
var types = {
  data: "data",
  whitespace: "whitespace",
  lineEnding: "lineEnding",
  lineEndingBlank: "lineEndingBlank",
  linePrefix: "linePrefix",
  lineSuffix: "lineSuffix",
  atxHeading: "atxHeading",
  atxHeadingSequence: "atxHeadingSequence",
  atxHeadingText: "atxHeadingText",
  autolink: "autolink",
  autolinkEmail: "autolinkEmail",
  autolinkMarker: "autolinkMarker",
  autolinkProtocol: "autolinkProtocol",
  characterEscape: "characterEscape",
  characterEscapeValue: "characterEscapeValue",
  characterReference: "characterReference",
  characterReferenceMarker: "characterReferenceMarker",
  characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
  characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
  characterReferenceValue: "characterReferenceValue",
  codeFenced: "codeFenced",
  codeFencedFence: "codeFencedFence",
  codeFencedFenceSequence: "codeFencedFenceSequence",
  codeFencedFenceInfo: "codeFencedFenceInfo",
  codeFencedFenceMeta: "codeFencedFenceMeta",
  codeFlowValue: "codeFlowValue",
  codeIndented: "codeIndented",
  codeText: "codeText",
  codeTextData: "codeTextData",
  codeTextPadding: "codeTextPadding",
  codeTextSequence: "codeTextSequence",
  content: "content",
  definition: "definition",
  definitionDestination: "definitionDestination",
  definitionDestinationLiteral: "definitionDestinationLiteral",
  definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
  definitionDestinationRaw: "definitionDestinationRaw",
  definitionDestinationString: "definitionDestinationString",
  definitionLabel: "definitionLabel",
  definitionLabelMarker: "definitionLabelMarker",
  definitionLabelString: "definitionLabelString",
  definitionMarker: "definitionMarker",
  definitionTitle: "definitionTitle",
  definitionTitleMarker: "definitionTitleMarker",
  definitionTitleString: "definitionTitleString",
  emphasis: "emphasis",
  emphasisSequence: "emphasisSequence",
  emphasisText: "emphasisText",
  escapeMarker: "escapeMarker",
  hardBreakEscape: "hardBreakEscape",
  hardBreakTrailing: "hardBreakTrailing",
  htmlFlow: "htmlFlow",
  htmlFlowData: "htmlFlowData",
  htmlText: "htmlText",
  htmlTextData: "htmlTextData",
  image: "image",
  label: "label",
  labelText: "labelText",
  labelLink: "labelLink",
  labelImage: "labelImage",
  labelMarker: "labelMarker",
  labelImageMarker: "labelImageMarker",
  labelEnd: "labelEnd",
  link: "link",
  paragraph: "paragraph",
  reference: "reference",
  referenceMarker: "referenceMarker",
  referenceString: "referenceString",
  resource: "resource",
  resourceDestination: "resourceDestination",
  resourceDestinationLiteral: "resourceDestinationLiteral",
  resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
  resourceDestinationRaw: "resourceDestinationRaw",
  resourceDestinationString: "resourceDestinationString",
  resourceMarker: "resourceMarker",
  resourceTitle: "resourceTitle",
  resourceTitleMarker: "resourceTitleMarker",
  resourceTitleString: "resourceTitleString",
  setextHeading: "setextHeading",
  setextHeadingText: "setextHeadingText",
  setextHeadingLine: "setextHeadingLine",
  setextHeadingLineSequence: "setextHeadingLineSequence",
  strong: "strong",
  strongSequence: "strongSequence",
  strongText: "strongText",
  thematicBreak: "thematicBreak",
  thematicBreakSequence: "thematicBreakSequence",
  blockQuote: "blockQuote",
  blockQuotePrefix: "blockQuotePrefix",
  blockQuoteMarker: "blockQuoteMarker",
  blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
  listOrdered: "listOrdered",
  listUnordered: "listUnordered",
  listItemIndent: "listItemIndent",
  listItemMarker: "listItemMarker",
  listItemPrefix: "listItemPrefix",
  listItemPrefixWhitespace: "listItemPrefixWhitespace",
  listItemValue: "listItemValue",
  chunkDocument: "chunkDocument",
  chunkContent: "chunkContent",
  chunkFlow: "chunkFlow",
  chunkText: "chunkText",
  chunkString: "chunkString"
};
// node_modules/micromark-util-symbol/lib/values.js
var values = {
  ht: "\t",
  lf: `
`,
  cr: "\r",
  space: " ",
  exclamationMark: "!",
  quotationMark: '"',
  numberSign: "#",
  dollarSign: "$",
  percentSign: "%",
  ampersand: "&",
  apostrophe: "'",
  leftParenthesis: "(",
  rightParenthesis: ")",
  asterisk: "*",
  plusSign: "+",
  comma: ",",
  dash: "-",
  dot: ".",
  slash: "/",
  digit0: "0",
  digit1: "1",
  digit2: "2",
  digit3: "3",
  digit4: "4",
  digit5: "5",
  digit6: "6",
  digit7: "7",
  digit8: "8",
  digit9: "9",
  colon: ":",
  semicolon: ";",
  lessThan: "<",
  equalsTo: "=",
  greaterThan: ">",
  questionMark: "?",
  atSign: "@",
  uppercaseA: "A",
  uppercaseB: "B",
  uppercaseC: "C",
  uppercaseD: "D",
  uppercaseE: "E",
  uppercaseF: "F",
  uppercaseG: "G",
  uppercaseH: "H",
  uppercaseI: "I",
  uppercaseJ: "J",
  uppercaseK: "K",
  uppercaseL: "L",
  uppercaseM: "M",
  uppercaseN: "N",
  uppercaseO: "O",
  uppercaseP: "P",
  uppercaseQ: "Q",
  uppercaseR: "R",
  uppercaseS: "S",
  uppercaseT: "T",
  uppercaseU: "U",
  uppercaseV: "V",
  uppercaseW: "W",
  uppercaseX: "X",
  uppercaseY: "Y",
  uppercaseZ: "Z",
  leftSquareBracket: "[",
  backslash: "\\",
  rightSquareBracket: "]",
  caret: "^",
  underscore: "_",
  graveAccent: "`",
  lowercaseA: "a",
  lowercaseB: "b",
  lowercaseC: "c",
  lowercaseD: "d",
  lowercaseE: "e",
  lowercaseF: "f",
  lowercaseG: "g",
  lowercaseH: "h",
  lowercaseI: "i",
  lowercaseJ: "j",
  lowercaseK: "k",
  lowercaseL: "l",
  lowercaseM: "m",
  lowercaseN: "n",
  lowercaseO: "o",
  lowercaseP: "p",
  lowercaseQ: "q",
  lowercaseR: "r",
  lowercaseS: "s",
  lowercaseT: "t",
  lowercaseU: "u",
  lowercaseV: "v",
  lowercaseW: "w",
  lowercaseX: "x",
  lowercaseY: "y",
  lowercaseZ: "z",
  leftCurlyBrace: "{",
  verticalBar: "|",
  rightCurlyBrace: "}",
  tilde: "~",
  replacementCharacter: ""
};
// node_modules/micromark-util-chunked/dev/index.js
function splice(list, start, remove, items) {
  const end = list.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list.splice(...parameters);
  } else {
    if (remove)
      list.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize);
      parameters.unshift(start, 0);
      list.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list, items) {
  if (list.length > 0) {
    splice(list, list.length, 0, items);
    return list;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension) {
  let hook;
  for (hook in extension) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : undefined;
    const left = maybe || (all2[hook] = {});
    const right = extension[hook];
    let code;
    if (right) {
      for (code in right) {
        if (!hasOwnProperty.call(left, code))
          left[code] = [];
        const value = right[code];
        constructs(left[code], Array.isArray(value) ? value : value ? [value] : []);
      }
    }
  }
}
function constructs(existing, list) {
  let index2 = -1;
  const before = [];
  while (++index2 < list.length) {
    (list[index2].add === "after" ? existing : before).push(list[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value, base) {
  const code = Number.parseInt(value, base);
  if (code < codes.ht || code === codes.vt || code > codes.cr && code < codes.space || code > codes.tilde && code < 160 || code > 55295 && code < 57344 || code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || code > 1114111) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code);
}

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-util-character/dev/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code) {
  return code !== null && (code < codes.space || code === codes.del);
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code) {
  return code !== null && code < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code) {
  return code !== null && (code < codes.nul || code === codes.space);
}
function markdownSpace(code) {
  return code === codes.horizontalTab || code === codes.virtualSpace || code === codes.space;
}
var unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code) {
    return code !== null && code > -1 && regex.test(String.fromCharCode(code));
  }
}

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code) {
    if (markdownSpace(code)) {
      effects.enter(type);
      return prefix(code);
    }
    return ok2(code);
  }
  function prefix(code) {
    if (markdownSpace(code) && size++ < limit) {
      effects.consume(code);
      return prefix;
    }
    effects.exit(type);
    return ok2(code);
  }
}

// node_modules/micromark/dev/lib/initialize/content.js
var content = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous;
  return contentStart;
  function afterContentStartConstruct(code) {
    ok(code === codes.eof || markdownLineEnding(code), "expected eol or eof");
    if (code === codes.eof) {
      effects.consume(code);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    return factorySpace(effects, contentStart, types.linePrefix);
  }
  function paragraphInitial(code) {
    ok(code !== codes.eof && !markdownLineEnding(code), "expected anything other than a line ending or EOF");
    effects.enter(types.paragraph);
    return lineStart(code);
  }
  function lineStart(code) {
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous
    });
    if (previous) {
      previous.next = token;
    }
    previous = token;
    return data(code);
  }
  function data(code) {
    if (code === codes.eof) {
      effects.exit(types.chunkText);
      effects.exit(types.paragraph);
      effects.consume(code);
      return;
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code);
    return data;
  }
}

// node_modules/micromark/dev/lib/initialize/document.js
var document2 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      ok(item[0].continuation, "expected `continuation` to be defined on container construct");
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code);
    }
    return checkNewContainers(code);
  }
  function documentContinue(code) {
    ok(self2.containerState, "expected `containerState` to be defined after continuation");
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = undefined;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point2, "could not find previous flow chunk");
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point2 };
        index2++;
      }
      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
      self2.events.length = index2;
      return checkNewContainers(code);
    }
    return start(code);
  }
  function checkNewContainers(code) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code);
      }
      self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    self2.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code);
  }
  function thereIsANewContainer(code) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code);
  }
  function thereIsNoNewContainer(code) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code);
  }
  function documentContinued(code) {
    self2.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code);
  }
  function containerContinue(code) {
    ok(self2.currentConstruct, "expected `currentConstruct` to be defined on tokenizer");
    ok(self2.containerState, "expected `containerState` to be defined on tokenizer");
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code);
  }
  function flowStart(code) {
    if (code === codes.eof) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types.chunkFlow, {
      _tokenizer: childFlow,
      contentType: constants.contentTypeFlow,
      previous: childToken
    });
    return flowContinue(code);
  }
  function flowContinue(code) {
    if (code === codes.eof) {
      writeToChild(effects.exit(types.chunkFlow), true);
      exitContainers(0);
      effects.consume(code);
      return;
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      writeToChild(effects.exit(types.chunkFlow));
      continued = 0;
      self2.interrupt = undefined;
      return start;
    }
    effects.consume(code);
    return flowContinue;
  }
  function writeToChild(token, endOfFile) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (endOfFile)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          if (seen) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point2, "could not find previous flow chunk");
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = { ...point2 };
        index2++;
      }
      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      ok(entry[0].exit, "expected `exit` to be defined on container construct");
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    ok(self2.containerState, "expected `containerState` to be defined when closing flow");
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = undefined;
    childFlow = undefined;
    self2.containerState._closeFlow = undefined;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  ok(this.parser.constructs.disable.null, "expected `disable.null` to be populated");
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), types.linePrefix, this.parser.constructs.disable.null.includes("codeIndented") ? undefined : constants.tabSize);
}

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code) {
  if (code === codes.eof || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code)) {
    return constants.characterGroupPunctuation;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = { ...events[open][1].end };
          const end = { ...events[index2][1].start };
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start,
            end: { ...events[open][1].end }
          };
          closingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: { ...events[index2][1].start },
            end
          };
          text = {
            type: use > 1 ? types.strongText : types.emphasisText,
            start: { ...events[open][1].end },
            end: { ...events[index2][1].start }
          };
          group = {
            type: use > 1 ? types.strong : types.emphasis,
            start: { ...openingSequence.start },
            end: { ...closingSequence.end }
          };
          events[open][1].end = { ...openingSequence.start };
          events[index2][1].start = { ...closingSequence.end };
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text, context]
          ]);
          ok(context.parser.constructs.insideSpan.null, "expected `insideSpan` to be populated");
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [
            ["exit", text, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers = this.parser.constructs.attentionMarkers.null;
  const previous = this.previous;
  const before = classifyCharacter(previous);
  let marker;
  return start;
  function start(code) {
    ok(code === codes.asterisk || code === codes.underscore, "expected asterisk or underscore");
    marker = code;
    effects.enter("attentionSequence");
    return inside(code);
  }
  function inside(code) {
    if (code === marker) {
      effects.consume(code);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code);
    ok(attentionMarkers, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers.includes(code);
    const close = !before || before === constants.characterGroupPunctuation && after || attentionMarkers.includes(previous);
    token._open = Boolean(marker === codes.asterisk ? open : open && (before || !close));
    token._close = Boolean(marker === codes.asterisk ? close : close && (after || !open));
    return ok2(code);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}
// node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code) {
    ok(code === codes.lessThan, "expected `<`");
    effects.enter(types.autolink);
    effects.enter(types.autolinkMarker);
    effects.consume(code);
    effects.exit(types.autolinkMarker);
    effects.enter(types.autolinkProtocol);
    return open;
  }
  function open(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return schemeOrEmailAtext;
    }
    if (code === codes.atSign) {
      return nok(code);
    }
    return emailAtext(code);
  }
  function schemeOrEmailAtext(code) {
    if (code === codes.plusSign || code === codes.dash || code === codes.dot || asciiAlphanumeric(code)) {
      size = 1;
      return schemeInsideOrEmailAtext(code);
    }
    return emailAtext(code);
  }
  function schemeInsideOrEmailAtext(code) {
    if (code === codes.colon) {
      effects.consume(code);
      size = 0;
      return urlInside;
    }
    if ((code === codes.plusSign || code === codes.dash || code === codes.dot || asciiAlphanumeric(code)) && size++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code);
  }
  function urlInside(code) {
    if (code === codes.greaterThan) {
      effects.exit(types.autolinkProtocol);
      effects.enter(types.autolinkMarker);
      effects.consume(code);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok2;
    }
    if (code === codes.eof || code === codes.space || code === codes.lessThan || asciiControl(code)) {
      return nok(code);
    }
    effects.consume(code);
    return urlInside;
  }
  function emailAtext(code) {
    if (code === codes.atSign) {
      effects.consume(code);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code)) {
      effects.consume(code);
      return emailAtext;
    }
    return nok(code);
  }
  function emailAtSignOrDot(code) {
    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code);
  }
  function emailLabel(code) {
    if (code === codes.dot) {
      effects.consume(code);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code === codes.greaterThan) {
      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;
      effects.enter(types.autolinkMarker);
      effects.consume(code);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok2;
    }
    return emailValue(code);
  }
  function emailValue(code) {
    if ((code === codes.dash || asciiAlphanumeric(code)) && size++ < constants.autolinkDomainSizeMax) {
      const next = code === codes.dash ? emailValue : emailLabel;
      effects.consume(code);
      return next;
    }
    return nok(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { partial: true, tokenize: tokenizeBlankLine };
function tokenizeBlankLine(effects, ok2, nok) {
  return start;
  function start(code) {
    return markdownSpace(code) ? factorySpace(effects, after, types.linePrefix)(code) : after(code);
  }
  function after(code) {
    return code === codes.eof || markdownLineEnding(code) ? ok2(code) : nok(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    if (code === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types.blockQuotePrefix);
      effects.enter(types.blockQuoteMarker);
      effects.consume(code);
      effects.exit(types.blockQuoteMarker);
      return after;
    }
    return nok(code);
  }
  function after(code) {
    if (markdownSpace(code)) {
      effects.enter(types.blockQuotePrefixWhitespace);
      effects.consume(code);
      effects.exit(types.blockQuotePrefixWhitespace);
      effects.exit(types.blockQuotePrefix);
      return ok2;
    }
    effects.exit(types.blockQuotePrefix);
    return ok2(code);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code) {
    if (markdownSpace(code)) {
      ok(self2.parser.constructs.disable.null, "expected `disable.null` to be populated");
      return factorySpace(effects, contBefore, types.linePrefix, self2.parser.constructs.disable.null.includes("codeIndented") ? undefined : constants.tabSize)(code);
    }
    return contBefore(code);
  }
  function contBefore(code) {
    return effects.attempt(blockQuote, ok2, nok)(code);
  }
}
function exit(effects) {
  effects.exit(types.blockQuote);
}
// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code) {
    ok(code === codes.backslash, "expected `\\`");
    effects.enter(types.characterEscape);
    effects.enter(types.escapeMarker);
    effects.consume(code);
    effects.exit(types.escapeMarker);
    return inside;
  }
  function inside(code) {
    if (asciiPunctuation(code)) {
      effects.enter(types.characterEscapeValue);
      effects.consume(code);
      effects.exit(types.characterEscapeValue);
      effects.exit(types.characterEscape);
      return ok2;
    }
    return nok(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code) {
    ok(code === codes.ampersand, "expected `&`");
    effects.enter(types.characterReference);
    effects.enter(types.characterReferenceMarker);
    effects.consume(code);
    effects.exit(types.characterReferenceMarker);
    return open;
  }
  function open(code) {
    if (code === codes.numberSign) {
      effects.enter(types.characterReferenceMarkerNumeric);
      effects.consume(code);
      effects.exit(types.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types.characterReferenceValue);
    max = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value(code);
  }
  function numeric(code) {
    if (code === codes.uppercaseX || code === codes.lowercaseX) {
      effects.enter(types.characterReferenceMarkerHexadecimal);
      effects.consume(code);
      effects.exit(types.characterReferenceMarkerHexadecimal);
      effects.enter(types.characterReferenceValue);
      max = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value;
    }
    effects.enter(types.characterReferenceValue);
    max = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value(code);
  }
  function value(code) {
    if (code === codes.semicolon && size) {
      const token = effects.exit(types.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code);
      }
      effects.enter(types.characterReferenceMarker);
      effects.consume(code);
      effects.exit(types.characterReferenceMarker);
      effects.exit(types.characterReference);
      return ok2;
    }
    if (test(code) && size++ < max) {
      effects.consume(code);
      return value;
    }
    return nok(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
var codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closeStart = { partial: true, tokenize: tokenizeCloseStart };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code) {
    return beforeSequenceOpen(code);
  }
  function beforeSequenceOpen(code) {
    ok(code === codes.graveAccent || code === codes.tilde, "expected `` ` `` or `~`");
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code;
    effects.enter(types.codeFenced);
    effects.enter(types.codeFencedFence);
    effects.enter(types.codeFencedFenceSequence);
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === marker) {
      sizeOpen++;
      effects.consume(code);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code);
    }
    effects.exit(types.codeFencedFenceSequence);
    return markdownSpace(code) ? factorySpace(effects, infoBefore, types.whitespace)(code) : infoBefore(code);
  }
  function infoBefore(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.codeFencedFence);
      return self2.interrupt ? ok2(code) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);
    }
    effects.enter(types.codeFencedFenceInfo);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return info(code);
  }
  function info(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return infoBefore(code);
    }
    if (markdownSpace(code)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types.whitespace)(code);
    }
    if (code === codes.graveAccent && code === marker) {
      return nok(code);
    }
    effects.consume(code);
    return info;
  }
  function metaBefore(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      return infoBefore(code);
    }
    effects.enter(types.codeFencedFenceMeta);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return meta(code);
  }
  function meta(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceMeta);
      return infoBefore(code);
    }
    if (code === codes.graveAccent && code === marker) {
      return nok(code);
    }
    effects.consume(code);
    return meta;
  }
  function atNonLazyBreak(code) {
    ok(markdownLineEnding(code), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code);
  }
  function contentBefore(code) {
    ok(markdownLineEnding(code), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    return contentStart;
  }
  function contentStart(code) {
    return initialPrefix > 0 && markdownSpace(code) ? factorySpace(effects, beforeContentChunk, types.linePrefix, initialPrefix + 1)(code) : beforeContentChunk(code);
  }
  function beforeContentChunk(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);
    }
    effects.enter(types.codeFlowValue);
    return contentChunk(code);
  }
  function contentChunk(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.codeFlowValue);
      return beforeContentChunk(code);
    }
    effects.consume(code);
    return contentChunk;
  }
  function after(code) {
    effects.exit(types.codeFenced);
    return ok2(code);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code) {
      ok(markdownLineEnding(code), "expected eol");
      effects2.enter(types.lineEnding);
      effects2.consume(code);
      effects2.exit(types.lineEnding);
      return start2;
    }
    function start2(code) {
      ok(self2.parser.constructs.disable.null, "expected `disable.null` to be populated");
      effects2.enter(types.codeFencedFence);
      return markdownSpace(code) ? factorySpace(effects2, beforeSequenceClose, types.linePrefix, self2.parser.constructs.disable.null.includes("codeIndented") ? undefined : constants.tabSize)(code) : beforeSequenceClose(code);
    }
    function beforeSequenceClose(code) {
      if (code === marker) {
        effects2.enter(types.codeFencedFenceSequence);
        return sequenceClose(code);
      }
      return nok2(code);
    }
    function sequenceClose(code) {
      if (code === marker) {
        size++;
        effects2.consume(code);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit(types.codeFencedFenceSequence);
        return markdownSpace(code) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code) : sequenceCloseAfter(code);
      }
      return nok2(code);
    }
    function sequenceCloseAfter(code) {
      if (code === codes.eof || markdownLineEnding(code)) {
        effects2.exit(types.codeFencedFence);
        return ok3(code);
      }
      return nok2(code);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    if (code === codes.eof) {
      return nok(code);
    }
    ok(markdownLineEnding(code), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code) {
    return self2.parser.lazy[self2.now().line] ? nok(code) : ok2(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { partial: true, tokenize: tokenizeFurtherStart };
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    ok(markdownSpace(code));
    effects.enter(types.codeIndented);
    return factorySpace(effects, afterPrefix, types.linePrefix, constants.tabSize + 1)(code);
  }
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code) : nok(code);
  }
  function atBreak(code) {
    if (code === codes.eof) {
      return after(code);
    }
    if (markdownLineEnding(code)) {
      return effects.attempt(furtherStart, atBreak, after)(code);
    }
    effects.enter(types.codeFlowValue);
    return inside(code);
  }
  function inside(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.codeFlowValue);
      return atBreak(code);
    }
    effects.consume(code);
    return inside;
  }
  function after(code) {
    effects.exit(types.codeIndented);
    return ok2(code);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      effects.enter(types.lineEnding);
      effects.consume(code);
      effects.exit(types.lineEnding);
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, types.linePrefix, constants.tabSize + 1)(code);
  }
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok2(code) : markdownLineEnding(code) ? furtherStart2(code) : nok(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  previous,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === types.codeTextData) {
        events[headEnterIndex][1].type = types.codeTextPadding;
        events[tailExitIndex][1].type = types.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === undefined) {
      if (index2 !== tailExitIndex && events[index2][1].type !== types.lineEnding) {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === types.lineEnding) {
      events[enter][1].type = types.codeTextData;
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = undefined;
    }
  }
  return events;
}
function previous(code) {
  return code !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeCodeText(effects, ok2, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code) {
    ok(code === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self2, self2.previous), "expected correct previous");
    effects.enter(types.codeText);
    effects.enter(types.codeTextSequence);
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === codes.graveAccent) {
      effects.consume(code);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types.codeTextSequence);
    return between(code);
  }
  function between(code) {
    if (code === codes.eof) {
      return nok(code);
    }
    if (code === codes.space) {
      effects.enter("space");
      effects.consume(code);
      effects.exit("space");
      return between;
    }
    if (code === codes.graveAccent) {
      token = effects.enter(types.codeTextSequence);
      size = 0;
      return sequenceClose(code);
    }
    if (markdownLineEnding(code)) {
      effects.enter(types.lineEnding);
      effects.consume(code);
      effects.exit(types.lineEnding);
      return between;
    }
    effects.enter(types.codeTextData);
    return data(code);
  }
  function data(code) {
    if (code === codes.eof || code === codes.space || code === codes.graveAccent || markdownLineEnding(code)) {
      effects.exit(types.codeTextData);
      return between(code);
    }
    effects.consume(code);
    return data;
  }
  function sequenceClose(code) {
    if (code === codes.graveAccent) {
      effects.consume(code);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit(types.codeTextSequence);
      effects.exit(types.codeText);
      return ok2(code);
    }
    token.type = types.codeTextData;
    return data(code);
  }
}
// node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js
class SpliceBuffer {
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  get(index2) {
    if (index2 < 0 || index2 >= this.left.length + this.right.length) {
      throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    }
    if (index2 < this.left.length)
      return this.left[index2];
    return this.right[this.right.length - index2 + this.left.length - 1];
  }
  get length() {
    return this.left.length + this.right.length;
  }
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  slice(start, end) {
    const stop = end === null || end === undefined ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start, stop);
    }
    if (start > this.left.length) {
      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();
    }
    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
  }
  splice(start, deleteCount, items) {
    const count = deleteCount || 0;
    this.setCursor(Math.trunc(start));
    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);
    if (items)
      chunkedPush(this.left, items);
    return removed.reverse();
  }
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  setCursor(n) {
    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)
      return;
    if (n < this.left.length) {
      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
      chunkedPush(this.left, removed.reverse());
    }
  }
}
function chunkedPush(list, right) {
  let chunkStart = 0;
  if (right.length < constants.v8MaxSafeChunkSize) {
    list.push(...right);
  } else {
    while (chunkStart < right.length) {
      list.push(...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize));
      chunkStart += constants.v8MaxSafeChunkSize;
    }
  }
}

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(eventsArray) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events.get(index2);
    if (index2 && event[1].type === types.chunkFlow && events.get(index2 - 1)[1].type === types.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = undefined;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = types.lineEndingBlank;
            }
            otherEvent[1].type = types.lineEnding;
            lineIndex = otherIndex;
          }
        } else if (otherEvent[1].type === types.linePrefix || otherEvent[1].type === types.listItemIndent) {} else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = { ...events.get(lineIndex)[1].start };
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        events.splice(lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  let tokenizer = token._tokenizer;
  if (!tokenizer) {
    tokenizer = context.parser[token.contentType](token.start);
    if (token._contentTypeTextTrailing) {
      tokenizer._contentTypeTextTrailing = true;
    }
  }
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {}
    ok(!previous2 || current.previous === previous2, "expected previous to match");
    ok(!previous2 || previous2.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = undefined;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      ok(current, "expected a current token");
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = undefined;
      current.previous = undefined;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = undefined;
    current.previous = undefined;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    ok(start2 !== undefined, "expected a start position when splicing");
    jumps.push([start2, start2 + slice.length - 1]);
    events.splice(start2, 2, slice);
  }
  jumps.reverse();
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/dev/lib/content.js
var content2 = { resolve: resolveContent, tokenize: tokenizeContent };
var continuationConstruct = { partial: true, tokenize: tokenizeContinuation };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code) {
    ok(code !== codes.eof && !markdownLineEnding(code), "expected no eof or eol");
    effects.enter(types.content);
    previous2 = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code);
  }
  function chunkInside(code) {
    if (code === codes.eof) {
      return contentEnd(code);
    }
    if (markdownLineEnding(code)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code);
    }
    effects.consume(code);
    return chunkInside;
  }
  function contentEnd(code) {
    effects.exit(types.chunkContent);
    effects.exit(types.content);
    return ok2(code);
  }
  function contentContinue(code) {
    ok(markdownLineEnding(code), "expected eol");
    effects.consume(code);
    effects.exit(types.chunkContent);
    ok(previous2, "expected previous token");
    previous2.next = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code) {
    ok(markdownLineEnding(code), "expected a line ending");
    effects.exit(types.chunkContent);
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    return factorySpace(effects, prefixed, types.linePrefix);
  }
  function prefixed(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      return nok(code);
    }
    ok(self2.parser.constructs.disable.null, "expected `disable.null` to be populated");
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok2(code);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code);
  }
}
// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code) {
    if (code === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code === codes.eof || code === codes.space || code === codes.rightParenthesis || asciiControl(code)) {
      return nok(code);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return raw(code);
  }
  function enclosedBefore(code) {
    if (code === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code);
  }
  function enclosed(code) {
    if (code === codes.greaterThan) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code);
    }
    if (code === codes.eof || code === codes.lessThan || markdownLineEnding(code)) {
      return nok(code);
    }
    effects.consume(code);
    return code === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code) {
    if (code === codes.lessThan || code === codes.greaterThan || code === codes.backslash) {
      effects.consume(code);
      return enclosed;
    }
    return enclosed(code);
  }
  function raw(code) {
    if (!balance && (code === codes.eof || code === codes.rightParenthesis || markdownLineEndingOrSpace(code))) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code);
    }
    if (balance < limit && code === codes.leftParenthesis) {
      effects.consume(code);
      balance++;
      return raw;
    }
    if (code === codes.rightParenthesis) {
      effects.consume(code);
      balance--;
      return raw;
    }
    if (code === codes.eof || code === codes.space || code === codes.leftParenthesis || asciiControl(code)) {
      return nok(code);
    }
    effects.consume(code);
    return code === codes.backslash ? rawEscape : raw;
  }
  function rawEscape(code) {
    if (code === codes.leftParenthesis || code === codes.rightParenthesis || code === codes.backslash) {
      effects.consume(code);
      return raw;
    }
    return raw(code);
  }
}

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start;
  function start(code) {
    ok(code === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code) {
    if (size > constants.linkReferenceSizeMax || code === codes.eof || code === codes.leftSquareBracket || code === codes.rightSquareBracket && !seen || code === codes.caret && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code);
    }
    if (code === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code)) {
      effects.enter(types.lineEnding);
      effects.consume(code);
      effects.exit(types.lineEnding);
      return atBreak;
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code);
  }
  function labelInside(code) {
    if (code === codes.eof || code === codes.leftSquareBracket || code === codes.rightSquareBracket || markdownLineEnding(code) || size++ > constants.linkReferenceSizeMax) {
      effects.exit(types.chunkString);
      return atBreak(code);
    }
    effects.consume(code);
    if (!seen)
      seen = !markdownSpace(code);
    return code === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code) {
    if (code === codes.leftSquareBracket || code === codes.backslash || code === codes.rightSquareBracket) {
      effects.consume(code);
      size++;
      return labelInside;
    }
    return labelInside(code);
  }
}

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code) {
    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      marker = code === codes.leftParenthesis ? codes.rightParenthesis : code;
      return begin;
    }
    return nok(code);
  }
  function begin(code) {
    if (code === marker) {
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atBreak(code);
  }
  function atBreak(code) {
    if (code === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code === codes.eof) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      effects.enter(types.lineEnding);
      effects.consume(code);
      effects.exit(types.lineEnding);
      return factorySpace(effects, atBreak, types.linePrefix);
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return inside(code);
  }
  function inside(code) {
    if (code === marker || code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.chunkString);
      return atBreak(code);
    }
    effects.consume(code);
    return code === codes.backslash ? escape : inside;
  }
  function escape(code) {
    if (code === marker || code === codes.backslash) {
      effects.consume(code);
      return inside;
    }
    return inside(code);
  }
}

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter(types.lineEnding);
      effects.consume(code);
      effects.exit(types.lineEnding);
      seen = true;
      return start;
    }
    if (markdownSpace(code)) {
      return factorySpace(effects, start, seen ? types.linePrefix : types.lineSuffix)(code);
    }
    return ok2(code);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { partial: true, tokenize: tokenizeTitleBefore };
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code) {
    effects.enter(types.definition);
    return before(code);
  }
  function before(code) {
    ok(code === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(self2, effects, labelAfter, nok, types.definitionLabel, types.definitionLabelMarker, types.definitionLabelString)(code);
  }
  function labelAfter(code) {
    identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
    if (code === codes.colon) {
      effects.enter(types.definitionMarker);
      effects.consume(code);
      effects.exit(types.definitionMarker);
      return markerAfter;
    }
    return nok(code);
  }
  function markerAfter(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, destinationBefore)(code) : destinationBefore(code);
  }
  function destinationBefore(code) {
    return factoryDestination(effects, destinationAfter, nok, types.definitionDestination, types.definitionDestinationLiteral, types.definitionDestinationLiteralMarker, types.definitionDestinationRaw, types.definitionDestinationString)(code);
  }
  function destinationAfter(code) {
    return effects.attempt(titleBefore, after, after)(code);
  }
  function after(code) {
    return markdownSpace(code) ? factorySpace(effects, afterWhitespace, types.whitespace)(code) : afterWhitespace(code);
  }
  function afterWhitespace(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.definition);
      self2.parser.defined.push(identifier);
      return ok2(code);
    }
    return nok(code);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, beforeMarker)(code) : nok(code);
  }
  function beforeMarker(code) {
    return factoryTitle(effects, titleAfter, nok, types.definitionTitle, types.definitionTitleMarker, types.definitionTitleString)(code);
  }
  function titleAfter(code) {
    return markdownSpace(code) ? factorySpace(effects, titleAfterOptionalWhitespace, types.whitespace)(code) : titleAfterOptionalWhitespace(code);
  }
  function titleAfterOptionalWhitespace(code) {
    return code === codes.eof || markdownLineEnding(code) ? ok2(code) : nok(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code) {
    ok(code === codes.backslash, "expected `\\`");
    effects.enter(types.hardBreakEscape);
    effects.consume(code);
    return after;
  }
  function after(code) {
    if (markdownLineEnding(code)) {
      effects.exit(types.hardBreakEscape);
      return ok2(code);
    }
    return nok(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text;
  if (events[contentStart][1].type === types.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text = {
      type: types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text, context],
      ["exit", text, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code) {
    effects.enter(types.atxHeading);
    return before(code);
  }
  function before(code) {
    ok(code === codes.numberSign, "expected `#`");
    effects.enter(types.atxHeadingSequence);
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === codes.numberSign && size++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code);
      return sequenceOpen;
    }
    if (code === codes.eof || markdownLineEndingOrSpace(code)) {
      effects.exit(types.atxHeadingSequence);
      return atBreak(code);
    }
    return nok(code);
  }
  function atBreak(code) {
    if (code === codes.numberSign) {
      effects.enter(types.atxHeadingSequence);
      return sequenceFurther(code);
    }
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.atxHeading);
      return ok2(code);
    }
    if (markdownSpace(code)) {
      return factorySpace(effects, atBreak, types.whitespace)(code);
    }
    effects.enter(types.atxHeadingText);
    return data(code);
  }
  function sequenceFurther(code) {
    if (code === codes.numberSign) {
      effects.consume(code);
      return sequenceFurther;
    }
    effects.exit(types.atxHeadingSequence);
    return atBreak(code);
  }
  function data(code) {
    if (code === codes.eof || code === codes.numberSign || markdownLineEndingOrSpace(code)) {
      effects.exit(types.atxHeadingText);
      return atBreak(code);
    }
    effects.consume(code);
    return data;
  }
}
// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
var blankLineBefore = { partial: true, tokenize: tokenizeBlankLineBefore };
var nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === types.htmlFlow) {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === types.linePrefix) {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start;
  function start(code) {
    return before(code);
  }
  function before(code) {
    ok(code === codes.lessThan, "expected `<`");
    effects.enter(types.htmlFlow);
    effects.enter(types.htmlFlowData);
    effects.consume(code);
    return open;
  }
  function open(code) {
    if (code === codes.exclamationMark) {
      effects.consume(code);
      return declarationOpen;
    }
    if (code === codes.slash) {
      effects.consume(code);
      closingTag = true;
      return tagCloseStart;
    }
    if (code === codes.questionMark) {
      effects.consume(code);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code)) {
      ok(code !== null);
      effects.consume(code);
      buffer = String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function declarationOpen(code) {
    if (code === codes.dash) {
      effects.consume(code);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code === codes.leftSquareBracket) {
      effects.consume(code);
      marker = constants.htmlCdata;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code);
  }
  function commentOpenInside(code) {
    if (code === codes.dash) {
      effects.consume(code);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code);
  }
  function cdataOpenInside(code) {
    const value = constants.cdataOpeningString;
    if (code === value.charCodeAt(index2++)) {
      effects.consume(code);
      if (index2 === value.length) {
        return self2.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      ok(code !== null);
      effects.consume(code);
      buffer = String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function tagName(code) {
    if (code === codes.eof || code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {
      const slash = code === codes.slash;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok2(code) : continuation(code);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code) : continuation(code);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code) : closingTag ? completeClosingTagAfter(code) : completeAttributeNameBefore(code);
    }
    if (code === codes.dash || asciiAlphanumeric(code)) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return tagName;
    }
    return nok(code);
  }
  function basicSelfClosing(code) {
    if (code === codes.greaterThan) {
      effects.consume(code);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code);
  }
  function completeClosingTagAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeClosingTagAfter;
    }
    return completeEnd(code);
  }
  function completeAttributeNameBefore(code) {
    if (code === codes.slash) {
      effects.consume(code);
      return completeEnd;
    }
    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameBefore;
    }
    return completeEnd(code);
  }
  function completeAttributeName(code) {
    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code);
  }
  function completeAttributeNameAfter(code) {
    if (code === codes.equalsTo) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code);
  }
  function completeAttributeValueBefore(code) {
    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {
      return nok(code);
    }
    if (code === codes.quotationMark || code === codes.apostrophe) {
      effects.consume(code);
      markerB = code;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code);
  }
  function completeAttributeValueQuoted(code) {
    if (code === markerB) {
      effects.consume(code);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code === codes.eof || markdownLineEnding(code)) {
      return nok(code);
    }
    effects.consume(code);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code) {
    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.slash || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent || markdownLineEndingOrSpace(code)) {
      return completeAttributeNameAfter(code);
    }
    effects.consume(code);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code) {
    if (code === codes.slash || code === codes.greaterThan || markdownSpace(code)) {
      return completeAttributeNameBefore(code);
    }
    return nok(code);
  }
  function completeEnd(code) {
    if (code === codes.greaterThan) {
      effects.consume(code);
      return completeAfter;
    }
    return nok(code);
  }
  function completeAfter(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      return continuation(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAfter;
    }
    return nok(code);
  }
  function continuation(code) {
    if (code === codes.dash && marker === constants.htmlComment) {
      effects.consume(code);
      return continuationCommentInside;
    }
    if (code === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code);
      return continuationRawTagOpen;
    }
    if (code === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code);
      return continuationClose;
    }
    if (code === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    if (code === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types.htmlFlowData);
      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code);
    }
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.htmlFlowData);
      return continuationStart(code);
    }
    effects.consume(code);
    return continuation;
  }
  function continuationStart(code) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code);
  }
  function continuationStartNonLazy(code) {
    ok(markdownLineEnding(code));
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      return continuationStart(code);
    }
    effects.enter(types.htmlFlowData);
    return continuation(code);
  }
  function continuationCommentInside(code) {
    if (code === codes.dash) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationRawTagOpen(code) {
    if (code === codes.slash) {
      effects.consume(code);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationRawEndTag(code) {
    if (code === codes.greaterThan) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code);
        return continuationClose;
      }
      return continuation(code);
    }
    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {
      ok(code !== null);
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationCdataInside(code) {
    if (code === codes.rightSquareBracket) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationDeclarationInside(code) {
    if (code === codes.greaterThan) {
      effects.consume(code);
      return continuationClose;
    }
    if (code === codes.dash && marker === constants.htmlComment) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationClose(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.htmlFlowData);
      return continuationAfter(code);
    }
    effects.consume(code);
    return continuationClose;
  }
  function continuationAfter(code) {
    effects.exit(types.htmlFlow);
    return ok2(code);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter(types.lineEnding);
      effects.consume(code);
      effects.exit(types.lineEnding);
      return after;
    }
    return nok(code);
  }
  function after(code) {
    return self2.parser.lazy[self2.now().line] ? nok(code) : ok2(code);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start;
  function start(code) {
    ok(markdownLineEnding(code), "expected a line ending");
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    return effects.attempt(blankLine, ok2, nok);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code) {
    ok(code === codes.lessThan, "expected `<`");
    effects.enter(types.htmlText);
    effects.enter(types.htmlTextData);
    effects.consume(code);
    return open;
  }
  function open(code) {
    if (code === codes.exclamationMark) {
      effects.consume(code);
      return declarationOpen;
    }
    if (code === codes.slash) {
      effects.consume(code);
      return tagCloseStart;
    }
    if (code === codes.questionMark) {
      effects.consume(code);
      return instruction;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagOpen;
    }
    return nok(code);
  }
  function declarationOpen(code) {
    if (code === codes.dash) {
      effects.consume(code);
      return commentOpenInside;
    }
    if (code === codes.leftSquareBracket) {
      effects.consume(code);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return declaration;
    }
    return nok(code);
  }
  function commentOpenInside(code) {
    if (code === codes.dash) {
      effects.consume(code);
      return commentEnd;
    }
    return nok(code);
  }
  function comment(code) {
    if (code === codes.eof) {
      return nok(code);
    }
    if (code === codes.dash) {
      effects.consume(code);
      return commentClose;
    }
    if (markdownLineEnding(code)) {
      returnState = comment;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return comment;
  }
  function commentClose(code) {
    if (code === codes.dash) {
      effects.consume(code);
      return commentEnd;
    }
    return comment(code);
  }
  function commentEnd(code) {
    return code === codes.greaterThan ? end(code) : code === codes.dash ? commentClose(code) : comment(code);
  }
  function cdataOpenInside(code) {
    const value = constants.cdataOpeningString;
    if (code === value.charCodeAt(index2++)) {
      effects.consume(code);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code);
  }
  function cdata(code) {
    if (code === codes.eof) {
      return nok(code);
    }
    if (code === codes.rightSquareBracket) {
      effects.consume(code);
      return cdataClose;
    }
    if (markdownLineEnding(code)) {
      returnState = cdata;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return cdata;
  }
  function cdataClose(code) {
    if (code === codes.rightSquareBracket) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function cdataEnd(code) {
    if (code === codes.greaterThan) {
      return end(code);
    }
    if (code === codes.rightSquareBracket) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function declaration(code) {
    if (code === codes.eof || code === codes.greaterThan) {
      return end(code);
    }
    if (markdownLineEnding(code)) {
      returnState = declaration;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return declaration;
  }
  function instruction(code) {
    if (code === codes.eof) {
      return nok(code);
    }
    if (code === codes.questionMark) {
      effects.consume(code);
      return instructionClose;
    }
    if (markdownLineEnding(code)) {
      returnState = instruction;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return instruction;
  }
  function instructionClose(code) {
    return code === codes.greaterThan ? end(code) : instruction(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagClose;
    }
    return nok(code);
  }
  function tagClose(code) {
    if (code === codes.dash || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagClose;
    }
    return tagCloseBetween(code);
  }
  function tagCloseBetween(code) {
    if (markdownLineEnding(code)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagCloseBetween;
    }
    return end(code);
  }
  function tagOpen(code) {
    if (code === codes.dash || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpen;
    }
    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function tagOpenBetween(code) {
    if (code === codes.slash) {
      effects.consume(code);
      return end;
    }
    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenBetween;
    }
    return end(code);
  }
  function tagOpenAttributeName(code) {
    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code);
  }
  function tagOpenAttributeNameAfter(code) {
    if (code === codes.equalsTo) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code);
  }
  function tagOpenAttributeValueBefore(code) {
    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {
      return nok(code);
    }
    if (code === codes.quotationMark || code === codes.apostrophe) {
      effects.consume(code);
      marker = code;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code);
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code);
      marker = undefined;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code === codes.eof) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code) {
    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.lessThan || code === codes.equalsTo || code === codes.graveAccent) {
      return nok(code);
    }
    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code) {
    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function end(code) {
    if (code === codes.greaterThan) {
      effects.consume(code);
      effects.exit(types.htmlTextData);
      effects.exit(types.htmlText);
      return ok2;
    }
    return nok(code);
  }
  function lineEndingBefore(code) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code), "expected eol");
    effects.exit(types.htmlTextData);
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code) {
    ok(self2.parser.constructs.disable.null, "expected `disable.null` to be populated");
    return markdownSpace(code) ? factorySpace(effects, lineEndingAfterPrefix, types.linePrefix, self2.parser.constructs.disable.null.includes("codeIndented") ? undefined : constants.tabSize)(code) : lineEndingAfterPrefix(code);
  }
  function lineEndingAfterPrefix(code) {
    effects.enter(types.htmlTextData);
    return returnState(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index2 = -1;
  const newEvents = [];
  while (++index2 < events.length) {
    const token = events[index2][1];
    newEvents.push(events[index2]);
    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {
      const offset = token.type === types.labelImage ? 4 : 2;
      token.type = types.data;
      index2 += offset;
    }
  }
  if (events.length !== newEvents.length) {
    splice(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === types.link || token.type === types.labelLink && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === types.labelLink) {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {
        open = index2;
        if (token.type !== types.labelLink) {
          offset = 2;
          break;
        }
      }
    } else if (token.type === types.labelEnd) {
      close = index2;
    }
  }
  ok(open !== undefined, "`open` is supposed to be found");
  ok(close !== undefined, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types.labelLink ? types.link : types.image,
    start: { ...events[open][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  const label = {
    type: types.label,
    start: { ...events[open][1].start },
    end: { ...events[close][1].end }
  };
  const text = {
    type: types.labelText,
    start: { ...events[open + offset + 2][1].end },
    end: { ...events[close - 2][1].start }
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text, context]]);
  ok(context.parser.constructs.insideSpan.null, "expected `insideSpan.null` to be populated");
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
  media = push(media, [
    ["exit", text, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === types.labelImage || self2.events[index2][1].type === types.labelLink) && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code) {
    ok(code === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code);
    }
    if (labelStart._inactive) {
      return labelEndNok(code);
    }
    defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({ start: labelStart.end, end: self2.now() })));
    effects.enter(types.labelEnd);
    effects.enter(types.labelMarker);
    effects.consume(code);
    effects.exit(types.labelMarker);
    effects.exit(types.labelEnd);
    return after;
  }
  function after(code) {
    if (code === codes.leftParenthesis) {
      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);
    }
    if (code === codes.leftSquareBracket) {
      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);
    }
    return defined ? labelEndOk(code) : labelEndNok(code);
  }
  function referenceNotFull(code) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);
  }
  function labelEndOk(code) {
    return ok2(code);
  }
  function labelEndNok(code) {
    labelStart._balanced = true;
    return nok(code);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code) {
    ok(code === codes.leftParenthesis, "expected left paren");
    effects.enter(types.resource);
    effects.enter(types.resourceMarker);
    effects.consume(code);
    effects.exit(types.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);
  }
  function resourceOpen(code) {
    if (code === codes.rightParenthesis) {
      return resourceEnd(code);
    }
    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, types.resourceDestination, types.resourceDestinationLiteral, types.resourceDestinationLiteralMarker, types.resourceDestinationRaw, types.resourceDestinationString, constants.linkResourceDestinationBalanceMax)(code);
  }
  function resourceDestinationAfter(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);
  }
  function resourceDestinationMissing(code) {
    return nok(code);
  }
  function resourceBetween(code) {
    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {
      return factoryTitle(effects, resourceTitleAfter, nok, types.resourceTitle, types.resourceTitleMarker, types.resourceTitleString)(code);
    }
    return resourceEnd(code);
  }
  function resourceTitleAfter(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);
  }
  function resourceEnd(code) {
    if (code === codes.rightParenthesis) {
      effects.enter(types.resourceMarker);
      effects.consume(code);
      effects.exit(types.resourceMarker);
      effects.exit(types.resource);
      return ok2;
    }
    return nok(code);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code) {
    ok(code === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, types.reference, types.referenceMarker, types.referenceString)(code);
  }
  function referenceFullAfter(code) {
    return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok2(code) : nok(code);
  }
  function referenceFullMissing(code) {
    return nok(code);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code) {
    ok(code === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types.reference);
    effects.enter(types.referenceMarker);
    effects.consume(code);
    effects.exit(types.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code) {
    if (code === codes.rightSquareBracket) {
      effects.enter(types.referenceMarker);
      effects.consume(code);
      effects.exit(types.referenceMarker);
      effects.exit(types.reference);
      return ok2;
    }
    return nok(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    ok(code === codes.exclamationMark, "expected `!`");
    effects.enter(types.labelImage);
    effects.enter(types.labelImageMarker);
    effects.consume(code);
    effects.exit(types.labelImageMarker);
    return open;
  }
  function open(code) {
    if (code === codes.leftSquareBracket) {
      effects.enter(types.labelMarker);
      effects.consume(code);
      effects.exit(types.labelMarker);
      effects.exit(types.labelImage);
      return after;
    }
    return nok(code);
  }
  function after(code) {
    return code === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok2(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code) {
    ok(code === codes.leftSquareBracket, "expected `[`");
    effects.enter(types.labelLink);
    effects.enter(types.labelMarker);
    effects.consume(code);
    effects.exit(types.labelMarker);
    effects.exit(types.labelLink);
    return after;
  }
  function after(code) {
    return code === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok2(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code) {
    ok(markdownLineEnding(code), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    return factorySpace(effects, ok2, types.linePrefix);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code) {
    effects.enter(types.thematicBreak);
    return before(code);
  }
  function before(code) {
    ok(code === codes.asterisk || code === codes.dash || code === codes.underscore, "expected `*`, `-`, or `_`");
    marker = code;
    return atBreak(code);
  }
  function atBreak(code) {
    if (code === marker) {
      effects.enter(types.thematicBreakSequence);
      return sequence(code);
    }
    if (size >= constants.thematicBreakMarkerCountMin && (code === codes.eof || markdownLineEnding(code))) {
      effects.exit(types.thematicBreak);
      return ok2(code);
    }
    return nok(code);
  }
  function sequence(code) {
    if (code === marker) {
      effects.consume(code);
      size++;
      return sequence;
    }
    effects.exit(types.thematicBreakSequence);
    return markdownSpace(code) ? factorySpace(effects, atBreak, types.whitespace)(code) : atBreak(code);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/list.js
var list = {
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
var listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
var indentConstruct = { partial: true, tokenize: tokenizeIndent };
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code === codes.asterisk || code === codes.plusSign || code === codes.dash ? types.listUnordered : types.listOrdered);
    if (kind === types.listUnordered ? !self2.containerState.marker || code === self2.containerState.marker : asciiDigit(code)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types.listUnordered) {
        effects.enter(types.listItemPrefix);
        return code === codes.asterisk || code === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);
      }
      if (!self2.interrupt || code === codes.digit1) {
        effects.enter(types.listItemPrefix);
        effects.enter(types.listItemValue);
        return inside(code);
      }
    }
    return nok(code);
  }
  function inside(code) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code) && ++size < constants.listItemValueSizeMax) {
      effects.consume(code);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code === self2.containerState.marker : code === codes.rightParenthesis || code === codes.dot)) {
      effects.exit(types.listItemValue);
      return atMarker(code);
    }
    return nok(code);
  }
  function atMarker(code) {
    ok(self2.containerState, "expected state");
    ok(code !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types.listItemMarker);
    effects.consume(code);
    effects.exit(types.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code;
    return effects.check(blankLine, self2.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code);
  }
  function otherPrefix(code) {
    if (markdownSpace(code)) {
      effects.enter(types.listItemPrefixWhitespace);
      effects.consume(code);
      effects.exit(types.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code);
  }
  function endOfPrefix(code) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types.listItemPrefix), true).length;
    return ok2(code);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = undefined;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(effects, ok2, types.listItemIndent, self2.containerState.size + 1)(code);
  }
  function notBlank(code) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code)) {
      self2.containerState.furtherBlankLines = undefined;
      self2.containerState.initialBlankLine = undefined;
      return notInCurrentItem(code);
    }
    self2.containerState.furtherBlankLines = undefined;
    self2.containerState.initialBlankLine = undefined;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code);
  }
  function notInCurrentItem(code) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = undefined;
    ok(self2.parser.constructs.disable.null, "expected `disable.null` to be populated");
    return factorySpace(effects, effects.attempt(list, ok2, nok), types.linePrefix, self2.parser.constructs.disable.null.includes("codeIndented") ? undefined : constants.tabSize)(code);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(effects, afterPrefix, types.listItemIndent, self2.containerState.size + 1);
  function afterPrefix(code) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code) : nok(code);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  ok(self2.parser.constructs.disable.null, "expected `disable.null` to be populated");
  return factorySpace(effects, afterPrefix, types.listItemPrefixWhitespace, self2.parser.constructs.disable.null.includes("codeIndented") ? undefined : constants.tabSize + 1);
  function afterPrefix(code) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code) && tail && tail[1].type === types.listItemPrefixWhitespace ? ok2(code) : nok(code);
  }
}
// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === types.content) {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === types.paragraph) {
        text = index2;
      }
    } else {
      if (events[index2][1].type === types.content) {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === types.definition) {
        definition2 = index2;
      }
    }
  }
  ok(text !== undefined, "expected a `text` index to be found");
  ok(content3 !== undefined, "expected a `text` index to be found");
  ok(events[content3][2] === context, "enter context should be same");
  ok(events[events.length - 1][2] === context, "enter context should be same");
  const heading = {
    type: types.setextHeading,
    start: { ...events[content3][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  events[text][1].type = types.setextHeadingText;
  if (definition2) {
    events.splice(text, 0, ["enter", heading, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = { ...events[definition2][1].end };
  } else {
    events[content3][1] = heading;
  }
  events.push(["exit", heading, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code) {
    let index2 = self2.events.length;
    let paragraph;
    ok(code === codes.dash || code === codes.equalsTo, "expected `=` or `-`");
    while (index2--) {
      if (self2.events[index2][1].type !== types.lineEnding && self2.events[index2][1].type !== types.linePrefix && self2.events[index2][1].type !== types.content) {
        paragraph = self2.events[index2][1].type === types.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph)) {
      effects.enter(types.setextHeadingLine);
      marker = code;
      return before(code);
    }
    return nok(code);
  }
  function before(code) {
    effects.enter(types.setextHeadingLineSequence);
    return inside(code);
  }
  function inside(code) {
    if (code === marker) {
      effects.consume(code);
      return inside;
    }
    effects.exit(types.setextHeadingLineSequence);
    return markdownSpace(code) ? factorySpace(effects, after, types.lineSuffix)(code) : after(code);
  }
  function after(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit(types.setextHeadingLine);
      return ok2(code);
    }
    return nok(code);
  }
}
// node_modules/micromark/dev/lib/initialize/flow.js
var flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), types.linePrefix)));
  return initial;
  function atBlankEnding(code) {
    ok(code === codes.eof || markdownLineEnding(code), "expected eol or eof");
    if (code === codes.eof) {
      effects.consume(code);
      return;
    }
    effects.enter(types.lineEndingBlank);
    effects.consume(code);
    effects.exit(types.lineEndingBlank);
    self2.currentConstruct = undefined;
    return initial;
  }
  function afterConstruct(code) {
    ok(code === codes.eof || markdownLineEnding(code), "expected eol or eof");
    if (code === codes.eof) {
      effects.consume(code);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    self2.currentConstruct = undefined;
    return initial;
  }
}

// node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : undefined),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text2 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code) {
      return atBreak(code) ? text2(code) : notText(code);
    }
    function notText(code) {
      if (code === codes.eof) {
        effects.consume(code);
        return;
      }
      effects.enter(types.data);
      effects.consume(code);
      return data;
    }
    function data(code) {
      if (atBreak(code)) {
        effects.exit(types.data);
        return text2(code);
      }
      effects.consume(code);
      return data;
    }
    function atBreak(code) {
      if (code === codes.eof) {
        return true;
      }
      const list2 = constructs2[code];
      let index2 = -1;
      if (list2) {
        ok(Array.isArray(list2), "expected `disable.null` to be populated");
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === undefined) {
        if (events[index2] && events[index2][1].type === types.data) {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== types.data) {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = undefined;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size++;
        } else if (chunk === codes.virtualSpace) {} else {
          index2++;
          break;
        }
      }
      if (context._contentTypeTextTrailing && eventIndex === events.length) {
        size = 0;
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < constants.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,
          start: {
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index2,
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size
          },
          end: { ...data.end }
        };
        data.end = { ...token.start };
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/dev/lib/constructs.js
var exports_constructs = {};
__export(exports_constructs, {
  text: () => text2,
  string: () => string2,
  insideSpan: () => insideSpan,
  flowInitial: () => flowInitial,
  flow: () => flow2,
  document: () => document3,
  disable: () => disable,
  contentInitial: () => contentInitial,
  attentionMarkers: () => attentionMarkers
});
var document3 = {
  [codes.asterisk]: list,
  [codes.plusSign]: list,
  [codes.dash]: list,
  [codes.digit0]: list,
  [codes.digit1]: list,
  [codes.digit2]: list,
  [codes.digit3]: list,
  [codes.digit4]: list,
  [codes.digit5]: list,
  [codes.digit6]: list,
  [codes.digit7]: list,
  [codes.digit8]: list,
  [codes.digit9]: list,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow2 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak,
  [codes.dash]: [setextUnderline, thematicBreak],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text2 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_src(), 1);
var debug = import_debug.default("micromark");
function createTokenizer(parser, initialize, from) {
  let point2 = {
    _bufferIndex: -1,
    _index: 0,
    line: from && from.line || 1,
    column: from && from.column || 1,
    offset: from && from.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter,
    exit: exit2,
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    code: codes.eof,
    containerState: {},
    defineSkip,
    events: [],
    now,
    parser,
    previous: codes.eof,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { _bufferIndex, _index, line, column, offset } = point2;
    return { _bufferIndex, _index, line, column, offset };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point2);
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code) {
    ok(consumed === true, "expected character to be consumed");
    consumed = undefined;
    debug("main: passing `%s` to %s", code, state && state.name);
    expectedCode = code;
    ok(typeof state === "function", "expected state");
    state = state(code);
  }
  function consume(code) {
    ok(code === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code);
    ok(consumed === undefined, "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used");
    ok(code === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter", "expected last token to be open");
    if (markdownLineEnding(code)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point2);
    } else if (code !== codes.virtualSpace) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    debug("enter: `%s`", type);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now();
    ok(type === token.type, "expected exit token to match current token");
    ok(!(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex), "expected non-empty token (`" + type + "`)");
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : ("tokenize" in constructs2) ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code) {
          const left = code !== null && map[code];
          const all2 = code !== null && map.null;
          const list2 = [
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(context.parser.constructs.disable.null, "expected `disable.null` to be populated");
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code);
          }
          return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok2, nok)(code);
        }
      }
      function ok2(code) {
        ok(code === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code) {
        ok(code === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit", "expected last token to end");
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { from: startEventsIndex, restore };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point2);
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab)
            continue;
          value = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}

// node_modules/micromark/dev/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = combineExtensions([exports_constructs, ...settings.extensions || []]);
  const parser = {
    constructs: constructs2,
    content: create(content),
    defined: [],
    document: create(document2),
    flow: create(flow),
    lazy: {},
    string: create(string),
    text: create(text)
  };
  return parser;
  function create(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {}
  return events;
}

// node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || undefined).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start = undefined;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== undefined ? match.index : value.length;
      code = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = undefined;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = undefined;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next)
              chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(codes.carriageReturn);
      if (buffer)
        chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}
// node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/mdast-util-from-markdown/dev/lib/index.js
var own3 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = undefined;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis),
      hardBreakEscape: opener(hardBreak),
      hardBreakTrailing: opener(hardBreak),
      htmlFlow: opener(html, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html, buffer),
      htmlTextData: onenterdata,
      image: opener(image),
      label: buffer,
      link: opener(link),
      listItem: opener(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading),
      strong: opener(strong),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === types.listOrdered || events[index2][1].type === types.listUnordered) {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own3.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({ sliceSerialize: events[index2][2].sliceSerialize }, context), events[index2][1]);
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, undefined, tail[0]);
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem2;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case types.listUnordered:
        case types.listOrdered:
        case types.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = undefined;
          break;
        }
        case types.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = undefined;
          }
          break;
        }
        case types.linePrefix:
        case types.listItemValue:
        case types.listItemMarker:
        case types.listItemPrefix:
        case types.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = undefined;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {
        if (listItem2) {
          let tailIndex = index2;
          lineIndex = undefined;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = types.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {} else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem2._spread = true;
          }
          listItem2.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem2, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === types.listItemPrefix) {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            end: undefined
          };
          listItem2 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = undefined;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function opener(create, and) {
    return open;
    function open(token) {
      enter.call(this, create(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler || undefined]);
    node2.position = {
      start: point2(token.start),
      end: undefined
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): its not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point2(token.end);
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(this.sliceSerialize(token), constants.numericBaseDecimal);
      this.data.expectingFirstListItemValue = undefined;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside)
      return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = undefined;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      ok(depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6, "expected `depth` between `1` and `6`");
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = undefined;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text3();
      tail.position = {
        start: point2(token.start),
        end: undefined
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point2(token.end);
      this.data.atHardBreak = undefined;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = undefined;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = undefined;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(ancestor.type === "image" || ancestor.type === "link", "expected image or link on stack");
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image" || node2.type === "link", "expected image or link on stack");
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image" || node2.type === "link", "expected image or link on stack");
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image" || node2.type === "link", "expected image or link on stack");
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = undefined;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image" || node2.type === "link", "expected image reference or link reference on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    ok(token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal");
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(data2, type === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal);
      this.data.characterReferenceType = undefined;
    } else {
      const result = decodeNamedCharacterReference(data2);
      ok(result !== false, "expected reference to decode");
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    ok(tail, "expected `node`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis() {
    return { type: "emphasis", children: [] };
  }
  function heading() {
    return {
      type: "heading",
      depth: 0,
      children: []
    };
  }
  function hardBreak() {
    return { type: "break" };
  }
  function html() {
    return { type: "html", value: "" };
  }
  function image() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph() {
    return { type: "paragraph", children: [] };
  }
  function strong() {
    return { type: "strong", children: [] };
  }
  function text3() {
    return { type: "text", value: "" };
  }
  function thematicBreak2() {
    return { type: "thematicBreak" };
  }
}
function point2(d) {
  return { line: d.line, column: d.column, offset: d.offset };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own3.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          if (right) {
            Object.assign(combined[key], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open");
  }
}
// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}
// node_modules/ccount/index.js
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character, index2 + character.length);
  }
  return count;
}

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/mdast-util-find-and-replace/node_modules/unist-util-is/lib/index.js
var convert = function(test) {
  if (test === null || test === undefined) {
    return ok2;
  }
  if (typeof test === "function") {
    return castFactory(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = check;
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = node2;
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(looksLikeANode(value) && testFunction.call(this, value, typeof index2 === "number" ? index2 : undefined, parent || undefined));
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
// node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/color.node.js
function color(d) {
  return "\x1B[33m" + d + "\x1B[39m";
}

// node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/index.js
var empty = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, undefined, [])();
  function factory(node2, index2, parents) {
    const value = node2 && typeof node2 === "object" ? node2 : {};
    if (typeof value.type === "string") {
      const name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
      Object.defineProperty(visit, "name", {
        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit;
    function visit() {
      let result = empty;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is2(node2, index2, parents[parents.length - 1] || undefined)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = node2;
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === undefined ? empty : [value];
}
// node_modules/mdast-util-find-and-replace/lib/index.js
function findAndReplace(tree, list2, options) {
  const settings = options || {};
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(list2);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      const siblings = grandparent ? grandparent.children : undefined;
      if (ignored(parent, siblings ? siblings.indexOf(parent) : undefined, grandparent)) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find = pairs[pairIndex][0];
    const replace = pairs[pairIndex][1];
    let start = 0;
    const siblings = parent.children;
    const index2 = siblings.indexOf(node2);
    let change = false;
    let nodes = [];
    find.lastIndex = 0;
    let match = find.exec(node2.value);
    while (match) {
      const position2 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value = replace(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : undefined;
      }
      if (value === false) {
        find.lastIndex = position2 + 1;
      } else {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position2)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position2 + match[0].length;
        change = true;
      }
      if (!find.global) {
        break;
      }
      match = find.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index2 = -1;
  while (++index2 < list2.length) {
    const tuple = list2[index2];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find) {
  return typeof find === "string" ? new RegExp(escapeStringRegexp(find), "g") : find;
}
function toFunction(replace) {
  return typeof replace === "function" ? replace : function() {
    return replace;
  };
}
// node_modules/mdast-util-gfm-autolink-literal/lib/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(tree, [
    [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
    [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, findEmail]
  ], { ignore: ["link", "linkReference"] });
}
function findUrl(_, protocol, domain, path, match) {
  let prefix = "";
  if (!previous2(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain = protocol + domain;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain)) {
    return false;
  }
  const parts = splitUrl(domain + path);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match) {
  if (!previous2(match, true) || /[-\d_]$/.test(label)) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain) {
  const parts = domain.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, undefined];
  }
  url = url.slice(0, trailExec.index);
  let trail = trailExec[0];
  let closingParenIndex = trail.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail.slice(0, closingParenIndex + 1);
    trail = trail.slice(closingParenIndex + 1);
    closingParenIndex = trail.indexOf(")");
    closingParens++;
  }
  return [url, trail];
}
function previous2(match, email) {
  const code = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code) || unicodePunctuation(code)) && (!email || code !== 47);
}
// node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference.peek = footnoteReferencePeek;
function enterFootnoteCallString() {
  this.buffer();
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function enterFootnoteDefinition(token) {
  this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, token);
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteReference");
  node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  node2.label = label;
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteDefinition");
  node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  node2.label = label;
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteReference(node2, _, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit2 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(state.safe(state.associationId(node2), { after: "]", before: value }));
  subexit();
  exit2();
  value += tracker.move("]");
  return value;
}
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteCallString: enterFootnoteCallString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: enterFootnoteDefinition
    },
    exit: {
      gfmFootnoteCallString: exitFootnoteCallString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: exitFootnoteDefinition
    }
  };
}
function gfmFootnoteToMarkdown(options) {
  let firstLineBlank = false;
  if (options && options.firstLineBlank) {
    firstLineBlank = true;
  }
  return {
    handlers: { footnoteDefinition, footnoteReference },
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function footnoteDefinition(node2, _, state, info) {
    const tracker = state.createTracker(info);
    let value = tracker.move("[^");
    const exit2 = state.enter("footnoteDefinition");
    const subexit = state.enter("label");
    value += tracker.move(state.safe(state.associationId(node2), { before: value, after: "]" }));
    subexit();
    value += tracker.move("]:");
    if (node2.children && node2.children.length > 0) {
      tracker.shift(4);
      value += tracker.move((firstLineBlank ? `
` : " ") + state.indentLines(state.containerFlow(node2, tracker.current()), firstLineBlank ? mapAll : mapExceptFirst));
    }
    exit2();
    return value;
  }
}
function mapExceptFirst(line, index2, blank) {
  return index2 === 0 ? line : mapAll(line, index2, blank);
}
function mapAll(line, index2, blank) {
  return (blank ? "" : "    ") + line;
}
// node_modules/mdast-util-gfm-strikethrough/lib/index.js
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _, state, info) {
  const tracker = state.createTracker(info);
  const exit2 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit2();
  return value;
}
function peekDelete() {
  return "~";
}
// node_modules/markdown-table/index.js
function defaultStringLength(value) {
  return value.length;
}
function markdownTable(table, options) {
  const settings = options || {};
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table[rowIndex].length;
    }
    while (++columnIndex2 < table[rowIndex].length) {
      const cell = serialize(table[rowIndex][columnIndex2]);
      if (settings.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes2[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === undefined || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code === 99) {
      before = ":";
      after = ":";
    } else if (code === 108) {
      before = ":";
    } else if (code === 114) {
      after = ":";
    }
    let size = settings.alignDelimiters === false ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length);
    const cell = before + "-".repeat(size) + after;
    if (settings.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (settings.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code = alignments[columnIndex];
        if (code === 114) {
          before = " ".repeat(size);
        } else if (code === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (settings.padding !== false && !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell);
      if (settings.alignDelimiters !== false) {
        line.push(after);
      }
      if (settings.padding !== false) {
        line.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join(""));
  }
  return lines.join(`
`);
}
function serialize(value) {
  return value === null || value === undefined ? "" : String(value);
}
function toAlignment(value) {
  const code = typeof value === "string" ? value.codePointAt(0) : 0;
  return code === 67 || code === 99 ? 99 : code === 76 || code === 108 ? 108 : code === 82 || code === 114 ? 114 : 0;
}

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote(node2, _, state, info) {
  const exit2 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(state.containerFlow(node2, tracker.current()), map);
  exit2();
  return value;
}
function map(line, _, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list2, none) {
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  if (!list2 || list2.length === 0) {
    return none;
  }
  let index2 = -1;
  while (++index2 < list2.length) {
    if (stack.includes(list2[index2])) {
      return true;
    }
  }
  return false;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, state, info) {
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    if (state.unsafe[index2].character === `
` && patternInScope(state.stack, state.unsafe[index2])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// node_modules/longest-streak/index.js
function longestStreak(value, substring) {
  const source = String(value);
  let index2 = source.indexOf(substring);
  let expected = index2;
  let count = 0;
  let max = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + substring.length;
    index2 = source.indexOf(substring, expected);
  }
  return max;
}

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node2, state) {
  return Boolean(state.options.fences === false && node2.value && !node2.lang && /[^ \r\n]/.test(node2.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value));
}

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error("Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code(node2, _, state, info) {
  const marker = checkFence(state);
  const raw = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit3 = state.enter("codeIndented");
    const value2 = state.indentLines(raw, map2);
    exit3();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit2 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(state.safe(node2.lang, {
      before: value,
      after: " ",
      encode: ["`"],
      ...tracker.current()
    }));
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(state.safe(node2.meta, {
      before: value,
      after: `
`,
      encode: ["`"],
      ...tracker.current()
    }));
    subexit();
  }
  value += tracker.move(`
`);
  if (raw) {
    value += tracker.move(raw + `
`);
  }
  value += tracker.move(sequence);
  exit2();
  return value;
}
function map2(line, _, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error("Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition2(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  }));
  value += tracker.move("]: ");
  subexit();
  if (!node2.url || /[\0- \u007F]/.test(node2.url)) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(state.safe(node2.url, { before: value, after: ">", ...tracker.current() }));
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(state.safe(node2.url, {
      before: value,
      after: node2.title ? " " : `
`,
      ...tracker.current()
    }));
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(state.safe(node2.title, {
      before: value,
      after: quote,
      ...tracker.current()
    }));
    value += tracker.move(quote);
    subexit();
  }
  exit2();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error("Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
function encodeCharacterReference(code2) {
  return "&#x" + code2.toString(16).toUpperCase() + ";";
}

// node_modules/mdast-util-to-markdown/lib/util/encode-info.js
function encodeInfo(outside, inside, marker) {
  const outsideKind = classifyCharacter(outside);
  const insideKind = classifyCharacter(inside);
  if (outsideKind === undefined) {
    return insideKind === undefined ? marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false } : insideKind === 1 ? { inside: true, outside: true } : { inside: false, outside: true };
  }
  if (outsideKind === 1) {
    return insideKind === undefined ? { inside: false, outside: false } : insideKind === 1 ? { inside: true, outside: true } : { inside: false, outside: false };
  }
  return insideKind === undefined ? { inside: false, outside: false } : insideKind === 1 ? { inside: true, outside: false } : { inside: false, outside: false };
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node2, _, state, info) {
  const marker = checkEmphasis(state);
  const exit2 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker);
  let between = tracker.move(state.containerPhrasing(node2, {
    after: marker,
    before,
    ...tracker.current()
  }));
  const betweenHead = between.charCodeAt(0);
  const open = encodeInfo(info.before.charCodeAt(info.before.length - 1), betweenHead, marker);
  if (open.inside) {
    between = encodeCharacterReference(betweenHead) + between.slice(1);
  }
  const betweenTail = between.charCodeAt(between.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker);
  exit2();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between + after;
}
function emphasisPeek(_, _1, state) {
  return state.options.emphasis || "*";
}

// node_modules/mdast-util-to-markdown/node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js
var convert2 = function(test) {
  if (test === null || test === undefined) {
    return ok3;
  }
  if (typeof test === "function") {
    return castFactory2(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory2(test) : propsFactory2(test);
  }
  if (typeof test === "string") {
    return typeFactory2(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory2(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert2(tests[index2]);
  }
  return castFactory2(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory2(check) {
  const checkAsRecord = check;
  return castFactory2(all2);
  function all2(node2) {
    const nodeAsRecord = node2;
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key])
        return false;
    }
    return true;
  }
}
function typeFactory2(check) {
  return castFactory2(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory2(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(looksLikeANode2(value) && testFunction.call(this, value, typeof index2 === "number" ? index2 : undefined, parent || undefined));
  }
}
function ok3() {
  return true;
}
function looksLikeANode2(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
// node_modules/mdast-util-to-markdown/node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/color.node.js
function color2(d) {
  return "\x1B[33m" + d + "\x1B[39m";
}

// node_modules/mdast-util-to-markdown/node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE2 = true;
var EXIT2 = false;
var SKIP2 = "skip";
function visitParents2(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is3 = convert2(check);
  const step = reverse ? -1 : 1;
  factory(tree, undefined, [])();
  function factory(node2, index2, parents) {
    const value = node2 && typeof node2 === "object" ? node2 : {};
    if (typeof value.type === "string") {
      const name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
      Object.defineProperty(visit, "name", {
        value: "node (" + color2(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit;
    function visit() {
      let result = empty2;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is3(node2, index2, parents[parents.length - 1] || undefined)) {
        result = toResult2(visitor(node2, parents));
        if (result[0] === EXIT2) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = node2;
        if (nodeAsParent.children && result[0] !== SKIP2) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT2) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult2(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE2, value];
  }
  return value === null || value === undefined ? empty2 : [value];
}
// node_modules/mdast-util-to-markdown/node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = undefined;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents2(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : undefined;
    return visitor(node2, index2, parent);
  }
}
// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT2;
    }
  });
  return Boolean((!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak));
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node2, _, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit3 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: `
`,
      after: `
`
    });
    subexit2();
    exit3();
    return value2 + `
` + (rank === 1 ? "=" : "-").repeat(value2.length - (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf(`
`)) + 1));
  }
  const sequence = "#".repeat(rank);
  const exit2 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: `
`,
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit2();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
html.peek = htmlPeek;
function html(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
image.peek = imagePeek;
function image(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(state.safe(node2.alt, { before: value, after: "]", ...tracker.current() }));
  value += tracker.move("](");
  subexit();
  if (!node2.url && node2.title || /[\0- \u007F]/.test(node2.url)) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(state.safe(node2.url, { before: value, after: ">", ...tracker.current() }));
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(state.safe(node2.url, {
      before: value,
      after: node2.title ? " " : ")",
      ...tracker.current()
    }));
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(state.safe(node2.title, {
      before: value,
      after: quote,
      ...tracker.current()
    }));
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak)
      continue;
    while (match = expression.exec(value)) {
      let position2 = match.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node2, state) {
  const raw = toString(node2);
  return Boolean(!state.options.resourceLink && node2.url && !node2.title && node2.children && node2.children.length === 1 && node2.children[0].type === "text" && (raw === node2.url || "mailto:" + raw === node2.url) && /^[a-z][a-z+.-]+:/i.test(node2.url) && !/[\0- <>\u007F]/.test(node2.url));
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit2;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit2 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(state.containerPhrasing(node2, {
      before: value2,
      after: ">",
      ...tracker.current()
    }));
    value2 += tracker.move(">");
    exit2();
    state.stack = stack;
    return value2;
  }
  exit2 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(state.containerPhrasing(node2, {
    before: value,
    after: "](",
    ...tracker.current()
  }));
  value += tracker.move("](");
  subexit();
  if (!node2.url && node2.title || /[\0- \u007F]/.test(node2.url)) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(state.safe(node2.url, { before: value, after: ">", ...tracker.current() }));
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(state.safe(node2.url, {
      before: value,
      after: node2.title ? " " : ")",
      ...tracker.current()
    }));
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(state.safe(node2.title, {
      before: value,
      after: quote,
      ...tracker.current()
    }));
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function linkPeek(node2, _, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text3 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text3 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !text3 || text3 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error("Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
  }
  if (bulletOther === bullet) {
    throw new Error("Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different");
  }
  return bulletOther;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error("Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error("Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list2(node2, parent, state, info) {
  const exit2 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : undefined;
    if ((bullet === "*" || bullet === "-") && firstListItem && (!firstListItem.children || !firstListItem.children[0]) && state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const item = node2.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit2();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || "one";
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error("Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
  }
  return style;
}

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit2 = state.enter("listItem");
  const value = state.indentLines(state.containerFlow(node2, tracker.current()), map3);
  exit2();
  return value;
  function map3(line, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph(node2, _, state, info) {
  const exit2 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit2();
  return value;
}

// node_modules/mdast-util-phrasing/node_modules/unist-util-is/lib/index.js
var convert3 = function(test) {
  if (test === null || test === undefined) {
    return ok4;
  }
  if (typeof test === "function") {
    return castFactory3(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory3(test) : propsFactory3(test);
  }
  if (typeof test === "string") {
    return typeFactory3(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory3(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert3(tests[index2]);
  }
  return castFactory3(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory3(check) {
  const checkAsRecord = check;
  return castFactory3(all2);
  function all2(node2) {
    const nodeAsRecord = node2;
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key])
        return false;
    }
    return true;
  }
}
function typeFactory3(check) {
  return castFactory3(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory3(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(looksLikeANode3(value) && testFunction.call(this, value, typeof index2 === "number" ? index2 : undefined, parent || undefined));
  }
}
function ok4() {
  return true;
}
function looksLikeANode3(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
// node_modules/mdast-util-phrasing/lib/index.js
var phrasing = convert3([
  "break",
  "delete",
  "emphasis",
  "footnote",
  "footnoteReference",
  "image",
  "imageReference",
  "inlineCode",
  "inlineMath",
  "link",
  "linkReference",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "strong",
  "text",
  "textDirective"
]);
// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node2, _, state, info) {
  const hasPhrasing = node2.children.some(function(d) {
    return phrasing(d);
  });
  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return container.call(state, node2, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error("Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node2, _, state, info) {
  const marker = checkStrong(state);
  const exit2 = state.enter("strong");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker + marker);
  let between = tracker.move(state.containerPhrasing(node2, {
    after: marker,
    before,
    ...tracker.current()
  }));
  const betweenHead = between.charCodeAt(0);
  const open = encodeInfo(info.before.charCodeAt(info.before.length - 1), betweenHead, marker);
  if (open.inside) {
    between = encodeCharacterReference(betweenHead) + between.slice(1);
  }
  const betweenTail = between.charCodeAt(between.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker + marker);
  exit2();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between + after;
}
function strongPeek(_, _1, state) {
  return state.options.strong || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/text.js
function text3(node2, _, state, info) {
  return state.safe(node2.value, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error("Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more");
  }
  return repetition;
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak2(_, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote,
  break: hardBreak,
  code,
  definition: definition2,
  emphasis,
  hardBreak,
  heading,
  html,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list: list2,
  listItem,
  paragraph,
  root,
  strong,
  text: text3,
  thematicBreak: thematicBreak2
};
// node_modules/mdast-util-gfm-table/lib/index.js
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit2,
      tableHeader: exit2,
      tableRow: exit2
    }
  };
}
function enterTable(token) {
  const align = token._align;
  ok(align, "expected `_align` on table");
  this.enter({
    type: "table",
    align: align.map(function(d) {
      return d === "none" ? null : d;
    }),
    children: []
  }, token);
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = undefined;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      { atBreak: true, character: "|", after: "[	 :-]" },
      { character: "|", inConstruct: "tableCell" },
      { atBreak: true, character: ":", after: "-" },
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _, state, info) {
    return serializeData(handleTableAsData(node2, state, info), node2.align);
  }
  function handleTableRow(node2, _, state, info) {
    const row = handleTableRowAsData(node2, state, info);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf(`
`));
  }
  function handleTableCell(node2, _, state, info) {
    const exit3 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit3();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      alignDelimiters,
      padding,
      stringLength
    });
  }
  function handleTableAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index2 < children.length) {
      result[index2] = handleTableRowAsData(children[index2], state, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index2 < children.length) {
      result[index2] = handleTableCell(children[index2], node2, state, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value = handle.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}
// node_modules/mdast-util-gfm-task-list-item/lib/index.js
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node2 = this.stack[this.stack.length - 2];
  ok(node2.type === "listItem");
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "paragraph");
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings.length) {
        const sibling = siblings[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, state, info) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle.listItem(node2, parent, state, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}
// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(options),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}
// node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js
var wwwPrefix = { tokenize: tokenizeWwwPrefix, partial: true };
var domain = { tokenize: tokenizeDomain, partial: true };
var path = { tokenize: tokenizePath, partial: true };
var trail = { tokenize: tokenizeTrail, partial: true };
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = {
  name: "wwwAutolink",
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var protocolAutolink = {
  name: "protocolAutolink",
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = {
  name: "emailAutolink",
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text4 = {};
function gfmAutolinkLiteral() {
  return { text: text4 };
}
var code2 = codes.digit0;
while (code2 < codes.leftCurlyBrace) {
  text4[code2] = emailAutolink;
  code2++;
  if (code2 === codes.colon)
    code2 = codes.uppercaseA;
  else if (code2 === codes.leftSquareBracket)
    code2 = codes.lowercaseA;
}
text4[codes.plusSign] = emailAutolink;
text4[codes.dash] = emailAutolink;
text4[codes.dot] = emailAutolink;
text4[codes.underscore] = emailAutolink;
text4[codes.uppercaseH] = [emailAutolink, protocolAutolink];
text4[codes.lowercaseH] = [emailAutolink, protocolAutolink];
text4[codes.uppercaseW] = [emailAutolink, wwwAutolink];
text4[codes.lowercaseW] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok5, nok) {
  const self2 = this;
  let dot;
  let data;
  return start;
  function start(code3) {
    if (!gfmAtext(code3) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code3);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code3);
  }
  function atext(code3) {
    if (gfmAtext(code3)) {
      effects.consume(code3);
      return atext;
    }
    if (code3 === codes.atSign) {
      effects.consume(code3);
      return emailDomain;
    }
    return nok(code3);
  }
  function emailDomain(code3) {
    if (code3 === codes.dot) {
      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code3);
    }
    if (code3 === codes.dash || code3 === codes.underscore || asciiAlphanumeric(code3)) {
      data = true;
      effects.consume(code3);
      return emailDomain;
    }
    return emailDomainAfter(code3);
  }
  function emailDomainDot(code3) {
    effects.consume(code3);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code3) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok5(code3);
    }
    return nok(code3);
  }
}
function tokenizeWwwAutolink(effects, ok5, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code3) {
    if (code3 !== codes.uppercaseW && code3 !== codes.lowercaseW || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code3);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code3);
  }
  function wwwAfter(code3) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok5(code3);
  }
}
function tokenizeProtocolAutolink(effects, ok5, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code3) {
    if ((code3 === codes.uppercaseH || code3 === codes.lowercaseH) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code3);
      effects.consume(code3);
      return protocolPrefixInside;
    }
    return nok(code3);
  }
  function protocolPrefixInside(code3) {
    if (asciiAlpha(code3) && buffer.length < 5) {
      buffer += String.fromCodePoint(code3);
      effects.consume(code3);
      return protocolPrefixInside;
    }
    if (code3 === codes.colon) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code3);
        return protocolSlashesInside;
      }
    }
    return nok(code3);
  }
  function protocolSlashesInside(code3) {
    if (code3 === codes.slash) {
      effects.consume(code3);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code3);
  }
  function afterProtocol(code3) {
    return code3 === codes.eof || asciiControl(code3) || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || unicodePunctuation(code3) ? nok(code3) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code3);
  }
  function protocolAfter(code3) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok5(code3);
  }
}
function tokenizeWwwPrefix(effects, ok5, nok) {
  let size = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code3) {
    if ((code3 === codes.uppercaseW || code3 === codes.lowercaseW) && size < 3) {
      size++;
      effects.consume(code3);
      return wwwPrefixInside;
    }
    if (code3 === codes.dot && size === 3) {
      effects.consume(code3);
      return wwwPrefixAfter;
    }
    return nok(code3);
  }
  function wwwPrefixAfter(code3) {
    return code3 === codes.eof ? nok(code3) : ok5(code3);
  }
}
function tokenizeDomain(effects, ok5, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code3) {
    if (code3 === codes.dot || code3 === codes.underscore) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code3);
    }
    if (code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || code3 !== codes.dash && unicodePunctuation(code3)) {
      return domainAfter(code3);
    }
    seen = true;
    effects.consume(code3);
    return domainInside;
  }
  function domainAtPunctuation(code3) {
    if (code3 === codes.underscore) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = undefined;
    }
    effects.consume(code3);
    return domainInside;
  }
  function domainAfter(code3) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code3);
    }
    return ok5(code3);
  }
}
function tokenizePath(effects, ok5) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code3) {
    if (code3 === codes.leftParenthesis) {
      sizeOpen++;
      effects.consume(code3);
      return pathInside;
    }
    if (code3 === codes.rightParenthesis && sizeClose < sizeOpen) {
      return pathAtPunctuation(code3);
    }
    if (code3 === codes.exclamationMark || code3 === codes.quotationMark || code3 === codes.ampersand || code3 === codes.apostrophe || code3 === codes.rightParenthesis || code3 === codes.asterisk || code3 === codes.comma || code3 === codes.dot || code3 === codes.colon || code3 === codes.semicolon || code3 === codes.lessThan || code3 === codes.questionMark || code3 === codes.rightSquareBracket || code3 === codes.underscore || code3 === codes.tilde) {
      return effects.check(trail, ok5, pathAtPunctuation)(code3);
    }
    if (code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      return ok5(code3);
    }
    effects.consume(code3);
    return pathInside;
  }
  function pathAtPunctuation(code3) {
    if (code3 === codes.rightParenthesis) {
      sizeClose++;
    }
    effects.consume(code3);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok5, nok) {
  return trail2;
  function trail2(code3) {
    if (code3 === codes.exclamationMark || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.rightParenthesis || code3 === codes.asterisk || code3 === codes.comma || code3 === codes.dot || code3 === codes.colon || code3 === codes.semicolon || code3 === codes.questionMark || code3 === codes.underscore || code3 === codes.tilde) {
      effects.consume(code3);
      return trail2;
    }
    if (code3 === codes.ampersand) {
      effects.consume(code3);
      return trailCharacterReferenceStart;
    }
    if (code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      return trailBracketAfter;
    }
    if (code3 === codes.lessThan || code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      return ok5(code3);
    }
    return nok(code3);
  }
  function trailBracketAfter(code3) {
    if (code3 === codes.eof || code3 === codes.leftParenthesis || code3 === codes.leftSquareBracket || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      return ok5(code3);
    }
    return trail2(code3);
  }
  function trailCharacterReferenceStart(code3) {
    return asciiAlpha(code3) ? trailCharacterReferenceInside(code3) : nok(code3);
  }
  function trailCharacterReferenceInside(code3) {
    if (code3 === codes.semicolon) {
      effects.consume(code3);
      return trail2;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return trailCharacterReferenceInside;
    }
    return nok(code3);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok5, nok) {
  return start;
  function start(code3) {
    effects.consume(code3);
    return after;
  }
  function after(code3) {
    return asciiAlphanumeric(code3) ? nok(code3) : ok5(code3);
  }
}
function previousWww(code3) {
  return code3 === codes.eof || code3 === codes.leftParenthesis || code3 === codes.asterisk || code3 === codes.underscore || code3 === codes.leftSquareBracket || code3 === codes.rightSquareBracket || code3 === codes.tilde || markdownLineEndingOrSpace(code3);
}
function previousProtocol(code3) {
  return !asciiAlpha(code3);
}
function previousEmail(code3) {
  return !(code3 === codes.slash || gfmAtext(code3));
}
function gfmAtext(code3) {
  return code3 === codes.plusSign || code3 === codes.dash || code3 === codes.dot || code3 === codes.underscore || asciiAlphanumeric(code3);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}
// node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js
var indent = { tokenize: tokenizeIndent2, partial: true };
function gfmFootnote() {
  return {
    document: {
      [codes.leftSquareBracket]: {
        name: "gfmFootnoteDefinition",
        tokenize: tokenizeDefinitionStart,
        continuation: { tokenize: tokenizeDefinitionContinuation },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [codes.leftSquareBracket]: {
        name: "gfmFootnoteCall",
        tokenize: tokenizeGfmFootnoteCall
      },
      [codes.rightSquareBracket]: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok5, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self2.events[index2][1];
    if (token.type === types.labelImage) {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === types.labelLink || token.type === types.label || token.type === types.image || token.type === types.link) {
      break;
    }
  }
  return start;
  function start(code3) {
    ok(code3 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart || !labelStart._balanced) {
      return nok(code3);
    }
    const id = normalizeIdentifier(self2.sliceSerialize({ start: labelStart.end, end: self2.now() }));
    if (id.codePointAt(0) !== codes.caret || !defined.includes(id.slice(1))) {
      return nok(code3);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok5(code3);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  let labelStart;
  while (index2--) {
    if (events[index2][1].type === types.labelImage && events[index2][0] === "enter") {
      labelStart = events[index2][1];
      break;
    }
  }
  ok(labelStart, "expected `labelStart` to resolve");
  events[index2 + 1][1].type = types.data;
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: types.chunkString,
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    events[index2 + 3],
    events[index2 + 4],
    ["enter", marker, context],
    ["exit", marker, context],
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok5, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start;
  function start(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code3) {
    if (code3 !== codes.caret)
      return nok(code3);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code3) {
    if (size > constants.linkReferenceSizeMax || code3 === codes.rightSquareBracket && !data || code3 === codes.eof || code3 === codes.leftSquareBracket || markdownLineEndingOrSpace(code3)) {
      return nok(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
        return nok(code3);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code3);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok5;
    }
    if (!markdownLineEndingOrSpace(code3)) {
      data = true;
    }
    size++;
    effects.consume(code3);
    return code3 === codes.backslash ? callEscape : callData;
  }
  function callEscape(code3) {
    if (code3 === codes.leftSquareBracket || code3 === codes.backslash || code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      size++;
      return callData;
    }
    return callData(code3);
  }
}
function tokenizeDefinitionStart(effects, ok5, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier;
  let size = 0;
  let data;
  return start;
  function start(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code3) {
    if (code3 === codes.caret) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code3);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code3);
  }
  function labelInside(code3) {
    if (size > constants.linkReferenceSizeMax || code3 === codes.rightSquareBracket && !data || code3 === codes.eof || code3 === codes.leftSquareBracket || markdownLineEndingOrSpace(code3)) {
      return nok(code3);
    }
    if (code3 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self2.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code3);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code3)) {
      data = true;
    }
    size++;
    effects.consume(code3);
    return code3 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code3) {
    if (code3 === codes.leftSquareBracket || code3 === codes.backslash || code3 === codes.rightSquareBracket) {
      effects.consume(code3);
      size++;
      return labelInside;
    }
    return labelInside(code3);
  }
  function labelAfter(code3) {
    if (code3 === codes.colon) {
      effects.enter("definitionMarker");
      effects.consume(code3);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }
      return factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace");
    }
    return nok(code3);
  }
  function whitespaceAfter(code3) {
    return ok5(code3);
  }
}
function tokenizeDefinitionContinuation(effects, ok5, nok) {
  return effects.check(blankLine, ok5, effects.attempt(indent, ok5, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok5, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", constants.tabSize + 1);
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === constants.tabSize ? ok5(code3) : nok(code3);
  }
}
// node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    name: "strikethrough",
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === undefined) {
    single = true;
  }
  return {
    text: { [codes.tilde]: tokenizer },
    insideSpan: { null: [tokenizer] },
    attentionMarkers: { null: [codes.tilde] }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text5 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text5, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan2, events.slice(open + 1, index2), context));
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text5, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough, context]
            ]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = types.data;
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok5, nok) {
    const previous3 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code3) {
      ok(code3 === codes.tilde, "expected `~`");
      if (previous3 === codes.tilde && events[events.length - 1][1].type !== types.characterEscape) {
        return nok(code3);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code3);
    }
    function more(code3) {
      const before = classifyCharacter(previous3);
      if (code3 === codes.tilde) {
        if (size > 1)
          return nok(code3);
        effects.consume(code3);
        size++;
        return more;
      }
      if (size < 2 && !single)
        return nok(code3);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code3);
      token._open = !after || after === constants.attentionSideAfter && Boolean(before);
      token._close = !before || before === constants.attentionSideAfter && Boolean(after);
      return ok5(code3);
    }
  }
}
// node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js
class EditMap {
  constructor() {
    this.map = [];
  }
  add(index2, remove, add) {
    addImplementation(this, index2, remove, add);
  }
  consume(events) {
    this.map.sort(function(a, b) {
      return a[0] - b[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index2 = this.map.length;
    const vecs = [];
    while (index2 > 0) {
      index2 -= 1;
      vecs.push(events.slice(this.map[index2][0] + this.map[index2][1]), this.map[index2][2]);
      events.length = this.map[index2][0];
    }
    vecs.push(events.slice());
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      for (const element of slice) {
        events.push(element);
      }
      slice = vecs.pop();
    }
    this.map.length = 0;
  }
}
function addImplementation(editMap, at, remove, add) {
  let index2 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index2 < editMap.map.length) {
    if (editMap.map[index2][0] === at) {
      editMap.map[index2][1] += remove;
      editMap.map[index2][2].push(...add);
      return;
    }
    index2 += 1;
  }
  editMap.map.push([at, remove, add]);
}

// node_modules/micromark-extension-gfm-table/dev/lib/infer.js
function gfmTableAlign(events, index2) {
  ok(events[index2][1].type === "table", "expected table");
  let inDelimiterRow = false;
  const align = [];
  while (index2 < events.length) {
    const event = events[index2];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
        }
      } else if (event[1].type === "tableContent") {
        if (events[index2 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index2 += 1;
  }
  return align;
}

// node_modules/micromark-extension-gfm-table/dev/lib/syntax.js
function gfmTable() {
  return {
    flow: {
      null: { name: "table", tokenize: tokenizeTable, resolveAll: resolveTable }
    }
  };
}
function tokenizeTable(effects, ok5, nok) {
  const self2 = this;
  let size = 0;
  let sizeB = 0;
  let seen;
  return start;
  function start(code3) {
    let index2 = self2.events.length - 1;
    while (index2 > -1) {
      const type = self2.events[index2][1].type;
      if (type === types.lineEnding || type === types.linePrefix)
        index2--;
      else
        break;
    }
    const tail = index2 > -1 ? self2.events[index2][1].type : null;
    const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    return next(code3);
  }
  function headRowBefore(code3) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code3);
  }
  function headRowStart(code3) {
    if (code3 === codes.verticalBar) {
      return headRowBreak(code3);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code3);
  }
  function headRowBreak(code3) {
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter(types.lineEnding);
        effects.consume(code3);
        effects.exit(types.lineEnding);
        return headDelimiterStart;
      }
      return nok(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, headRowBreak, types.whitespace)(code3);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size += 1;
    }
    if (code3 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter(types.data);
    return headRowData(code3);
  }
  function headRowData(code3) {
    if (code3 === codes.eof || code3 === codes.verticalBar || markdownLineEndingOrSpace(code3)) {
      effects.exit(types.data);
      return headRowBreak(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? headRowEscape : headRowData;
  }
  function headRowEscape(code3) {
    if (code3 === codes.backslash || code3 === codes.verticalBar) {
      effects.consume(code3);
      return headRowData;
    }
    return headRowData(code3);
  }
  function headDelimiterStart(code3) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code3)) {
      ok(self2.parser.constructs.disable.null, "expected `disabled.null`");
      return factorySpace(effects, headDelimiterBefore, types.linePrefix, self2.parser.constructs.disable.null.includes("codeIndented") ? undefined : constants.tabSize)(code3);
    }
    return headDelimiterBefore(code3);
  }
  function headDelimiterBefore(code3) {
    if (code3 === codes.dash || code3 === codes.colon) {
      return headDelimiterValueBefore(code3);
    }
    if (code3 === codes.verticalBar) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterCellBefore(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(effects, headDelimiterValueBefore, types.whitespace)(code3);
    }
    return headDelimiterValueBefore(code3);
  }
  function headDelimiterValueBefore(code3) {
    if (code3 === codes.colon) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code3);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code3 === codes.dash) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      return headDelimiterCellAfter(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterLeftAlignmentAfter(code3) {
    if (code3 === codes.dash) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterFiller(code3) {
    if (code3 === codes.dash) {
      effects.consume(code3);
      return headDelimiterFiller;
    }
    if (code3 === codes.colon) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code3);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code3);
  }
  function headDelimiterRightAlignmentAfter(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(effects, headDelimiterCellAfter, types.whitespace)(code3);
    }
    return headDelimiterCellAfter(code3);
  }
  function headDelimiterCellAfter(code3) {
    if (code3 === codes.verticalBar) {
      return headDelimiterBefore(code3);
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      if (!seen || size !== sizeB) {
        return headDelimiterNok(code3);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok5(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterNok(code3) {
    return nok(code3);
  }
  function bodyRowStart(code3) {
    effects.enter("tableRow");
    return bodyRowBreak(code3);
  }
  function bodyRowBreak(code3) {
    if (code3 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code3 === codes.eof || markdownLineEnding(code3)) {
      effects.exit("tableRow");
      return ok5(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, bodyRowBreak, types.whitespace)(code3);
    }
    effects.enter(types.data);
    return bodyRowData(code3);
  }
  function bodyRowData(code3) {
    if (code3 === codes.eof || code3 === codes.verticalBar || markdownLineEndingOrSpace(code3)) {
      effects.exit(types.data);
      return bodyRowBreak(code3);
    }
    effects.consume(code3);
    return code3 === codes.backslash ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code3) {
    if (code3 === codes.backslash || code3 === codes.verticalBar) {
      effects.consume(code3);
      return bodyRowData;
    }
    return bodyRowData(code3);
  }
}
function resolveTable(events, context) {
  let index2 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map3 = new EditMap;
  while (++index2 < events.length) {
    const event = events[index2];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          ok(currentTable, "there should be a table opening");
          flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);
          currentBody = undefined;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          end: Object.assign({}, token.end)
        };
        map3.add(index2, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = undefined;
        lastCell = [0, 0, 0, 0];
        cell = [0, index2 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            end: Object.assign({}, token.end)
          };
          map3.add(index2, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map3, context, lastCell, rowKind, undefined, currentCell);
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index2;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(map3, context, lastCell, rowKind, undefined, currentCell);
          }
          lastCell = cell;
          cell = [lastCell[1], index2, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index2;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index2;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(map3, context, lastCell, rowKind, index2, currentCell);
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map3, context, cell, rowKind, index2, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell[3] = index2;
    }
  }
  if (lastTableEnd !== 0) {
    ok(currentTable, "expected table opening");
    flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);
  }
  map3.consume(context.events);
  index2 = -1;
  while (++index2 < context.events.length) {
    const event = context.events[index2];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index2);
    }
  }
  return events;
}
function flushCell(map3, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    ok(previousCell, "expected previous cell enter");
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map3.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    end: Object.assign({}, now)
  };
  map3.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map3.add(range[2], 0, [["enter", valueToken, context]]);
    ok(range[3] !== 0);
    if (rowKind !== 2) {
      const start = context.events[range[2]];
      const end = context.events[range[3]];
      start[1].end = Object.assign({}, end[1].end);
      start[1].type = types.chunkText;
      start[1].contentType = constants.contentTypeText;
      if (range[3] > range[2] + 1) {
        const a = range[2] + 1;
        const b = range[3] - range[2] - 1;
        map3.add(a, b, []);
      }
    }
    map3.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== undefined) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map3.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = undefined;
  }
  return previousCell;
}
function flushTableEnd(map3, context, index2, table, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index2);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table.end = Object.assign({}, related);
  exits.push(["exit", table, context]);
  map3.add(index2 + 1, 0, exits);
}
function getPoint(events, index2) {
  const event = events[index2];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}
// node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js
var tasklistCheck = { name: "tasklistCheck", tokenize: tokenizeTasklistCheck };
function gfmTaskListItem() {
  return {
    text: { [codes.leftSquareBracket]: tasklistCheck }
  };
}
function tokenizeTasklistCheck(effects, ok5, nok) {
  const self2 = this;
  return open;
  function open(code3) {
    ok(code3 === codes.leftSquareBracket, "expected `[`");
    if (self2.previous !== codes.eof || !self2._gfmTasklistFirstContentOfListItem) {
      return nok(code3);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code3);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code3) {
    if (markdownLineEndingOrSpace(code3)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code3);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code3 === codes.uppercaseX || code3 === codes.lowercaseX) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code3);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code3);
  }
  function close(code3) {
    if (code3 === codes.rightSquareBracket) {
      effects.enter("taskListCheckMarker");
      effects.consume(code3);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    if (markdownLineEnding(code3)) {
      return ok5(code3);
    }
    if (markdownSpace(code3)) {
      return effects.check({ tokenize: spaceThenNonSpace }, ok5, nok)(code3);
    }
    return nok(code3);
  }
}
function spaceThenNonSpace(effects, ok5, nok) {
  return factorySpace(effects, after, types.whitespace);
  function after(code3) {
    return code3 === codes.eof ? nok(code3) : ok5(code3);
  }
}
// node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}

// node_modules/remark-gfm/lib/index.js
var emptyOptions2 = {};
function remarkGfm(options) {
  const self2 = this;
  const settings = options || emptyOptions2;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings));
}
// node_modules/unist-util-is/lib/index.js
var convert4 = function(test) {
  if (test === undefined || test === null) {
    return ok5;
  }
  if (typeof test === "string") {
    return typeFactory4(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory4(test) : propsFactory4(test);
  }
  if (typeof test === "function") {
    return castFactory4(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory4(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert4(tests[index2]);
  }
  return castFactory4(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory4(check) {
  return castFactory4(all2);
  function all2(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key])
        return false;
    }
    return true;
  }
}
function typeFactory4(check) {
  return castFactory4(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory4(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(node2 && typeof node2 === "object" && "type" in node2 && Boolean(check.call(this, node2, ...parameters)));
  }
}
function ok5() {
  return true;
}
// node_modules/unist-util-visit-parents/lib/color.js
function color3(d) {
  return "\x1B[33m" + d + "\x1B[39m";
}

// node_modules/unist-util-visit-parents/lib/index.js
var CONTINUE3 = true;
var EXIT3 = false;
var SKIP3 = "skip";
var visitParents3 = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  const is5 = convert4(test);
  const step = reverse ? -1 : 1;
  factory(tree, undefined, [])();
  function factory(node2, index2, parents) {
    const value = node2 && typeof node2 === "object" ? node2 : {};
    if (typeof value.type === "string") {
      const name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
      Object.defineProperty(visit2, "name", {
        value: "node (" + color3(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = [];
      let subresult;
      let offset;
      let grandparents;
      if (!test || is5(node2, index2, parents[parents.length - 1] || null)) {
        result = toResult3(visitor(node2, parents));
        if (result[0] === EXIT3) {
          return result;
        }
      }
      if (node2.children && result[0] !== SKIP3) {
        offset = (reverse ? node2.children.length : -1) + step;
        grandparents = parents.concat(node2);
        while (offset > -1 && offset < node2.children.length) {
          subresult = factory(node2.children[offset], offset, grandparents)();
          if (subresult[0] === EXIT3) {
            return subresult;
          }
          offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
        }
      }
      return result;
    }
  }
};
function toResult3(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE3, value];
  }
  return [value];
}
// node_modules/unist-util-visit/lib/index.js
var visit2 = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents3(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    return visitor(node2, parent ? parent.children.indexOf(node2) : null, parent);
  }
};
// node_modules/docx/build/index.mjs
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

class BaseXmlComponent {
  constructor(rootKey) {
    __publicField(this, "rootKey");
    this.rootKey = rootKey;
  }
}
var EMPTY_OBJECT = Object.seal({});

class XmlComponent extends BaseXmlComponent {
  constructor(rootKey) {
    super(rootKey);
    __publicField(this, "root");
    this.root = new Array;
  }
  prepForXml(context) {
    var _a;
    context.stack.push(this);
    const children = this.root.map((comp) => {
      if (comp instanceof BaseXmlComponent) {
        return comp.prepForXml(context);
      }
      return comp;
    }).filter((comp) => comp !== undefined);
    context.stack.pop();
    return {
      [this.rootKey]: children.length ? children.length === 1 && ((_a = children[0]) == null ? undefined : _a._attr) ? children[0] : children : EMPTY_OBJECT
    };
  }
  addChildElement(child) {
    this.root.push(child);
    return this;
  }
}

class IgnoreIfEmptyXmlComponent extends XmlComponent {
  prepForXml(context) {
    const result = super.prepForXml(context);
    if (result && (typeof result[this.rootKey] !== "object" || Object.keys(result[this.rootKey]).length)) {
      return result;
    }
    return;
  }
}

class XmlAttributeComponent extends BaseXmlComponent {
  constructor(root2) {
    super("_attr");
    __publicField(this, "xmlKeys");
    this.root = root2;
  }
  prepForXml(_) {
    const attrs = {};
    Object.keys(this.root).forEach((key) => {
      const value = this.root[key];
      if (value !== undefined) {
        const newKey = this.xmlKeys && this.xmlKeys[key] || key;
        attrs[newKey] = value;
      }
    });
    return { _attr: attrs };
  }
}

class NextAttributeComponent extends BaseXmlComponent {
  constructor(root2) {
    super("_attr");
    this.root = root2;
  }
  prepForXml(_) {
    const attrs = Object.values(this.root).filter(({ value }) => value !== undefined).reduce((acc, { key, value }) => __spreadProps(__spreadValues({}, acc), { [key]: value }), {});
    return { _attr: attrs };
  }
}

class Attributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      val: "w:val",
      color: "w:color",
      fill: "w:fill",
      space: "w:space",
      sz: "w:sz",
      type: "w:type",
      rsidR: "w:rsidR",
      rsidRPr: "w:rsidRPr",
      rsidSect: "w:rsidSect",
      w: "w:w",
      h: "w:h",
      top: "w:top",
      right: "w:right",
      bottom: "w:bottom",
      left: "w:left",
      header: "w:header",
      footer: "w:footer",
      gutter: "w:gutter",
      linePitch: "w:linePitch",
      pos: "w:pos"
    });
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var sax$1 = {};
var events = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1;i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== undefined)
    doError = doError && events2.error === undefined;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === undefined)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0;i < len; ++i)
      ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === undefined) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== undefined) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === undefined) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = { fired: false, wrapFn: undefined, target, type, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list3, events2, position2, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === undefined)
    return this;
  list3 = events2[type];
  if (list3 === undefined)
    return this;
  if (list3 === listener || list3.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list3.listener || listener);
    }
  } else if (typeof list3 !== "function") {
    position2 = -1;
    for (i = list3.length - 1;i >= 0; i--) {
      if (list3[i] === listener || list3[i].listener === listener) {
        originalListener = list3[i].listener;
        position2 = i;
        break;
      }
    }
    if (position2 < 0)
      return this;
    if (position2 === 0)
      list3.shift();
    else {
      spliceOne(list3, position2);
    }
    if (list3.length === 1)
      events2[type] = list3[0];
    if (events2.removeListener !== undefined)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i;
  events2 = this._events;
  if (events2 === undefined)
    return this;
  if (events2.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== undefined) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key;
    for (i = 0;i < keys.length; ++i) {
      key = keys[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== undefined) {
    for (i = listeners2.length - 1;i >= 0; i--) {
      this.removeListener(type, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === undefined)
    return [];
  var evlistener = events2[type];
  if (evlistener === undefined)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== undefined) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0;i < n; ++i)
    copy[i] = arr[i];
  return copy;
}
function spliceOne(list3, index2) {
  for (;index2 + 1 < list3.length; index2++)
    list3[index2] = list3[index2 + 1];
  list3.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0;i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once2(emitter, name) {
  return new Promise(function(resolve2, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver2);
      reject(err);
    }
    function resolver2() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve2([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver2, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events.exports;
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser$1 = { exports: {} };
var process2 = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process2.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1;i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process2.title = "browser";
process2.browser = true;
process2.env = {};
process2.argv = [];
process2.version = "";
process2.versions = {};
function noop() {}
process2.on = noop;
process2.addListener = noop;
process2.once = noop;
process2.off = noop;
process2.removeListener = noop;
process2.removeAllListeners = noop;
process2.emit = noop;
process2.prependListener = noop;
process2.prependOnceListener = noop;
process2.listeners = function(name) {
  return [];
};
process2.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process2.cwd = function() {
  return "/";
};
process2.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process2.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
var process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var streamBrowser;
var hasRequiredStreamBrowser;
function requireStreamBrowser() {
  if (hasRequiredStreamBrowser)
    return streamBrowser;
  hasRequiredStreamBrowser = 1;
  streamBrowser = eventsExports.EventEmitter;
  return streamBrowser;
}
var buffer = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js)
    return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code3.length;i < len; ++i) {
    lookup[i] = code3[i];
    revLookup[code3.charCodeAt(i)] = i;
  }
  revLookup[45] = 62;
  revLookup[95] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0;i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start;i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes;i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754)
    return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (;nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (;nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (;mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}
    e = e << mLen | m;
    eLen += mLen;
    for (;eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}
    buffer2[offset + i - d] |= s * 128;
  };
  return ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer)
    return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    var base64 = requireBase64Js();
    var ieee7542 = requireIeee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== undefined) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string3, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string3, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0;i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y);i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list3, length) {
      if (!Array.isArray(list3)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list3.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0;i < list3.length; ++i) {
          length += list3[i].length;
        }
      }
      var buffer2 = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0;i < list3.length; ++i) {
        var buf = list3[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer2.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string3, encoding) {
      if (Buffer2.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3);
      }
      var len = string3.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (;; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === undefined || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === undefined || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0;i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0;i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0;i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0;i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset;i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset;i >= 0; i--) {
          var found = true;
          for (var j = 0;j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string3, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string3.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0;i < length; ++i) {
        var parsed = parseInt(string3.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string3, offset, length) {
      return blitBuffer(utf8ToBytes(string3, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string3, offset, length) {
      return blitBuffer(asciiToBytes(string3), buf, offset, length);
    }
    function base64Write(buf, string3, offset, length) {
      return blitBuffer(base64ToBytes(string3), buf, offset, length);
    }
    function ucs2Write(buf, string3, offset, length) {
      return blitBuffer(utf16leToBytes(string3, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string3, offset, length, encoding) {
      if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined)
            encoding = "utf8";
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === undefined || length > remaining)
        length = remaining;
      if (string3.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (;; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length);
          case "base64":
            return base64Write(this, string3, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start;i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start;i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start;i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0;i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee7542.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee7542.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code3 = val.charCodeAt(0);
          if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
            val = code3;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start;i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0;i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string3, units) {
      units = units || Infinity;
      var codePoint;
      var length = string3.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0;i < length; ++i) {
        codePoint = string3.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0;i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0;i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0;i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0;i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0;j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  })(buffer);
  return buffer;
}
var util = {};
var types2 = {};
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1)
    return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var hasProto;
var hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto)
    return hasProto;
  hasRequiredHasProto = 1;
  var test = {
    foo: {}
  };
  var $Object = Object;
  hasProto = function hasProto2() {
    return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
  };
  return hasProto;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown)
    return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();
  hasown = bind.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError = TypeError;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var hasProto2 = requireHasProto()();
  var getProto = Object.getPrototypeOf || (hasProto2 ? function(x) {
    return x.__proto__;
  } : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn = requireHasown();
  var $concat = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace = bind.call(Function.call, String.prototype.replace);
  var $strSlice = bind.call(Function.call, String.prototype.slice);
  var $exec = bind.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string3) {
    var first = $strSlice(string3, 0, 1);
    var last = $strSlice(string3, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string3, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBind = { exports: {} };
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors)
    return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
        return true;
      } catch (e) {
        return false;
      }
    }
    return false;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!hasPropertyDescriptors()) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd)
    return gopd;
  hasRequiredGopd = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty)
    return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var hasPropertyDescriptors = requireHasPropertyDescriptors()();
  var GetIntrinsic = requireGetIntrinsic();
  var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  var $SyntaxError = GetIntrinsic("%SyntaxError%");
  var $TypeError = GetIntrinsic("%TypeError%");
  var gopd2 = requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength)
    return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var define = requireDefineDataProperty();
  var hasDescriptors = requireHasPropertyDescriptors()();
  var gOPD = requireGopd();
  var $TypeError = GetIntrinsic("%TypeError%");
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD) {
      var desc = gOPD(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(fn, "length", length, true, true);
      } else {
        define(fn, "length", length);
      }
    }
    return fn;
  };
  return setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind)
    return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var bind = requireFunctionBind();
    var GetIntrinsic = requireGetIntrinsic();
    var setFunctionLength2 = requireSetFunctionLength();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind2(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength2(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  })(callBind);
  return callBind.exports;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction)
    return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var toStr = Object.prototype.toString;
  var fnToStr = Function.prototype.toString;
  var isFnRegex = /^\s*(?:function)?\*/;
  var hasToStringTag = requireShams()();
  var getProto = Object.getPrototypeOf;
  var getGeneratorFunc = function() {
    if (!hasToStringTag) {
      return false;
    }
    try {
      return Function("return function*() {}")();
    } catch (e) {}
  };
  var GeneratorFunction;
  isGeneratorFunction = function isGeneratorFunction2(fn) {
    if (typeof fn !== "function") {
      return false;
    }
    if (isFnRegex.test(fnToStr.call(fn))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr.call(fn);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto) {
      return false;
    }
    if (typeof GeneratorFunction === "undefined") {
      var generatorFunc = getGeneratorFunc();
      GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
    }
    return getProto(fn) === GeneratorFunction;
  };
  return isGeneratorFunction;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable)
    return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_) {
      if (_ !== isCallableMarker) {
        reflectApply = null;
      }
    }
  } else {
    reflectApply = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all2 = document.all;
    if (toStr.call(all2) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e) {}
        }
        return false;
      };
    }
  }
  isCallable = reflectApply ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i = 0, len = array.length;i < len; i++) {
      if (hasOwnProperty2.call(array, i)) {
        if (receiver == null) {
          iterator(array[i], i, array);
        } else {
          iterator.call(receiver, array[i], i, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string3, iterator, receiver) {
    for (var i = 0, len = string3.length;i < len; i++) {
      if (receiver == null) {
        iterator(string3.charAt(i), i, string3);
      } else {
        iterator.call(receiver, string3.charAt(i), i, string3);
      }
    }
  };
  var forEachObject = function forEachObject2(object, iterator, receiver) {
    for (var k in object) {
      if (hasOwnProperty2.call(object, k)) {
        if (receiver == null) {
          iterator(object[k], k, object);
        } else {
          iterator.call(receiver, object[k], k, object);
        }
      }
    }
  };
  var forEach = function forEach2(list3, iterator, thisArg) {
    if (!isCallable2(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (toStr.call(list3) === "[object Array]") {
      forEachArray(list3, iterator, receiver);
    } else if (typeof list3 === "string") {
      forEachString(list3, iterator, receiver);
    } else {
      forEachObject(list3, iterator, receiver);
    }
  };
  forEach_1 = forEach;
  return forEach_1;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays)
    return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ];
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i = 0;i < possibleNames.length; i++) {
      if (typeof g[possibleNames[i]] === "function") {
        out[out.length] = possibleNames[i];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray)
    return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach = requireForEach();
  var availableTypedArrays2 = requireAvailableTypedArrays();
  var callBind2 = requireCallBind();
  var callBound2 = requireCallBound();
  var gOPD = requireGopd();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var getPrototypeOf = Object.getPrototypeOf;
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i = 0;i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var cache = { __proto__: null };
  if (hasToStringTag && gOPD && getPrototypeOf) {
    forEach(typedArrays, function(typedArray) {
      var arr = new g[typedArray];
      if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        cache["$" + typedArray] = callBind2(descriptor.get);
      }
    });
  } else {
    forEach(typedArrays, function(typedArray) {
      var arr = new g[typedArray];
      var fn = arr.slice || arr.set;
      if (fn) {
        cache["$" + typedArray] = callBind2(fn);
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found = false;
    forEach(cache, function(getter, typedArray) {
      if (!found) {
        try {
          if ("$" + getter(value) === typedArray) {
            found = $slice(typedArray, 1);
          }
        } catch (e) {}
      }
    });
    return found;
  };
  var trySlices = function tryAllSlices(value) {
    var found = false;
    forEach(cache, function(getter, name) {
      if (!found) {
        try {
          getter(value);
          found = $slice(name, 1);
        } catch (e) {}
      }
    });
    return found;
  };
  whichTypedArray = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD) {
      return null;
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
var isTypedArray;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var whichTypedArray2 = requireWhichTypedArray();
  isTypedArray = function isTypedArray2(value) {
    return !!whichTypedArray2(value);
  };
  return isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types2;
  hasRequiredTypes = 1;
  (function(exports) {
    var isArgumentsObject = requireIsArguments();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = requireWhichTypedArray();
    var isTypedArray2 = requireIsTypedArray();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction2;
    exports.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array3(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array3;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map);
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set);
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap);
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet);
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer);
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy);
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types2);
  return types2;
}
var isBufferBrowser;
var hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  if (hasRequiredIsBufferBrowser)
    return isBufferBrowser;
  hasRequiredIsBufferBrowser = 1;
  isBufferBrowser = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  return isBufferBrowser;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util;
  hasRequiredUtil = 1;
  (function(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0;i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0;i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i];i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var debugEnv = process$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process$1.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    };
    inspect.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      regexp: "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length;i < l; ++i) {
        if (hasOwnProperty2(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty2(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf(`
`) > -1) {
            if (array) {
              str = str.split(`
`).map(function(line) {
                return "  " + line;
              }).join(`
`).slice(2);
            } else {
              str = `
` + str.split(`
`).map(function(line) {
                return "   " + line;
              }).join(`
`);
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf(`
`) >= 0)
          ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + `
 `) + " " + output.join(`,
  `) + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = requireTypes();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray2;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === undefined;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = requireIsBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date;
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = inherits_browserExports;
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve2, reject) {
          promiseResolve = resolve2;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0;i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0;i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(function(ret) {
          process$1.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports.callbackify = callbackify;
  })(util);
  return util;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = requireBuffer(), Buffer2 = _require.Buffer;
  var _require2 = requireUtil(), inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_, options2) {
        return inspect(this, _objectSpread({}, options2, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errorsBrowser = {};
var hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser)
    return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes2 = {};
  function createErrorType(code3, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code3;
    codes2[code3] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search2, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search2.length) === search2;
  }
  function endsWith(str, search2, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search2.length, this_len) === search2;
  }
  function includes(str, search2, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search2.length > str.length) {
      return false;
    } else {
      return str.indexOf(search2, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes2;
  return errorsBrowser;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options2, isDuplex, duplexKey) {
    return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
  }
  function getHighWaterMark(state2, options2, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser;
  hasRequiredBrowser = 1;
  browser = deprecate;
  function deprecate(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name) {
    try {
      if (!commonjsGlobal.localStorage)
        return false;
    } catch (_) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name];
    if (val == null)
      return false;
    return String(val).toLowerCase() === "true";
  }
  return browser;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser()
  };
  var Stream2 = requireStreamBrowser();
  var Buffer2 = requireBuffer().Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  inherits_browserExports(Writable, Stream2);
  function nop() {}
  function WritableState(options2, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options2.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options2.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options2.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options2) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options2);
    this._writableState = new WritableState(options2, this, isDuplex);
    this.writable = true;
    if (options2) {
      if (typeof options2.write === "function")
        this._write = options2.write;
      if (typeof options2.writev === "function")
        this._writev = options2.writev;
      if (typeof options2.destroy === "function")
        this._destroy = options2.destroy;
      if (typeof options2.final === "function")
        this._final = options2.final;
    }
    Stream2.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END;
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES;
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state2.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state2.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
        clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret)
      state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed)
      state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state2.onwrite);
    else
      stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK;
    onwriteStateUpdate(state2);
    if (er)
      onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null)
        state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending)
      endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process$1.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished)
        process$1.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  inherits_browserExports(Duplex, Readable);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0;v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options2) {
    if (!(this instanceof Duplex))
      return new Duplex(options2);
    Readable.call(this, options2);
    Writable.call(this, options2);
    this.allowHalfOpen = true;
    if (options2) {
      if (options2.readable === false)
        this.readable = false;
      if (options2.writable === false)
        this.writable = false;
      if (options2.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer)
    return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = requireBuffer();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== undefined) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream)
    return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once3(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {}
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once3(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve2 = iter[kLastResolve];
    if (resolve2 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve2(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve2, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve2(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve2, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve2, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve2(createIterResult(undefined, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve2, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve2, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve2;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve2 = iterator[kLastResolve];
      if (resolve2 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve2(createIterResult(undefined, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser)
    return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  eventsExports.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = requireStreamBrowser();
  var Buffer2 = requireBuffer().Buffer;
  var OurUint8Array = commonjsGlobal.Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = requireUtil();
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug2() {};
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  inherits_browserExports(Readable, Stream2);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options2, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options2.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options2.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options2.encoding) {
      if (!StringDecoder)
        StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options2.encoding);
      this.encoding = options2.encoding;
    }
  }
  function Readable(options2) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options2);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options2, this, isDuplex);
    this.readable = true;
    if (options2) {
      if (typeof options2.read === "function")
        this._read = options2.read;
      if (typeof options2.destroy === "function")
        this._destroy = options2.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else
            addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0)
              addChunk(stream, state2, chunk, false);
            else
              maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront)
        state2.buffer.unshift(chunk);
      else
        state2.buffer.push(chunk);
      if (state2.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content3 = "";
    while (p !== null) {
      content3 += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content3 !== "")
      this._readableState.buffer.push(content3);
    this._readableState.length = content3.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended)
      return 0;
    if (state2.objectMode)
      return 1;
    if (n !== n) {
      if (state2.flowing && state2.length)
        return state2.buffer.head.data.length;
      else
        return state2.length;
    }
    if (n > state2.highWaterMark)
      state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length)
      return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0)
        state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading)
        n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state2);
    else
      ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended)
        state2.needReadable = true;
      if (nOrig !== n && state2.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug2("onEofChunk");
    if (state2.ended)
      return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow3(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug2("maybeReadMore read 0");
      stream.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted)
      process$1.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug2("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug2("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain)
        state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow3(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0)
      return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes)
        return this;
      if (!dest)
        dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1)
      return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1)
      state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug2("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug2("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow3(stream);
    if (state2.flowing && !state2.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow3(stream) {
    var state2 = stream._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) {}
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder)
        chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state2.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = /* @__PURE__ */ function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0)
      return null;
    var ret;
    if (state2.objectMode)
      ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder)
        ret = state2.buffer.join("");
      else if (state2.buffer.length === 1)
        ret = state2.buffer.first();
      else
        ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug2("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process$1.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug2("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === undefined) {
        from = requireFromBrowser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  inherits_browserExports(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK);
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options2) {
    if (!(this instanceof Transform))
      return new Transform(options2);
    Duplex.call(this, options2);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options2) {
      if (typeof options2.transform === "function")
        this._transform = options2.transform;
      if (typeof options2.flush === "function")
        this._flush = options2.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0;
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
    return stream.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform = require_stream_transform();
  inherits_browserExports(PassThrough, Transform);
  function PassThrough(options2) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options2);
    Transform.call(this, options2);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline)
    return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once3(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(undefined, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once3(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === undefined)
      eos = requireEndOfStream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop2;
    if (typeof streams[streams.length - 1] !== "function")
      return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0;_key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
var streamBrowserify = Stream$1;
var EE = eventsExports.EventEmitter;
var inherits = inherits_browserExports;
inherits(Stream$1, EE);
Stream$1.Readable = require_stream_readable();
Stream$1.Writable = require_stream_writable();
Stream$1.Duplex = require_stream_duplex();
Stream$1.Transform = require_stream_transform();
Stream$1.PassThrough = require_stream_passthrough();
Stream$1.finished = requireEndOfStream();
Stream$1.pipeline = requirePipeline();
Stream$1.Stream = Stream$1;
function Stream$1() {
  EE.call(this);
}
Stream$1.prototype.pipe = function(dest, options2) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (dest.write(chunk) === false && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options2 || options2.end !== false)) {
    source.on("end", onend);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    if (typeof dest.destroy === "function")
      dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
(function(exports) {
  (function(sax2) {
    sax2.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax2.SAXParser = SAXParser;
    sax2.SAXStream = SAXStream;
    sax2.createStream = createStream;
    sax2.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax2.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit2(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {}
        F.prototype = o;
        var newf = new F;
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i in o)
          if (o.hasOwnProperty(i))
            a.push(i);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length;i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax2.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length;i < l; i++) {
        parser[buffers[i]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream2;
    try {
      Stream2 = streamBrowserify.Stream;
    } catch (ex) {
      Stream2 = function() {};
    }
    var streamWraps = sax2.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream2.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h;
              return h;
            }
            me.on(ev, h);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream2.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = requireString_decoder().StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream2.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
      return c === " " || c === `
` || c === "\r" || c === "\t";
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax2.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax2.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    };
    sax2.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key) {
      var e = sax2.ENTITIES[key];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax2.ENTITIES[key] = s2;
    });
    for (var s in sax2.STATE) {
      sax2.STATE[sax2.STATE[s]] = s;
    }
    S = sax2.STATE;
    function emit2(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit2(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit2(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text5) {
      if (opt.trim)
        text5 = text5.trim();
      if (opt.normalize)
        text5 = text5.replace(/\s+/g, " ");
      return text5;
    }
    function error(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += `
Line: ` + parser.line + `
Column: ` + parser.column + `
Char: ` + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit2(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit2(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute2) {
      var i = name.indexOf(":");
      var qualName = i < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute2 && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + `
Actual: ` + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + `
Actual: ` + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i = 0, l = parser.attribList.length;i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t--) {
        var close = parser.tags[t];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i) {
      var result = "";
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === `
`) {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === `
`) {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c))
              ;
            else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c;
            if (c === "]") {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer2;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer2 = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer2 = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer2 = "attribValue";
                break;
            }
            if (c === ";") {
              parser[buffer2] += parseEntity(parser);
              parser.entity = "";
              parser.state = returnState;
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer2] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index2 = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index2 < length) {
            var codePoint = Number(arguments[index2]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index2 + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax$1);
var arrayHelper = {
  isArray: function(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    }
    return Object.prototype.toString.call(value) === "[object Array]";
  }
};
var isArray$2 = arrayHelper.isArray;
var optionsHelper = {
  copyOptions: function(options2) {
    var key, copy = {};
    for (key in options2) {
      if (options2.hasOwnProperty(key)) {
        copy[key] = options2[key];
      }
    }
    return copy;
  },
  ensureFlagExists: function(item, options2) {
    if (!(item in options2) || typeof options2[item] !== "boolean") {
      options2[item] = false;
    }
  },
  ensureSpacesExists: function(options2) {
    if (!("spaces" in options2) || typeof options2.spaces !== "number" && typeof options2.spaces !== "string") {
      options2.spaces = 0;
    }
  },
  ensureAlwaysArrayExists: function(options2) {
    if (!("alwaysArray" in options2) || typeof options2.alwaysArray !== "boolean" && !isArray$2(options2.alwaysArray)) {
      options2.alwaysArray = false;
    }
  },
  ensureKeyExists: function(key, options2) {
    if (!(key + "Key" in options2) || typeof options2[key + "Key"] !== "string") {
      options2[key + "Key"] = options2.compact ? "_" + key : key;
    }
  },
  checkFnExists: function(key, options2) {
    return key + "Fn" in options2;
  }
};
var sax = sax$1;
var helper$2 = optionsHelper;
var isArray$1 = arrayHelper.isArray;
var options;
var currentElement$1;
function validateOptions$2(userOptions) {
  options = helper$2.copyOptions(userOptions);
  helper$2.ensureFlagExists("ignoreDeclaration", options);
  helper$2.ensureFlagExists("ignoreInstruction", options);
  helper$2.ensureFlagExists("ignoreAttributes", options);
  helper$2.ensureFlagExists("ignoreText", options);
  helper$2.ensureFlagExists("ignoreComment", options);
  helper$2.ensureFlagExists("ignoreCdata", options);
  helper$2.ensureFlagExists("ignoreDoctype", options);
  helper$2.ensureFlagExists("compact", options);
  helper$2.ensureFlagExists("alwaysChildren", options);
  helper$2.ensureFlagExists("addParent", options);
  helper$2.ensureFlagExists("trim", options);
  helper$2.ensureFlagExists("nativeType", options);
  helper$2.ensureFlagExists("nativeTypeAttributes", options);
  helper$2.ensureFlagExists("sanitize", options);
  helper$2.ensureFlagExists("instructionHasAttributes", options);
  helper$2.ensureFlagExists("captureSpacesBetweenElements", options);
  helper$2.ensureAlwaysArrayExists(options);
  helper$2.ensureKeyExists("declaration", options);
  helper$2.ensureKeyExists("instruction", options);
  helper$2.ensureKeyExists("attributes", options);
  helper$2.ensureKeyExists("text", options);
  helper$2.ensureKeyExists("comment", options);
  helper$2.ensureKeyExists("cdata", options);
  helper$2.ensureKeyExists("doctype", options);
  helper$2.ensureKeyExists("type", options);
  helper$2.ensureKeyExists("name", options);
  helper$2.ensureKeyExists("elements", options);
  helper$2.ensureKeyExists("parent", options);
  helper$2.checkFnExists("doctype", options);
  helper$2.checkFnExists("instruction", options);
  helper$2.checkFnExists("cdata", options);
  helper$2.checkFnExists("comment", options);
  helper$2.checkFnExists("text", options);
  helper$2.checkFnExists("instructionName", options);
  helper$2.checkFnExists("elementName", options);
  helper$2.checkFnExists("attributeName", options);
  helper$2.checkFnExists("attributeValue", options);
  helper$2.checkFnExists("attributes", options);
  return options;
}
function nativeType(value) {
  var nValue = Number(value);
  if (!isNaN(nValue)) {
    return nValue;
  }
  var bValue = value.toLowerCase();
  if (bValue === "true") {
    return true;
  } else if (bValue === "false") {
    return false;
  }
  return value;
}
function addField(type, value) {
  var key;
  if (options.compact) {
    if (!currentElement$1[options[type + "Key"]] && (isArray$1(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + "Key"]) !== -1 : options.alwaysArray)) {
      currentElement$1[options[type + "Key"]] = [];
    }
    if (currentElement$1[options[type + "Key"]] && !isArray$1(currentElement$1[options[type + "Key"]])) {
      currentElement$1[options[type + "Key"]] = [currentElement$1[options[type + "Key"]]];
    }
    if (type + "Fn" in options && typeof value === "string") {
      value = options[type + "Fn"](value, currentElement$1);
    }
    if (type === "instruction" && (("instructionFn" in options) || ("instructionNameFn" in options))) {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          if ("instructionFn" in options) {
            value[key] = options.instructionFn(value[key], key, currentElement$1);
          } else {
            var temp = value[key];
            delete value[key];
            value[options.instructionNameFn(key, temp, currentElement$1)] = temp;
          }
        }
      }
    }
    if (isArray$1(currentElement$1[options[type + "Key"]])) {
      currentElement$1[options[type + "Key"]].push(value);
    } else {
      currentElement$1[options[type + "Key"]] = value;
    }
  } else {
    if (!currentElement$1[options.elementsKey]) {
      currentElement$1[options.elementsKey] = [];
    }
    var element2 = {};
    element2[options.typeKey] = type;
    if (type === "instruction") {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          break;
        }
      }
      element2[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement$1) : key;
      if (options.instructionHasAttributes) {
        element2[options.attributesKey] = value[key][options.attributesKey];
        if ("instructionFn" in options) {
          element2[options.attributesKey] = options.instructionFn(element2[options.attributesKey], key, currentElement$1);
        }
      } else {
        if ("instructionFn" in options) {
          value[key] = options.instructionFn(value[key], key, currentElement$1);
        }
        element2[options.instructionKey] = value[key];
      }
    } else {
      if (type + "Fn" in options) {
        value = options[type + "Fn"](value, currentElement$1);
      }
      element2[options[type + "Key"]] = value;
    }
    if (options.addParent) {
      element2[options.parentKey] = currentElement$1;
    }
    currentElement$1[options.elementsKey].push(element2);
  }
}
function manipulateAttributes(attributes) {
  if ("attributesFn" in options && attributes) {
    attributes = options.attributesFn(attributes, currentElement$1);
  }
  if ((options.trim || ("attributeValueFn" in options) || ("attributeNameFn" in options) || options.nativeTypeAttributes) && attributes) {
    var key;
    for (key in attributes) {
      if (attributes.hasOwnProperty(key)) {
        if (options.trim)
          attributes[key] = attributes[key].trim();
        if (options.nativeTypeAttributes) {
          attributes[key] = nativeType(attributes[key]);
        }
        if ("attributeValueFn" in options)
          attributes[key] = options.attributeValueFn(attributes[key], key, currentElement$1);
        if ("attributeNameFn" in options) {
          var temp = attributes[key];
          delete attributes[key];
          attributes[options.attributeNameFn(key, attributes[key], currentElement$1)] = temp;
        }
      }
    }
  }
  return attributes;
}
function onInstruction(instruction) {
  var attributes = {};
  if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
    var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
    var match;
    while ((match = attrsRegExp.exec(instruction.body)) !== null) {
      attributes[match[1]] = match[2] || match[3] || match[4];
    }
    attributes = manipulateAttributes(attributes);
  }
  if (instruction.name.toLowerCase() === "xml") {
    if (options.ignoreDeclaration) {
      return;
    }
    currentElement$1[options.declarationKey] = {};
    if (Object.keys(attributes).length) {
      currentElement$1[options.declarationKey][options.attributesKey] = attributes;
    }
    if (options.addParent) {
      currentElement$1[options.declarationKey][options.parentKey] = currentElement$1;
    }
  } else {
    if (options.ignoreInstruction) {
      return;
    }
    if (options.trim) {
      instruction.body = instruction.body.trim();
    }
    var value = {};
    if (options.instructionHasAttributes && Object.keys(attributes).length) {
      value[instruction.name] = {};
      value[instruction.name][options.attributesKey] = attributes;
    } else {
      value[instruction.name] = instruction.body;
    }
    addField("instruction", value);
  }
}
function onStartElement(name, attributes) {
  var element2;
  if (typeof name === "object") {
    attributes = name.attributes;
    name = name.name;
  }
  attributes = manipulateAttributes(attributes);
  if ("elementNameFn" in options) {
    name = options.elementNameFn(name, currentElement$1);
  }
  if (options.compact) {
    element2 = {};
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element2[options.attributesKey] = {};
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          element2[options.attributesKey][key] = attributes[key];
        }
      }
    }
    if (!(name in currentElement$1) && (isArray$1(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
      currentElement$1[name] = [];
    }
    if (currentElement$1[name] && !isArray$1(currentElement$1[name])) {
      currentElement$1[name] = [currentElement$1[name]];
    }
    if (isArray$1(currentElement$1[name])) {
      currentElement$1[name].push(element2);
    } else {
      currentElement$1[name] = element2;
    }
  } else {
    if (!currentElement$1[options.elementsKey]) {
      currentElement$1[options.elementsKey] = [];
    }
    element2 = {};
    element2[options.typeKey] = "element";
    element2[options.nameKey] = name;
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element2[options.attributesKey] = attributes;
    }
    if (options.alwaysChildren) {
      element2[options.elementsKey] = [];
    }
    currentElement$1[options.elementsKey].push(element2);
  }
  element2[options.parentKey] = currentElement$1;
  currentElement$1 = element2;
}
function onText(text5) {
  if (options.ignoreText) {
    return;
  }
  if (!text5.trim() && !options.captureSpacesBetweenElements) {
    return;
  }
  if (options.trim) {
    text5 = text5.trim();
  }
  if (options.nativeType) {
    text5 = nativeType(text5);
  }
  if (options.sanitize) {
    text5 = text5.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  addField("text", text5);
}
function onComment(comment) {
  if (options.ignoreComment) {
    return;
  }
  if (options.trim) {
    comment = comment.trim();
  }
  addField("comment", comment);
}
function onEndElement(name) {
  var parentElement = currentElement$1[options.parentKey];
  if (!options.addParent) {
    delete currentElement$1[options.parentKey];
  }
  currentElement$1 = parentElement;
}
function onCdata(cdata) {
  if (options.ignoreCdata) {
    return;
  }
  if (options.trim) {
    cdata = cdata.trim();
  }
  addField("cdata", cdata);
}
function onDoctype(doctype) {
  if (options.ignoreDoctype) {
    return;
  }
  doctype = doctype.replace(/^ /, "");
  if (options.trim) {
    doctype = doctype.trim();
  }
  addField("doctype", doctype);
}
function onError(error) {
  error.note = error;
}
var xml2js$2 = function(xml2, userOptions) {
  var parser = sax.parser(true, {});
  var result = {};
  currentElement$1 = result;
  options = validateOptions$2(userOptions);
  {
    parser.opt = { strictEntities: true };
    parser.onopentag = onStartElement;
    parser.ontext = onText;
    parser.oncomment = onComment;
    parser.onclosetag = onEndElement;
    parser.onerror = onError;
    parser.oncdata = onCdata;
    parser.ondoctype = onDoctype;
    parser.onprocessinginstruction = onInstruction;
  }
  {
    parser.write(xml2).close();
  }
  if (result[options.elementsKey]) {
    var temp = result[options.elementsKey];
    delete result[options.elementsKey];
    result[options.elementsKey] = temp;
    delete result.text;
  }
  return result;
};
var helper$1 = optionsHelper;
var xml2js$1 = xml2js$2;
function validateOptions$1(userOptions) {
  var options2 = helper$1.copyOptions(userOptions);
  helper$1.ensureSpacesExists(options2);
  return options2;
}
var xml2json$1 = function(xml2, userOptions) {
  var options2, js, json, parentKey;
  options2 = validateOptions$1(userOptions);
  js = xml2js$1(xml2, options2);
  parentKey = "compact" in options2 && options2.compact ? "_parent" : "parent";
  if ("addParent" in options2 && options2.addParent) {
    json = JSON.stringify(js, function(k, v) {
      return k === parentKey ? "_" : v;
    }, options2.spaces);
  } else {
    json = JSON.stringify(js, null, options2.spaces);
  }
  return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
};
var helper = optionsHelper;
var isArray = arrayHelper.isArray;
var currentElement;
var currentElementName;
function validateOptions(userOptions) {
  var options2 = helper.copyOptions(userOptions);
  helper.ensureFlagExists("ignoreDeclaration", options2);
  helper.ensureFlagExists("ignoreInstruction", options2);
  helper.ensureFlagExists("ignoreAttributes", options2);
  helper.ensureFlagExists("ignoreText", options2);
  helper.ensureFlagExists("ignoreComment", options2);
  helper.ensureFlagExists("ignoreCdata", options2);
  helper.ensureFlagExists("ignoreDoctype", options2);
  helper.ensureFlagExists("compact", options2);
  helper.ensureFlagExists("indentText", options2);
  helper.ensureFlagExists("indentCdata", options2);
  helper.ensureFlagExists("indentAttributes", options2);
  helper.ensureFlagExists("indentInstruction", options2);
  helper.ensureFlagExists("fullTagEmptyElement", options2);
  helper.ensureFlagExists("noQuotesForNativeAttributes", options2);
  helper.ensureSpacesExists(options2);
  if (typeof options2.spaces === "number") {
    options2.spaces = Array(options2.spaces + 1).join(" ");
  }
  helper.ensureKeyExists("declaration", options2);
  helper.ensureKeyExists("instruction", options2);
  helper.ensureKeyExists("attributes", options2);
  helper.ensureKeyExists("text", options2);
  helper.ensureKeyExists("comment", options2);
  helper.ensureKeyExists("cdata", options2);
  helper.ensureKeyExists("doctype", options2);
  helper.ensureKeyExists("type", options2);
  helper.ensureKeyExists("name", options2);
  helper.ensureKeyExists("elements", options2);
  helper.checkFnExists("doctype", options2);
  helper.checkFnExists("instruction", options2);
  helper.checkFnExists("cdata", options2);
  helper.checkFnExists("comment", options2);
  helper.checkFnExists("text", options2);
  helper.checkFnExists("instructionName", options2);
  helper.checkFnExists("elementName", options2);
  helper.checkFnExists("attributeName", options2);
  helper.checkFnExists("attributeValue", options2);
  helper.checkFnExists("attributes", options2);
  helper.checkFnExists("fullTagEmptyElement", options2);
  return options2;
}
function writeIndentation(options2, depth, firstLine) {
  return (!firstLine && options2.spaces ? `
` : "") + Array(depth + 1).join(options2.spaces);
}
function writeAttributes(attributes, options2, depth) {
  if (options2.ignoreAttributes) {
    return "";
  }
  if ("attributesFn" in options2) {
    attributes = options2.attributesFn(attributes, currentElementName, currentElement);
  }
  var key, attr, attrName, quote, result = [];
  for (key in attributes) {
    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {
      quote = options2.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
      attr = "" + attributes[key];
      attr = attr.replace(/"/g, "&quot;");
      attrName = "attributeNameFn" in options2 ? options2.attributeNameFn(key, attr, currentElementName, currentElement) : key;
      result.push(options2.spaces && options2.indentAttributes ? writeIndentation(options2, depth + 1, false) : " ");
      result.push(attrName + "=" + quote + ("attributeValueFn" in options2 ? options2.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
    }
  }
  if (attributes && Object.keys(attributes).length && options2.spaces && options2.indentAttributes) {
    result.push(writeIndentation(options2, depth, false));
  }
  return result.join("");
}
function writeDeclaration(declaration, options2, depth) {
  currentElement = declaration;
  currentElementName = "xml";
  return options2.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options2.attributesKey], options2, depth) + "?>";
}
function writeInstruction(instruction, options2, depth) {
  if (options2.ignoreInstruction) {
    return "";
  }
  var key;
  for (key in instruction) {
    if (instruction.hasOwnProperty(key)) {
      break;
    }
  }
  var instructionName = "instructionNameFn" in options2 ? options2.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
  if (typeof instruction[key] === "object") {
    currentElement = instruction;
    currentElementName = instructionName;
    return "<?" + instructionName + writeAttributes(instruction[key][options2.attributesKey], options2, depth) + "?>";
  } else {
    var instructionValue = instruction[key] ? instruction[key] : "";
    if ("instructionFn" in options2)
      instructionValue = options2.instructionFn(instructionValue, key, currentElementName, currentElement);
    return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
  }
}
function writeComment(comment, options2) {
  return options2.ignoreComment ? "" : "<!--" + ("commentFn" in options2 ? options2.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
}
function writeCdata(cdata, options2) {
  return options2.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options2 ? options2.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
}
function writeDoctype(doctype, options2) {
  return options2.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options2 ? options2.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
}
function writeText(text5, options2) {
  if (options2.ignoreText)
    return "";
  text5 = "" + text5;
  text5 = text5.replace(/&amp;/g, "&");
  text5 = text5.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return "textFn" in options2 ? options2.textFn(text5, currentElementName, currentElement) : text5;
}
function hasContent(element2, options2) {
  var i;
  if (element2.elements && element2.elements.length) {
    for (i = 0;i < element2.elements.length; ++i) {
      switch (element2.elements[i][options2.typeKey]) {
        case "text":
          if (options2.indentText) {
            return true;
          }
          break;
        case "cdata":
          if (options2.indentCdata) {
            return true;
          }
          break;
        case "instruction":
          if (options2.indentInstruction) {
            return true;
          }
          break;
        case "doctype":
        case "comment":
        case "element":
          return true;
        default:
          return true;
      }
    }
  }
  return false;
}
function writeElement(element2, options2, depth) {
  currentElement = element2;
  currentElementName = element2.name;
  var xml2 = [], elementName = "elementNameFn" in options2 ? options2.elementNameFn(element2.name, element2) : element2.name;
  xml2.push("<" + elementName);
  if (element2[options2.attributesKey]) {
    xml2.push(writeAttributes(element2[options2.attributesKey], options2, depth));
  }
  var withClosingTag = element2[options2.elementsKey] && element2[options2.elementsKey].length || element2[options2.attributesKey] && element2[options2.attributesKey]["xml:space"] === "preserve";
  if (!withClosingTag) {
    if ("fullTagEmptyElementFn" in options2) {
      withClosingTag = options2.fullTagEmptyElementFn(element2.name, element2);
    } else {
      withClosingTag = options2.fullTagEmptyElement;
    }
  }
  if (withClosingTag) {
    xml2.push(">");
    if (element2[options2.elementsKey] && element2[options2.elementsKey].length) {
      xml2.push(writeElements(element2[options2.elementsKey], options2, depth + 1));
      currentElement = element2;
      currentElementName = element2.name;
    }
    xml2.push(options2.spaces && hasContent(element2, options2) ? `
` + Array(depth + 1).join(options2.spaces) : "");
    xml2.push("</" + elementName + ">");
  } else {
    xml2.push("/>");
  }
  return xml2.join("");
}
function writeElements(elements, options2, depth, firstLine) {
  return elements.reduce(function(xml2, element2) {
    var indent2 = writeIndentation(options2, depth, firstLine && !xml2);
    switch (element2.type) {
      case "element":
        return xml2 + indent2 + writeElement(element2, options2, depth);
      case "comment":
        return xml2 + indent2 + writeComment(element2[options2.commentKey], options2);
      case "doctype":
        return xml2 + indent2 + writeDoctype(element2[options2.doctypeKey], options2);
      case "cdata":
        return xml2 + (options2.indentCdata ? indent2 : "") + writeCdata(element2[options2.cdataKey], options2);
      case "text":
        return xml2 + (options2.indentText ? indent2 : "") + writeText(element2[options2.textKey], options2);
      case "instruction":
        var instruction = {};
        instruction[element2[options2.nameKey]] = element2[options2.attributesKey] ? element2 : element2[options2.instructionKey];
        return xml2 + (options2.indentInstruction ? indent2 : "") + writeInstruction(instruction, options2, depth);
    }
  }, "");
}
function hasContentCompact(element2, options2, anyContent) {
  var key;
  for (key in element2) {
    if (element2.hasOwnProperty(key)) {
      switch (key) {
        case options2.parentKey:
        case options2.attributesKey:
          break;
        case options2.textKey:
          if (options2.indentText || anyContent) {
            return true;
          }
          break;
        case options2.cdataKey:
          if (options2.indentCdata || anyContent) {
            return true;
          }
          break;
        case options2.instructionKey:
          if (options2.indentInstruction || anyContent) {
            return true;
          }
          break;
        case options2.doctypeKey:
        case options2.commentKey:
          return true;
        default:
          return true;
      }
    }
  }
  return false;
}
function writeElementCompact(element2, name, options2, depth, indent2) {
  currentElement = element2;
  currentElementName = name;
  var elementName = "elementNameFn" in options2 ? options2.elementNameFn(name, element2) : name;
  if (typeof element2 === "undefined" || element2 === null || element2 === "") {
    return "fullTagEmptyElementFn" in options2 && options2.fullTagEmptyElementFn(name, element2) || options2.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
  }
  var xml2 = [];
  if (name) {
    xml2.push("<" + elementName);
    if (typeof element2 !== "object") {
      xml2.push(">" + writeText(element2, options2) + "</" + elementName + ">");
      return xml2.join("");
    }
    if (element2[options2.attributesKey]) {
      xml2.push(writeAttributes(element2[options2.attributesKey], options2, depth));
    }
    var withClosingTag = hasContentCompact(element2, options2, true) || element2[options2.attributesKey] && element2[options2.attributesKey]["xml:space"] === "preserve";
    if (!withClosingTag) {
      if ("fullTagEmptyElementFn" in options2) {
        withClosingTag = options2.fullTagEmptyElementFn(name, element2);
      } else {
        withClosingTag = options2.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml2.push(">");
    } else {
      xml2.push("/>");
      return xml2.join("");
    }
  }
  xml2.push(writeElementsCompact(element2, options2, depth + 1, false));
  currentElement = element2;
  currentElementName = name;
  if (name) {
    xml2.push((indent2 ? writeIndentation(options2, depth, false) : "") + "</" + elementName + ">");
  }
  return xml2.join("");
}
function writeElementsCompact(element2, options2, depth, firstLine) {
  var i, key, nodes, xml2 = [];
  for (key in element2) {
    if (element2.hasOwnProperty(key)) {
      nodes = isArray(element2[key]) ? element2[key] : [element2[key]];
      for (i = 0;i < nodes.length; ++i) {
        switch (key) {
          case options2.declarationKey:
            xml2.push(writeDeclaration(nodes[i], options2, depth));
            break;
          case options2.instructionKey:
            xml2.push((options2.indentInstruction ? writeIndentation(options2, depth, firstLine) : "") + writeInstruction(nodes[i], options2, depth));
            break;
          case options2.attributesKey:
          case options2.parentKey:
            break;
          case options2.textKey:
            xml2.push((options2.indentText ? writeIndentation(options2, depth, firstLine) : "") + writeText(nodes[i], options2));
            break;
          case options2.cdataKey:
            xml2.push((options2.indentCdata ? writeIndentation(options2, depth, firstLine) : "") + writeCdata(nodes[i], options2));
            break;
          case options2.doctypeKey:
            xml2.push(writeIndentation(options2, depth, firstLine) + writeDoctype(nodes[i], options2));
            break;
          case options2.commentKey:
            xml2.push(writeIndentation(options2, depth, firstLine) + writeComment(nodes[i], options2));
            break;
          default:
            xml2.push(writeIndentation(options2, depth, firstLine) + writeElementCompact(nodes[i], key, options2, depth, hasContentCompact(nodes[i], options2)));
        }
        firstLine = firstLine && !xml2.length;
      }
    }
  }
  return xml2.join("");
}
var js2xml$2 = function(js, options2) {
  options2 = validateOptions(options2);
  var xml2 = [];
  currentElement = js;
  currentElementName = "_root_";
  if (options2.compact) {
    xml2.push(writeElementsCompact(js, options2, 0, true));
  } else {
    if (js[options2.declarationKey]) {
      xml2.push(writeDeclaration(js[options2.declarationKey], options2, 0));
    }
    if (js[options2.elementsKey] && js[options2.elementsKey].length) {
      xml2.push(writeElements(js[options2.elementsKey], options2, 0, !xml2.length));
    }
  }
  return xml2.join("");
};
var js2xml$1 = js2xml$2;
var json2xml$1 = function(json, options2) {
  if (json instanceof Buffer) {
    json = json.toString();
  }
  var js = null;
  if (typeof json === "string") {
    try {
      js = JSON.parse(json);
    } catch (e) {
      throw new Error("The JSON structure is invalid");
    }
  } else {
    js = json;
  }
  return js2xml$1(js, options2);
};
var xml2js = xml2js$2;
var xml2json = xml2json$1;
var js2xml = js2xml$2;
var json2xml = json2xml$1;
var lib = {
  xml2js,
  xml2json,
  js2xml,
  json2xml
};
var convertToXmlComponent = (element2) => {
  switch (element2.type) {
    case undefined:
    case "element":
      const xmlComponent = new ImportedXmlComponent(element2.name, element2.attributes);
      const childElements = element2.elements || [];
      for (const childElm of childElements) {
        const child = convertToXmlComponent(childElm);
        if (child !== undefined) {
          xmlComponent.push(child);
        }
      }
      return xmlComponent;
    case "text":
      return element2.text;
    default:
      return;
  }
};

class ImportedXmlComponentAttributes extends XmlAttributeComponent {
}

class ImportedXmlComponent extends XmlComponent {
  static fromXmlString(importedContent) {
    const xmlObj = lib.xml2js(importedContent, { compact: false });
    return convertToXmlComponent(xmlObj);
  }
  constructor(rootKey, _attr) {
    super(rootKey);
    if (_attr) {
      this.root.push(new ImportedXmlComponentAttributes(_attr));
    }
  }
  push(xmlComponent) {
    this.root.push(xmlComponent);
  }
}

class ImportedRootElementAttributes extends XmlComponent {
  constructor(_attr) {
    super("");
    this._attr = _attr;
  }
  prepForXml(_) {
    return {
      _attr: this._attr
    };
  }
}
class InitializableXmlComponent extends XmlComponent {
  constructor(rootKey, initComponent) {
    super(rootKey);
    if (initComponent) {
      this.root = initComponent.root;
    }
  }
}
var decimalNumber = (val) => {
  if (isNaN(val)) {
    throw new Error(`Invalid value '${val}' specified. Must be an integer.`);
  }
  return Math.floor(val);
};
var unsignedDecimalNumber = (val) => {
  const value = decimalNumber(val);
  if (value < 0) {
    throw new Error(`Invalid value '${val}' specified. Must be a positive integer.`);
  }
  return value;
};
var hexBinary = (val, length) => {
  const expectedLength = length * 2;
  if (val.length !== expectedLength || isNaN(Number(`0x${val}`))) {
    throw new Error(`Invalid hex value '${val}'. Expected ${expectedLength} digit hex value`);
  }
  return val;
};
var shortHexNumber = (val) => hexBinary(val, 2);
var uCharHexNumber = (val) => hexBinary(val, 1);
var universalMeasureValue = (val) => {
  const unit = val.slice(-2);
  const amount = val.substring(0, val.length - 2);
  return `${Number(amount)}${unit}`;
};
var positiveUniversalMeasureValue = (val) => {
  const value = universalMeasureValue(val);
  if (parseFloat(value) < 0) {
    throw new Error(`Invalid value '${value}' specified. Expected a positive number.`);
  }
  return value;
};
var hexColorValue = (val) => {
  if (val === "auto") {
    return val;
  }
  const color4 = val.charAt(0) === "#" ? val.substring(1) : val;
  return hexBinary(color4, 3);
};
var signedTwipsMeasureValue = (val) => typeof val === "string" ? universalMeasureValue(val) : decimalNumber(val);
var hpsMeasureValue = (val) => typeof val === "string" ? positiveUniversalMeasureValue(val) : unsignedDecimalNumber(val);
var twipsMeasureValue = (val) => typeof val === "string" ? positiveUniversalMeasureValue(val) : unsignedDecimalNumber(val);
var percentageValue = (val) => {
  const percent = val.substring(0, val.length - 1);
  return `${Number(percent)}%`;
};
var measurementOrPercentValue = (val) => {
  if (typeof val === "number") {
    return decimalNumber(val);
  }
  if (val.slice(-1) === "%") {
    return percentageValue(val);
  }
  return universalMeasureValue(val);
};
var eighthPointMeasureValue = unsignedDecimalNumber;
var pointMeasureValue = unsignedDecimalNumber;
var dateTimeValue = (val) => val.toISOString();

class OnOffElement extends XmlComponent {
  constructor(name, val = true) {
    super(name);
    if (val !== true) {
      this.root.push(new Attributes({ val }));
    }
  }
}

class HpsMeasureElement extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(new Attributes({ val: hpsMeasureValue(val) }));
  }
}
class StringValueElement extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(new Attributes({ val }));
  }
}
var createStringElement = (name, value) => new BuilderElement({
  name,
  attributes: {
    value: { key: "w:val", value }
  }
});

class NumberValueElement extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(new Attributes({ val }));
  }
}

class StringEnumValueElement extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(new Attributes({ val }));
  }
}

class StringContainer extends XmlComponent {
  constructor(name, val) {
    super(name);
    this.root.push(val);
  }
}

class BuilderElement extends XmlComponent {
  constructor({
    name,
    attributes,
    children
  }) {
    super(name);
    if (attributes) {
      this.root.push(new NextAttributeComponent(attributes));
    }
    if (children) {
      this.root.push(...children);
    }
  }
}
var AlignmentType = {
  START: "start",
  CENTER: "center",
  END: "end",
  BOTH: "both",
  MEDIUM_KASHIDA: "mediumKashida",
  DISTRIBUTE: "distribute",
  NUM_TAB: "numTab",
  HIGH_KASHIDA: "highKashida",
  LOW_KASHIDA: "lowKashida",
  THAI_DISTRIBUTE: "thaiDistribute",
  LEFT: "left",
  RIGHT: "right",
  JUSTIFIED: "both"
};

class AlignmentAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
}

class Alignment extends XmlComponent {
  constructor(type) {
    super("w:jc");
    this.root.push(new AlignmentAttributes({ val: type }));
  }
}

class BorderElement extends XmlComponent {
  constructor(elementName, { color: color4, size, space, style }) {
    super(elementName);
    this.root.push(new BordersAttributes({
      style,
      color: color4 === undefined ? undefined : hexColorValue(color4),
      size: size === undefined ? undefined : eighthPointMeasureValue(size),
      space: space === undefined ? undefined : pointMeasureValue(space)
    }));
  }
}

class BordersAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      style: "w:val",
      color: "w:color",
      size: "w:sz",
      space: "w:space"
    });
  }
}
var BorderStyle = {
  SINGLE: "single",
  DASH_DOT_STROKED: "dashDotStroked",
  DASHED: "dashed",
  DASH_SMALL_GAP: "dashSmallGap",
  DOT_DASH: "dotDash",
  DOT_DOT_DASH: "dotDotDash",
  DOTTED: "dotted",
  DOUBLE: "double",
  DOUBLE_WAVE: "doubleWave",
  INSET: "inset",
  NIL: "nil",
  NONE: "none",
  OUTSET: "outset",
  THICK: "thick",
  THICK_THIN_LARGE_GAP: "thickThinLargeGap",
  THICK_THIN_MEDIUM_GAP: "thickThinMediumGap",
  THICK_THIN_SMALL_GAP: "thickThinSmallGap",
  THIN_THICK_LARGE_GAP: "thinThickLargeGap",
  THIN_THICK_MEDIUM_GAP: "thinThickMediumGap",
  THIN_THICK_SMALL_GAP: "thinThickSmallGap",
  THIN_THICK_THIN_LARGE_GAP: "thinThickThinLargeGap",
  THIN_THICK_THIN_MEDIUM_GAP: "thinThickThinMediumGap",
  THIN_THICK_THIN_SMALL_GAP: "thinThickThinSmallGap",
  THREE_D_EMBOSS: "threeDEmboss",
  THREE_D_ENGRAVE: "threeDEngrave",
  TRIPLE: "triple",
  WAVE: "wave"
};

class Border extends IgnoreIfEmptyXmlComponent {
  constructor(options2) {
    super("w:pBdr");
    if (options2.top) {
      this.root.push(new BorderElement("w:top", options2.top));
    }
    if (options2.bottom) {
      this.root.push(new BorderElement("w:bottom", options2.bottom));
    }
    if (options2.left) {
      this.root.push(new BorderElement("w:left", options2.left));
    }
    if (options2.right) {
      this.root.push(new BorderElement("w:right", options2.right));
    }
  }
}

class ThematicBreak extends XmlComponent {
  constructor() {
    super("w:pBdr");
    const bottom = new BorderElement("w:bottom", {
      color: "auto",
      space: 1,
      style: BorderStyle.SINGLE,
      size: 6
    });
    this.root.push(bottom);
  }
}

class Indent extends XmlComponent {
  constructor({ start, end, left, right, hanging, firstLine }) {
    super("w:ind");
    this.root.push(new NextAttributeComponent({
      start: {
        key: "w:start",
        value: start === undefined ? undefined : signedTwipsMeasureValue(start)
      },
      end: {
        key: "w:end",
        value: end === undefined ? undefined : signedTwipsMeasureValue(end)
      },
      left: {
        key: "w:left",
        value: left === undefined ? undefined : signedTwipsMeasureValue(left)
      },
      right: {
        key: "w:right",
        value: right === undefined ? undefined : signedTwipsMeasureValue(right)
      },
      hanging: {
        key: "w:hanging",
        value: hanging === undefined ? undefined : twipsMeasureValue(hanging)
      },
      firstLine: {
        key: "w:firstLine",
        value: firstLine === undefined ? undefined : twipsMeasureValue(firstLine)
      }
    }));
  }
}
var Break$1 = class Break extends XmlComponent {
  constructor() {
    super("w:br");
  }
};
var FieldCharacterType = {
  BEGIN: "begin",
  END: "end",
  SEPARATE: "separate"
};

class FidCharAttrs extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { type: "w:fldCharType", dirty: "w:dirty" });
  }
}

class Begin extends XmlComponent {
  constructor(dirty) {
    super("w:fldChar");
    this.root.push(new FidCharAttrs({ type: FieldCharacterType.BEGIN, dirty }));
  }
}

class Separate extends XmlComponent {
  constructor(dirty) {
    super("w:fldChar");
    this.root.push(new FidCharAttrs({ type: FieldCharacterType.SEPARATE, dirty }));
  }
}

class End extends XmlComponent {
  constructor(dirty) {
    super("w:fldChar");
    this.root.push(new FidCharAttrs({ type: FieldCharacterType.END, dirty }));
  }
}
var SpaceType = {
  DEFAULT: "default",
  PRESERVE: "preserve"
};

class TextAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { space: "xml:space" });
  }
}

class Page extends XmlComponent {
  constructor() {
    super("w:instrText");
    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
    this.root.push("PAGE");
  }
}

class NumberOfPages extends XmlComponent {
  constructor() {
    super("w:instrText");
    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
    this.root.push("NUMPAGES");
  }
}

class NumberOfPagesSection extends XmlComponent {
  constructor() {
    super("w:instrText");
    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
    this.root.push("SECTIONPAGES");
  }
}

class CurrentSection extends XmlComponent {
  constructor() {
    super("w:instrText");
    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
    this.root.push("SECTION");
  }
}

class ShadingAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      fill: "w:fill",
      color: "w:color",
      type: "w:val"
    });
  }
}

class Shading extends XmlComponent {
  constructor({ fill, color: color4, type }) {
    super("w:shd");
    this.root.push(new ShadingAttributes({
      fill: fill === undefined ? undefined : hexColorValue(fill),
      color: color4 === undefined ? undefined : hexColorValue(color4),
      type
    }));
  }
}
class ChangeAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "w:id",
      author: "w:author",
      date: "w:date"
    });
  }
}
var EmphasisMarkType = {
  DOT: "dot"
};

class BaseEmphasisMark extends XmlComponent {
  constructor(emphasisMarkType) {
    super("w:em");
    this.root.push(new Attributes({
      val: emphasisMarkType
    }));
  }
}

class EmphasisMark extends BaseEmphasisMark {
  constructor(emphasisMarkType = EmphasisMarkType.DOT) {
    super(emphasisMarkType);
  }
}
class CharacterSpacing extends XmlComponent {
  constructor(value) {
    super("w:spacing");
    this.root.push(new Attributes({
      val: signedTwipsMeasureValue(value)
    }));
  }
}

class Color extends XmlComponent {
  constructor(color4) {
    super("w:color");
    this.root.push(new Attributes({
      val: hexColorValue(color4)
    }));
  }
}

class Highlight extends XmlComponent {
  constructor(color4) {
    super("w:highlight");
    this.root.push(new Attributes({
      val: color4
    }));
  }
}

class HighlightComplexScript extends XmlComponent {
  constructor(color4) {
    super("w:highlightCs");
    this.root.push(new Attributes({
      val: color4
    }));
  }
}
var createLanguageComponent = (options2) => new BuilderElement({
  name: "w:lang",
  attributes: {
    value: {
      key: "w:val",
      value: options2.value
    },
    eastAsia: {
      key: "w:eastAsia",
      value: options2.eastAsia
    },
    bidirectional: {
      key: "w:bidi",
      value: options2.bidirectional
    }
  }
});

class RunFontAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      ascii: "w:ascii",
      cs: "w:cs",
      eastAsia: "w:eastAsia",
      hAnsi: "w:hAnsi",
      hint: "w:hint"
    });
  }
}

class RunFonts extends XmlComponent {
  constructor(nameOrAttrs, hint) {
    super("w:rFonts");
    if (typeof nameOrAttrs === "string") {
      const name = nameOrAttrs;
      this.root.push(new RunFontAttributes({
        ascii: name,
        cs: name,
        eastAsia: name,
        hAnsi: name,
        hint
      }));
    } else {
      const attrs = nameOrAttrs;
      this.root.push(new RunFontAttributes(attrs));
    }
  }
}
var VerticalAlign$1 = class VerticalAlign extends XmlComponent {
  constructor(type) {
    super("w:vertAlign");
    this.root.push(new Attributes({
      val: type
    }));
  }
};

class SuperScript extends VerticalAlign$1 {
  constructor() {
    super("superscript");
  }
}

class SubScript extends VerticalAlign$1 {
  constructor() {
    super("subscript");
  }
}
var UnderlineType = {
  SINGLE: "single",
  WORDS: "words",
  DOUBLE: "double",
  THICK: "thick",
  DOTTED: "dotted",
  DOTTEDHEAVY: "dottedHeavy",
  DASH: "dash",
  DASHEDHEAVY: "dashedHeavy",
  DASHLONG: "dashLong",
  DASHLONGHEAVY: "dashLongHeavy",
  DOTDASH: "dotDash",
  DASHDOTHEAVY: "dashDotHeavy",
  DOTDOTDASH: "dotDotDash",
  DASHDOTDOTHEAVY: "dashDotDotHeavy",
  WAVE: "wave",
  WAVYHEAVY: "wavyHeavy",
  WAVYDOUBLE: "wavyDouble",
  NONE: "none"
};

class Underline extends XmlComponent {
  constructor(underlineType = UnderlineType.SINGLE, color4) {
    super("w:u");
    this.root.push(new Attributes({
      val: underlineType,
      color: color4 === undefined ? undefined : hexColorValue(color4)
    }));
  }
}
class RunProperties extends IgnoreIfEmptyXmlComponent {
  constructor(options2) {
    var _a, _b;
    super("w:rPr");
    if (!options2) {
      return;
    }
    if (options2.noProof !== undefined) {
      this.push(new OnOffElement("w:noProof", options2.noProof));
    }
    if (options2.bold !== undefined) {
      this.push(new OnOffElement("w:b", options2.bold));
    }
    if (options2.boldComplexScript === undefined && options2.bold !== undefined || options2.boldComplexScript) {
      this.push(new OnOffElement("w:bCs", (_a = options2.boldComplexScript) != null ? _a : options2.bold));
    }
    if (options2.italics !== undefined) {
      this.push(new OnOffElement("w:i", options2.italics));
    }
    if (options2.italicsComplexScript === undefined && options2.italics !== undefined || options2.italicsComplexScript) {
      this.push(new OnOffElement("w:iCs", (_b = options2.italicsComplexScript) != null ? _b : options2.italics));
    }
    if (options2.underline) {
      this.push(new Underline(options2.underline.type, options2.underline.color));
    }
    if (options2.effect) {
      this.push(new StringValueElement("w:effect", options2.effect));
    }
    if (options2.emphasisMark) {
      this.push(new EmphasisMark(options2.emphasisMark.type));
    }
    if (options2.color) {
      this.push(new Color(options2.color));
    }
    if (options2.kern) {
      this.push(new HpsMeasureElement("w:kern", options2.kern));
    }
    if (options2.position) {
      this.push(new StringValueElement("w:position", options2.position));
    }
    if (options2.size !== undefined) {
      this.push(new HpsMeasureElement("w:sz", options2.size));
    }
    const szCs = options2.sizeComplexScript === undefined || options2.sizeComplexScript === true ? options2.size : options2.sizeComplexScript;
    if (szCs) {
      this.push(new HpsMeasureElement("w:szCs", szCs));
    }
    if (options2.rightToLeft !== undefined) {
      this.push(new OnOffElement("w:rtl", options2.rightToLeft));
    }
    if (options2.smallCaps !== undefined) {
      this.push(new OnOffElement("w:smallCaps", options2.smallCaps));
    } else if (options2.allCaps !== undefined) {
      this.push(new OnOffElement("w:caps", options2.allCaps));
    }
    if (options2.strike !== undefined) {
      this.push(new OnOffElement("w:strike", options2.strike));
    }
    if (options2.doubleStrike !== undefined) {
      this.push(new OnOffElement("w:dstrike", options2.doubleStrike));
    }
    if (options2.subScript) {
      this.push(new SubScript);
    }
    if (options2.superScript) {
      this.push(new SuperScript);
    }
    if (options2.style) {
      this.push(new StringValueElement("w:rStyle", options2.style));
    }
    if (options2.font) {
      if (typeof options2.font === "string") {
        this.push(new RunFonts(options2.font));
      } else if ("name" in options2.font) {
        this.push(new RunFonts(options2.font.name, options2.font.hint));
      } else {
        this.push(new RunFonts(options2.font));
      }
    }
    if (options2.highlight) {
      this.push(new Highlight(options2.highlight));
    }
    const highlightCs = options2.highlightComplexScript === undefined || options2.highlightComplexScript === true ? options2.highlight : options2.highlightComplexScript;
    if (highlightCs) {
      this.push(new HighlightComplexScript(highlightCs));
    }
    if (options2.characterSpacing) {
      this.push(new CharacterSpacing(options2.characterSpacing));
    }
    if (options2.emboss !== undefined) {
      this.push(new OnOffElement("w:emboss", options2.emboss));
    }
    if (options2.imprint !== undefined) {
      this.push(new OnOffElement("w:imprint", options2.imprint));
    }
    if (options2.shading) {
      this.push(new Shading(options2.shading));
    }
    if (options2.revision) {
      this.push(new RunPropertiesChange(options2.revision));
    }
    if (options2.border) {
      this.push(new BorderElement("w:bdr", options2.border));
    }
    if (options2.snapToGrid !== undefined) {
      this.push(new OnOffElement("w:snapToGrid", options2.snapToGrid));
    }
    if (options2.vanish) {
      this.push(new OnOffElement("w:vanish", options2.vanish));
    }
    if (options2.specVanish) {
      this.push(new OnOffElement("w:specVanish", options2.vanish));
    }
    if (options2.scale !== undefined) {
      this.push(new NumberValueElement("w:w", options2.scale));
    }
    if (options2.language) {
      this.push(createLanguageComponent(options2.language));
    }
    if (options2.math) {
      this.push(new OnOffElement("w:oMath", options2.math));
    }
  }
  push(item) {
    this.root.push(item);
  }
}

class RunPropertiesChange extends XmlComponent {
  constructor(options2) {
    super("w:rPrChange");
    this.root.push(new ChangeAttributes({
      id: options2.id,
      author: options2.author,
      date: options2.date
    }));
    this.addChildElement(new RunProperties(options2));
  }
}

class Text extends XmlComponent {
  constructor(options2) {
    var _a;
    super("w:t");
    if (typeof options2 === "string") {
      this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));
      this.root.push(options2);
    } else {
      this.root.push(new TextAttributes({ space: (_a = options2.space) != null ? _a : SpaceType.DEFAULT }));
      this.root.push(options2.text);
    }
  }
}
var PageNumber = {
  CURRENT: "CURRENT",
  TOTAL_PAGES: "TOTAL_PAGES",
  TOTAL_PAGES_IN_SECTION: "TOTAL_PAGES_IN_SECTION",
  CURRENT_SECTION: "SECTION"
};

class Run extends XmlComponent {
  constructor(options2) {
    super("w:r");
    __publicField(this, "properties");
    this.properties = new RunProperties(options2);
    this.root.push(this.properties);
    if (options2.break) {
      for (let i = 0;i < options2.break; i++) {
        this.root.push(new Break$1);
      }
    }
    if (options2.children) {
      for (const child of options2.children) {
        if (typeof child === "string") {
          switch (child) {
            case PageNumber.CURRENT:
              this.root.push(new Begin);
              this.root.push(new Page);
              this.root.push(new Separate);
              this.root.push(new End);
              break;
            case PageNumber.TOTAL_PAGES:
              this.root.push(new Begin);
              this.root.push(new NumberOfPages);
              this.root.push(new Separate);
              this.root.push(new End);
              break;
            case PageNumber.TOTAL_PAGES_IN_SECTION:
              this.root.push(new Begin);
              this.root.push(new NumberOfPagesSection);
              this.root.push(new Separate);
              this.root.push(new End);
              break;
            case PageNumber.CURRENT_SECTION:
              this.root.push(new Begin);
              this.root.push(new CurrentSection);
              this.root.push(new Separate);
              this.root.push(new End);
              break;
            default:
              this.root.push(new Text(child));
              break;
          }
          continue;
        }
        this.root.push(child);
      }
    } else if (options2.text) {
      this.root.push(new Text(options2.text));
    }
  }
}

class TextRun extends Run {
  constructor(options2) {
    if (typeof options2 === "string") {
      super({});
      this.root.push(new Text(options2));
      return this;
    }
    super(options2);
  }
}

class SymbolAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      char: "w:char",
      symbolfont: "w:font"
    });
  }
}
var Symbol$1 = class Symbol2 extends XmlComponent {
  constructor(char = "", symbolfont = "Wingdings") {
    super("w:sym");
    this.root.push(new SymbolAttributes({ char, symbolfont }));
  }
};

class SymbolRun extends Run {
  constructor(options2) {
    if (typeof options2 === "string") {
      super({});
      this.root.push(new Symbol$1(options2));
      return this;
    }
    super(options2);
    this.root.push(new Symbol$1(options2.char, options2.symbolfont));
  }
}
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
var nanoid = (size = 21) => {
  let id = "";
  let i = size;
  while (i--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var convertInchesToTwip = (inches) => Math.floor(inches * 72 * 20);
var uniqueNumericIdCreator = (initial = 0) => {
  let currentCount = initial;
  return () => ++currentCount;
};
var abstractNumUniqueNumericIdGen = () => uniqueNumericIdCreator();
var concreteNumUniqueNumericIdGen = () => uniqueNumericIdCreator(1);
var docPropertiesUniqueNumericIdGen = () => uniqueNumericIdCreator();
var bookmarkUniqueNumericIdGen = () => uniqueNumericIdCreator();
var uniqueId = () => nanoid().toLowerCase();
var generateUuidPart = (count) => customAlphabet("1234567890abcdef", count)();
var uniqueUuid = () => `${generateUuidPart(8)}-${generateUuidPart(4)}-${generateUuidPart(4)}-${generateUuidPart(4)}-${generateUuidPart(12)}`;
var HorizontalPositionRelativeFrom = {
  CHARACTER: "character",
  COLUMN: "column",
  INSIDE_MARGIN: "insideMargin",
  LEFT_MARGIN: "leftMargin",
  MARGIN: "margin",
  OUTSIDE_MARGIN: "outsideMargin",
  PAGE: "page",
  RIGHT_MARGIN: "rightMargin"
};
var VerticalPositionRelativeFrom = {
  BOTTOM_MARGIN: "bottomMargin",
  INSIDE_MARGIN: "insideMargin",
  LINE: "line",
  MARGIN: "margin",
  OUTSIDE_MARGIN: "outsideMargin",
  PAGE: "page",
  PARAGRAPH: "paragraph",
  TOP_MARGIN: "topMargin"
};

class SimplePosAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      x: "x",
      y: "y"
    });
  }
}

class SimplePos extends XmlComponent {
  constructor() {
    super("wp:simplePos");
    this.root.push(new SimplePosAttributes({
      x: 0,
      y: 0
    }));
  }
}

class Align extends XmlComponent {
  constructor(value) {
    super("wp:align");
    this.root.push(value);
  }
}

class PositionOffset extends XmlComponent {
  constructor(offsetValue) {
    super("wp:posOffset");
    this.root.push(offsetValue.toString());
  }
}

class HorizontalPositionAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      relativeFrom: "relativeFrom"
    });
  }
}

class HorizontalPosition extends XmlComponent {
  constructor(horizontalPosition) {
    super("wp:positionH");
    this.root.push(new HorizontalPositionAttributes({
      relativeFrom: horizontalPosition.relative || HorizontalPositionRelativeFrom.PAGE
    }));
    if (horizontalPosition.align) {
      this.root.push(new Align(horizontalPosition.align));
    } else if (horizontalPosition.offset !== undefined) {
      this.root.push(new PositionOffset(horizontalPosition.offset));
    } else {
      throw new Error("There is no configuration provided for floating position (Align or offset)");
    }
  }
}

class VerticalPositionAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      relativeFrom: "relativeFrom"
    });
  }
}

class VerticalPosition extends XmlComponent {
  constructor(verticalPosition) {
    super("wp:positionV");
    this.root.push(new VerticalPositionAttributes({
      relativeFrom: verticalPosition.relative || VerticalPositionRelativeFrom.PAGE
    }));
    if (verticalPosition.align) {
      this.root.push(new Align(verticalPosition.align));
    } else if (verticalPosition.offset !== undefined) {
      this.root.push(new PositionOffset(verticalPosition.offset));
    } else {
      throw new Error("There is no configuration provided for floating position (Align or offset)");
    }
  }
}

class GraphicDataAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      uri: "uri"
    });
  }
}
var createSvgBlip = (mediaData) => new BuilderElement({
  name: "asvg:svgBlip",
  attributes: {
    asvg: {
      key: "xmlns:asvg",
      value: "http://schemas.microsoft.com/office/drawing/2016/SVG/main"
    },
    embed: {
      key: "r:embed",
      value: `rId{${mediaData.fileName}}`
    }
  }
});
var createExtention = (mediaData) => new BuilderElement({
  name: "a:ext",
  attributes: {
    uri: {
      key: "uri",
      value: "{96DAC541-7B7A-43D3-8B79-37D633B846F1}"
    }
  },
  children: [createSvgBlip(mediaData)]
});
var createExtentionList = (mediaData) => new BuilderElement({
  name: "a:extLst",
  children: [createExtention(mediaData)]
});
var createBlip = (mediaData) => new BuilderElement({
  name: "a:blip",
  attributes: {
    embed: {
      key: "r:embed",
      value: `rId{${mediaData.type === "svg" ? mediaData.fallback.fileName : mediaData.fileName}}`
    },
    cstate: {
      key: "cstate",
      value: "none"
    }
  },
  children: mediaData.type === "svg" ? [createExtentionList(mediaData)] : []
});

class SourceRectangle extends XmlComponent {
  constructor() {
    super("a:srcRect");
  }
}

class FillRectangle extends XmlComponent {
  constructor() {
    super("a:fillRect");
  }
}

class Stretch extends XmlComponent {
  constructor() {
    super("a:stretch");
    this.root.push(new FillRectangle);
  }
}

class BlipFill extends XmlComponent {
  constructor(mediaData) {
    super("pic:blipFill");
    this.root.push(createBlip(mediaData));
    this.root.push(new SourceRectangle);
    this.root.push(new Stretch);
  }
}

class PicLocksAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      noChangeAspect: "noChangeAspect",
      noChangeArrowheads: "noChangeArrowheads"
    });
  }
}

class PicLocks extends XmlComponent {
  constructor() {
    super("a:picLocks");
    this.root.push(new PicLocksAttributes({
      noChangeAspect: 1,
      noChangeArrowheads: 1
    }));
  }
}

class ChildNonVisualProperties extends XmlComponent {
  constructor() {
    super("pic:cNvPicPr");
    this.root.push(new PicLocks);
  }
}
var createHyperlinkClick = (linkId, hasXmlNs) => new BuilderElement({
  name: "a:hlinkClick",
  attributes: __spreadProps(__spreadValues({}, hasXmlNs ? {
    xmlns: {
      key: "xmlns:a",
      value: "http://schemas.openxmlformats.org/drawingml/2006/main"
    }
  } : {}), {
    id: {
      key: "r:id",
      value: `rId${linkId}`
    }
  })
});

class NonVisualPropertiesAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "id",
      name: "name",
      descr: "descr"
    });
  }
}

class NonVisualProperties extends XmlComponent {
  constructor() {
    super("pic:cNvPr");
    this.root.push(new NonVisualPropertiesAttributes({
      id: 0,
      name: "",
      descr: ""
    }));
  }
  prepForXml(context) {
    for (let i = context.stack.length - 1;i >= 0; i--) {
      const element2 = context.stack[i];
      if (!(element2 instanceof ConcreteHyperlink)) {
        continue;
      }
      this.root.push(createHyperlinkClick(element2.linkId, false));
      break;
    }
    return super.prepForXml(context);
  }
}

class NonVisualPicProperties extends XmlComponent {
  constructor() {
    super("pic:nvPicPr");
    this.root.push(new NonVisualProperties);
    this.root.push(new ChildNonVisualProperties);
  }
}

class PicAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns:pic"
    });
  }
}

class ExtentsAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      cx: "cx",
      cy: "cy"
    });
  }
}

class Extents extends XmlComponent {
  constructor(x, y) {
    super("a:ext");
    __publicField(this, "attributes");
    this.attributes = new ExtentsAttributes({
      cx: x,
      cy: y
    });
    this.root.push(this.attributes);
  }
}

class OffsetAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      x: "x",
      y: "y"
    });
  }
}

class Offset extends XmlComponent {
  constructor() {
    super("a:off");
    this.root.push(new OffsetAttributes({
      x: 0,
      y: 0
    }));
  }
}

class FormAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      flipVertical: "flipV",
      flipHorizontal: "flipH",
      rotation: "rot"
    });
  }
}

class Form extends XmlComponent {
  constructor(options2) {
    var _a, _b;
    super("a:xfrm");
    __publicField(this, "extents");
    this.root.push(new FormAttributes({
      flipVertical: (_a = options2.flip) == null ? undefined : _a.vertical,
      flipHorizontal: (_b = options2.flip) == null ? undefined : _b.horizontal,
      rotation: options2.rotation
    }));
    this.extents = new Extents(options2.emus.x, options2.emus.y);
    this.root.push(new Offset);
    this.root.push(this.extents);
  }
}
var createNoFill = () => new BuilderElement({ name: "a:noFill" });
var createSchemeColor = (options2) => new BuilderElement({
  name: "a:schemeClr",
  attributes: {
    value: {
      key: "val",
      value: options2.value
    }
  }
});
var createSolidRgbColor = (options2) => new BuilderElement({
  name: "a:srgbClr",
  attributes: {
    value: {
      key: "val",
      value: options2.value
    }
  }
});
var createSolidFill = (options2) => new BuilderElement({
  name: "a:solidFill",
  children: [options2.type === "rgb" ? createSolidRgbColor(options2) : createSchemeColor(options2)]
});
var createOutline = (options2) => new BuilderElement({
  name: "a:ln",
  attributes: {
    width: {
      key: "w",
      value: options2.width
    },
    cap: {
      key: "cap",
      value: options2.cap
    },
    compoundLine: {
      key: "cmpd",
      value: options2.compoundLine
    },
    align: {
      key: "algn",
      value: options2.align
    }
  },
  children: [
    options2.type === "noFill" ? createNoFill() : options2.solidFillType === "rgb" ? createSolidFill({
      type: "rgb",
      value: options2.value
    }) : createSolidFill({
      type: "scheme",
      value: options2.value
    })
  ]
});

class AdjustmentValues extends XmlComponent {
  constructor() {
    super("a:avLst");
  }
}

class PresetGeometryAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      prst: "prst"
    });
  }
}

class PresetGeometry extends XmlComponent {
  constructor() {
    super("a:prstGeom");
    this.root.push(new PresetGeometryAttributes({
      prst: "rect"
    }));
    this.root.push(new AdjustmentValues);
  }
}

class ShapePropertiesAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      bwMode: "bwMode"
    });
  }
}

class ShapeProperties extends XmlComponent {
  constructor({ outline, transform }) {
    super("pic:spPr");
    __publicField(this, "form");
    this.root.push(new ShapePropertiesAttributes({
      bwMode: "auto"
    }));
    this.form = new Form(transform);
    this.root.push(this.form);
    this.root.push(new PresetGeometry);
    if (outline) {
      this.root.push(createNoFill());
      this.root.push(createOutline(outline));
    }
  }
}

class Pic extends XmlComponent {
  constructor({
    mediaData,
    transform,
    outline
  }) {
    super("pic:pic");
    this.root.push(new PicAttributes({
      xmlns: "http://schemas.openxmlformats.org/drawingml/2006/picture"
    }));
    this.root.push(new NonVisualPicProperties);
    this.root.push(new BlipFill(mediaData));
    this.root.push(new ShapeProperties({ transform, outline }));
  }
}

class GraphicData extends XmlComponent {
  constructor({
    mediaData,
    transform,
    outline
  }) {
    super("a:graphicData");
    __publicField(this, "pic");
    this.root.push(new GraphicDataAttributes({
      uri: "http://schemas.openxmlformats.org/drawingml/2006/picture"
    }));
    this.pic = new Pic({ mediaData, transform, outline });
    this.root.push(this.pic);
  }
}

class GraphicAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      a: "xmlns:a"
    });
  }
}

class Graphic extends XmlComponent {
  constructor({
    mediaData,
    transform,
    outline
  }) {
    super("a:graphic");
    __publicField(this, "data");
    this.root.push(new GraphicAttributes({
      a: "http://schemas.openxmlformats.org/drawingml/2006/main"
    }));
    this.data = new GraphicData({ mediaData, transform, outline });
    this.root.push(this.data);
  }
}
var TextWrappingType = {
  NONE: 0,
  SQUARE: 1,
  TIGHT: 2,
  TOP_AND_BOTTOM: 3
};
var TextWrappingSide = {
  BOTH_SIDES: "bothSides",
  LEFT: "left",
  RIGHT: "right",
  LARGEST: "largest"
};

class WrapNone extends XmlComponent {
  constructor() {
    super("wp:wrapNone");
  }
}

class WrapSquareAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      distT: "distT",
      distB: "distB",
      distL: "distL",
      distR: "distR",
      wrapText: "wrapText"
    });
  }
}

class WrapSquare extends XmlComponent {
  constructor(textWrapping, margins = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }) {
    super("wp:wrapSquare");
    this.root.push(new WrapSquareAttributes({
      wrapText: textWrapping.side || TextWrappingSide.BOTH_SIDES,
      distT: margins.top,
      distB: margins.bottom,
      distL: margins.left,
      distR: margins.right
    }));
  }
}

class WrapTightAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      distT: "distT",
      distB: "distB"
    });
  }
}

class WrapTight extends XmlComponent {
  constructor(margins = {
    top: 0,
    bottom: 0
  }) {
    super("wp:wrapTight");
    this.root.push(new WrapTightAttributes({
      distT: margins.top,
      distB: margins.bottom
    }));
  }
}

class WrapTopAndBottomAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      distT: "distT",
      distB: "distB"
    });
  }
}

class WrapTopAndBottom extends XmlComponent {
  constructor(margins = {
    top: 0,
    bottom: 0
  }) {
    super("wp:wrapTopAndBottom");
    this.root.push(new WrapTopAndBottomAttributes({
      distT: margins.top,
      distB: margins.bottom
    }));
  }
}

class DocProperties extends XmlComponent {
  constructor({ name, description, title } = { name: "", description: "", title: "" }) {
    super("wp:docPr");
    __publicField(this, "docPropertiesUniqueNumericId", docPropertiesUniqueNumericIdGen());
    this.root.push(new NextAttributeComponent({
      id: {
        key: "id",
        value: this.docPropertiesUniqueNumericId()
      },
      name: {
        key: "name",
        value: name
      },
      description: {
        key: "descr",
        value: description
      },
      title: {
        key: "title",
        value: title
      }
    }));
  }
  prepForXml(context) {
    for (let i = context.stack.length - 1;i >= 0; i--) {
      const element2 = context.stack[i];
      if (!(element2 instanceof ConcreteHyperlink)) {
        continue;
      }
      this.root.push(createHyperlinkClick(element2.linkId, true));
      break;
    }
    return super.prepForXml(context);
  }
}
var createEffectExtent = ({ top, right, bottom, left }) => new BuilderElement({
  name: "wp:effectExtent",
  attributes: {
    top: {
      key: "t",
      value: top
    },
    right: {
      key: "r",
      value: right
    },
    bottom: {
      key: "b",
      value: bottom
    },
    left: {
      key: "l",
      value: left
    }
  }
});

class ExtentAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      cx: "cx",
      cy: "cy"
    });
  }
}

class Extent extends XmlComponent {
  constructor(x, y) {
    super("wp:extent");
    __publicField(this, "attributes");
    this.attributes = new ExtentAttributes({
      cx: x,
      cy: y
    });
    this.root.push(this.attributes);
  }
}

class GraphicFrameLockAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns:a",
      noChangeAspect: "noChangeAspect"
    });
  }
}

class GraphicFrameLocks extends XmlComponent {
  constructor() {
    super("a:graphicFrameLocks");
    this.root.push(new GraphicFrameLockAttributes({
      xmlns: "http://schemas.openxmlformats.org/drawingml/2006/main",
      noChangeAspect: 1
    }));
  }
}

class GraphicFrameProperties extends XmlComponent {
  constructor() {
    super("wp:cNvGraphicFramePr");
    this.root.push(new GraphicFrameLocks);
  }
}

class AnchorAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      distT: "distT",
      distB: "distB",
      distL: "distL",
      distR: "distR",
      allowOverlap: "allowOverlap",
      behindDoc: "behindDoc",
      layoutInCell: "layoutInCell",
      locked: "locked",
      relativeHeight: "relativeHeight",
      simplePos: "simplePos"
    });
  }
}

class Anchor extends XmlComponent {
  constructor({
    mediaData,
    transform,
    drawingOptions
  }) {
    super("wp:anchor");
    const floating = __spreadValues({
      allowOverlap: true,
      behindDocument: false,
      lockAnchor: false,
      layoutInCell: true,
      verticalPosition: {},
      horizontalPosition: {}
    }, drawingOptions.floating);
    this.root.push(new AnchorAttributes({
      distT: floating.margins ? floating.margins.top || 0 : 0,
      distB: floating.margins ? floating.margins.bottom || 0 : 0,
      distL: floating.margins ? floating.margins.left || 0 : 0,
      distR: floating.margins ? floating.margins.right || 0 : 0,
      simplePos: "0",
      allowOverlap: floating.allowOverlap === true ? "1" : "0",
      behindDoc: floating.behindDocument === true ? "1" : "0",
      locked: floating.lockAnchor === true ? "1" : "0",
      layoutInCell: floating.layoutInCell === true ? "1" : "0",
      relativeHeight: floating.zIndex ? floating.zIndex : transform.emus.y
    }));
    this.root.push(new SimplePos);
    this.root.push(new HorizontalPosition(floating.horizontalPosition));
    this.root.push(new VerticalPosition(floating.verticalPosition));
    this.root.push(new Extent(transform.emus.x, transform.emus.y));
    this.root.push(createEffectExtent({ top: 0, right: 0, bottom: 0, left: 0 }));
    if (drawingOptions.floating !== undefined && drawingOptions.floating.wrap !== undefined) {
      switch (drawingOptions.floating.wrap.type) {
        case TextWrappingType.SQUARE:
          this.root.push(new WrapSquare(drawingOptions.floating.wrap, drawingOptions.floating.margins));
          break;
        case TextWrappingType.TIGHT:
          this.root.push(new WrapTight(drawingOptions.floating.margins));
          break;
        case TextWrappingType.TOP_AND_BOTTOM:
          this.root.push(new WrapTopAndBottom(drawingOptions.floating.margins));
          break;
        case TextWrappingType.NONE:
        default:
          this.root.push(new WrapNone);
      }
    } else {
      this.root.push(new WrapNone);
    }
    this.root.push(new DocProperties(drawingOptions.docProperties));
    this.root.push(new GraphicFrameProperties);
    this.root.push(new Graphic({ mediaData, transform, outline: drawingOptions.outline }));
  }
}
var createInline = ({ mediaData, transform, docProperties, outline }) => {
  var _a, _b, _c, _d;
  return new BuilderElement({
    name: "wp:inline",
    attributes: {
      distanceTop: {
        key: "distT",
        value: 0
      },
      distanceBottom: {
        key: "distB",
        value: 0
      },
      distanceLeft: {
        key: "distL",
        value: 0
      },
      distanceRight: {
        key: "distR",
        value: 0
      }
    },
    children: [
      new Extent(transform.emus.x, transform.emus.y),
      createEffectExtent(outline ? {
        top: ((_a = outline.width) != null ? _a : 9525) * 2,
        right: ((_b = outline.width) != null ? _b : 9525) * 2,
        bottom: ((_c = outline.width) != null ? _c : 9525) * 2,
        left: ((_d = outline.width) != null ? _d : 9525) * 2
      } : { top: 0, right: 0, bottom: 0, left: 0 }),
      new DocProperties(docProperties),
      new GraphicFrameProperties,
      new Graphic({ mediaData, transform, outline })
    ]
  });
};

class Drawing extends XmlComponent {
  constructor(imageData, drawingOptions = {}) {
    super("w:drawing");
    if (!drawingOptions.floating) {
      this.root.push(createInline({
        mediaData: imageData,
        transform: imageData.transformation,
        docProperties: drawingOptions.docProperties,
        outline: drawingOptions.outline
      }));
    } else {
      this.root.push(new Anchor({ mediaData: imageData, transform: imageData.transformation, drawingOptions }));
    }
  }
}
var convertDataURIToBinary = (dataURI) => {
  if (typeof atob === "function") {
    const BASE64_MARKER = ";base64,";
    const base64Index = dataURI.indexOf(BASE64_MARKER);
    const base64IndexWithOffset = base64Index === -1 ? 0 : base64Index + BASE64_MARKER.length;
    return new Uint8Array(atob(dataURI.substring(base64IndexWithOffset)).split("").map((c) => c.charCodeAt(0)));
  } else {
    const b = __require("buffer");
    return new b.Buffer(dataURI, "base64");
  }
};
var standardizeData = (data) => typeof data === "string" ? convertDataURIToBinary(data) : data;
var createImageData = (options2, key) => ({
  data: standardizeData(options2.data),
  fileName: key,
  transformation: {
    pixels: {
      x: Math.round(options2.transformation.width),
      y: Math.round(options2.transformation.height)
    },
    emus: {
      x: Math.round(options2.transformation.width * 9525),
      y: Math.round(options2.transformation.height * 9525)
    },
    flip: options2.transformation.flip,
    rotation: options2.transformation.rotation ? options2.transformation.rotation * 60000 : undefined
  }
});

class ImageRun extends Run {
  constructor(options2) {
    super({});
    __publicField(this, "key");
    __publicField(this, "fallbackKey", `${uniqueId()}.png`);
    __publicField(this, "imageData");
    this.key = `${uniqueId()}.${options2.type}`;
    this.imageData = options2.type === "svg" ? __spreadProps(__spreadValues({
      type: options2.type
    }, createImageData(options2, this.key)), {
      fallback: __spreadValues({
        type: options2.fallback.type
      }, createImageData(__spreadProps(__spreadValues({}, options2.fallback), {
        transformation: options2.transformation
      }), this.fallbackKey))
    }) : __spreadValues({
      type: options2.type
    }, createImageData(options2, this.key));
    const drawing = new Drawing(this.imageData, {
      floating: options2.floating,
      docProperties: options2.altText,
      outline: options2.outline
    });
    this.root.push(drawing);
  }
  prepForXml(context) {
    context.file.Media.addImage(this.key, this.imageData);
    if (this.imageData.type === "svg") {
      context.file.Media.addImage(this.fallbackKey, this.imageData.fallback);
    }
    return super.prepForXml(context);
  }
}
class CommentAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { id: "w:id", initials: "w:initials", author: "w:author", date: "w:date" });
  }
}
class RootCommentsAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      "xmlns:cx": "xmlns:cx",
      "xmlns:cx1": "xmlns:cx1",
      "xmlns:cx2": "xmlns:cx2",
      "xmlns:cx3": "xmlns:cx3",
      "xmlns:cx4": "xmlns:cx4",
      "xmlns:cx5": "xmlns:cx5",
      "xmlns:cx6": "xmlns:cx6",
      "xmlns:cx7": "xmlns:cx7",
      "xmlns:cx8": "xmlns:cx8",
      "xmlns:mc": "xmlns:mc",
      "xmlns:aink": "xmlns:aink",
      "xmlns:am3d": "xmlns:am3d",
      "xmlns:o": "xmlns:o",
      "xmlns:r": "xmlns:r",
      "xmlns:m": "xmlns:m",
      "xmlns:v": "xmlns:v",
      "xmlns:wp14": "xmlns:wp14",
      "xmlns:wp": "xmlns:wp",
      "xmlns:w10": "xmlns:w10",
      "xmlns:w": "xmlns:w",
      "xmlns:w14": "xmlns:w14",
      "xmlns:w15": "xmlns:w15",
      "xmlns:w16cex": "xmlns:w16cex",
      "xmlns:w16cid": "xmlns:w16cid",
      "xmlns:w16": "xmlns:w16",
      "xmlns:w16sdtdh": "xmlns:w16sdtdh",
      "xmlns:w16se": "xmlns:w16se",
      "xmlns:wpg": "xmlns:wpg",
      "xmlns:wpi": "xmlns:wpi",
      "xmlns:wne": "xmlns:wne",
      "xmlns:wps": "xmlns:wps"
    });
  }
}
class Comment extends XmlComponent {
  constructor({ id, initials, author, date = /* @__PURE__ */ new Date, children }) {
    super("w:comment");
    this.root.push(new CommentAttributes({
      id,
      initials,
      author,
      date: date.toISOString()
    }));
    for (const child of children) {
      this.root.push(child);
    }
  }
}

class Comments extends XmlComponent {
  constructor({ children }) {
    super("w:comments");
    this.root.push(new RootCommentsAttributes({
      "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
      "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
      "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
      "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
      "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
      "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
      "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
      "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
      "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
      "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
      "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
      "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
      "xmlns:o": "urn:schemas-microsoft-com:office:office",
      "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
      "xmlns:v": "urn:schemas-microsoft-com:vml",
      "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
      "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
      "xmlns:w10": "urn:schemas-microsoft-com:office:word",
      "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
      "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
      "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
      "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
      "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
      "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
      "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
      "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
      "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
      "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
      "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
      "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
    }));
    for (const child of children) {
      this.root.push(new Comment(child));
    }
  }
}
class PageBreakBefore extends XmlComponent {
  constructor() {
    super("w:pageBreakBefore");
  }
}
var LineRuleType = {
  AT_LEAST: "atLeast",
  EXACTLY: "exactly",
  EXACT: "exact",
  AUTO: "auto"
};

class SpacingAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      after: "w:after",
      before: "w:before",
      line: "w:line",
      lineRule: "w:lineRule"
    });
  }
}

class Spacing extends XmlComponent {
  constructor(options2) {
    super("w:spacing");
    this.root.push(new SpacingAttributes(options2));
  }
}
var HeadingLevel = {
  HEADING_1: "Heading1",
  HEADING_2: "Heading2",
  HEADING_3: "Heading3",
  HEADING_4: "Heading4",
  HEADING_5: "Heading5",
  HEADING_6: "Heading6",
  TITLE: "Title"
};
var Style$1 = class Style extends XmlComponent {
  constructor(styleId) {
    super("w:pStyle");
    this.root.push(new Attributes({
      val: styleId
    }));
  }
};

class TabStop extends XmlComponent {
  constructor(tabDefinitions) {
    super("w:tabs");
    for (const tabDefinition of tabDefinitions) {
      this.root.push(new TabStopItem(tabDefinition));
    }
  }
}
var TabStopType = {
  LEFT: "left",
  RIGHT: "right",
  CENTER: "center",
  BAR: "bar",
  CLEAR: "clear",
  DECIMAL: "decimal",
  END: "end",
  NUM: "num",
  START: "start"
};
class TabAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val", pos: "w:pos", leader: "w:leader" });
  }
}

class TabStopItem extends XmlComponent {
  constructor({ type, position: position2, leader }) {
    super("w:tab");
    this.root.push(new TabAttributes({
      val: type,
      pos: position2,
      leader
    }));
  }
}

class NumberProperties extends XmlComponent {
  constructor(numberId, indentLevel) {
    super("w:numPr");
    this.root.push(new IndentLevel(indentLevel));
    this.root.push(new NumberId(numberId));
  }
}

class IndentLevel extends XmlComponent {
  constructor(level) {
    super("w:ilvl");
    if (level > 9) {
      throw new Error("Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7");
    }
    this.root.push(new Attributes({
      val: level
    }));
  }
}

class NumberId extends XmlComponent {
  constructor(id) {
    super("w:numId");
    this.root.push(new Attributes({
      val: typeof id === "string" ? `{${id}}` : id
    }));
  }
}

class FileChild extends XmlComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "fileChild", Symbol());
  }
}

class RelationshipAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "Id",
      type: "Type",
      target: "Target",
      targetMode: "TargetMode"
    });
  }
}
var TargetModeType = {
  EXTERNAL: "External"
};

class Relationship extends XmlComponent {
  constructor(id, type, target, targetMode) {
    super("Relationship");
    this.root.push(new RelationshipAttributes({
      id,
      type,
      target,
      targetMode
    }));
  }
}

class HyperlinkAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "r:id",
      history: "w:history",
      anchor: "w:anchor"
    });
  }
}
class ConcreteHyperlink extends XmlComponent {
  constructor(children, relationshipId, anchor) {
    super("w:hyperlink");
    __publicField(this, "linkId");
    this.linkId = relationshipId;
    const props = {
      history: 1,
      anchor: anchor ? anchor : undefined,
      id: !anchor ? `rId${this.linkId}` : undefined
    };
    const attributes = new HyperlinkAttributes(props);
    this.root.push(attributes);
    children.forEach((child) => {
      this.root.push(child);
    });
  }
}
class ExternalHyperlink extends XmlComponent {
  constructor(options2) {
    super("w:externalHyperlink");
    this.options = options2;
  }
}

class BookmarkStartAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "w:id",
      name: "w:name"
    });
  }
}

class BookmarkEndAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "w:id"
    });
  }
}

class Bookmark {
  constructor(options2) {
    __publicField(this, "bookmarkUniqueNumericId", bookmarkUniqueNumericIdGen());
    __publicField(this, "start");
    __publicField(this, "children");
    __publicField(this, "end");
    const linkId = this.bookmarkUniqueNumericId();
    this.start = new BookmarkStart(options2.id, linkId);
    this.children = options2.children;
    this.end = new BookmarkEnd(linkId);
  }
}

class BookmarkStart extends XmlComponent {
  constructor(id, linkId) {
    super("w:bookmarkStart");
    const attributes = new BookmarkStartAttributes({
      name: id,
      id: linkId
    });
    this.root.push(attributes);
  }
}

class BookmarkEnd extends XmlComponent {
  constructor(linkId) {
    super("w:bookmarkEnd");
    const attributes = new BookmarkEndAttributes({
      id: linkId
    });
    this.root.push(attributes);
  }
}

class OutlineLevel extends XmlComponent {
  constructor(level) {
    super("w:outlineLvl");
    this.level = level;
    this.root.push(new Attributes({
      val: level
    }));
  }
}
class VerticalAlignAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      verticalAlign: "w:val"
    });
  }
}

class VerticalAlignElement extends XmlComponent {
  constructor(value) {
    super("w:vAlign");
    this.root.push(new VerticalAlignAttributes({ verticalAlign: value }));
  }
}
var HeaderFooterReferenceType = {
  DEFAULT: "default",
  FIRST: "first",
  EVEN: "even"
};

class FooterReferenceAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      type: "w:type",
      id: "r:id"
    });
  }
}
var HeaderFooterType = {
  HEADER: "w:headerReference",
  FOOTER: "w:footerReference"
};

class HeaderFooterReference extends XmlComponent {
  constructor(type, options2) {
    super(type);
    this.root.push(new FooterReferenceAttributes({
      type: options2.type || HeaderFooterReferenceType.DEFAULT,
      id: `rId${options2.id}`
    }));
  }
}

class Columns extends XmlComponent {
  constructor({ space, count, separate, equalWidth, children }) {
    super("w:cols");
    this.root.push(new NextAttributeComponent({
      space: { key: "w:space", value: space === undefined ? undefined : twipsMeasureValue(space) },
      count: { key: "w:num", value: count === undefined ? undefined : decimalNumber(count) },
      separate: { key: "w:sep", value: separate },
      equalWidth: { key: "w:equalWidth", value: equalWidth }
    }));
    if (!equalWidth && children) {
      children.forEach((column) => this.addChildElement(column));
    }
  }
}
class DocGridAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      type: "w:type",
      linePitch: "w:linePitch",
      charSpace: "w:charSpace"
    });
  }
}

class DocumentGrid extends XmlComponent {
  constructor(linePitch, charSpace, type) {
    super("w:docGrid");
    this.root.push(new DocGridAttributes({
      type,
      linePitch: decimalNumber(linePitch),
      charSpace: charSpace ? decimalNumber(charSpace) : undefined
    }));
  }
}
var createLineNumberType = ({ countBy, start, restart, distance }) => new BuilderElement({
  name: "w:lnNumType",
  attributes: {
    countBy: { key: "w:countBy", value: countBy === undefined ? undefined : decimalNumber(countBy) },
    start: { key: "w:start", value: start === undefined ? undefined : decimalNumber(start) },
    restart: { key: "w:restart", value: restart },
    distance: {
      key: "w:distance",
      value: distance === undefined ? undefined : twipsMeasureValue(distance)
    }
  }
});
class PageBordersAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      display: "w:display",
      offsetFrom: "w:offsetFrom",
      zOrder: "w:zOrder"
    });
  }
}

class PageBorders extends IgnoreIfEmptyXmlComponent {
  constructor(options2) {
    super("w:pgBorders");
    if (!options2) {
      return this;
    }
    if (options2.pageBorders) {
      this.root.push(new PageBordersAttributes({
        display: options2.pageBorders.display,
        offsetFrom: options2.pageBorders.offsetFrom,
        zOrder: options2.pageBorders.zOrder
      }));
    } else {
      this.root.push(new PageBordersAttributes({}));
    }
    if (options2.pageBorderTop) {
      this.root.push(new BorderElement("w:top", options2.pageBorderTop));
    }
    if (options2.pageBorderLeft) {
      this.root.push(new BorderElement("w:left", options2.pageBorderLeft));
    }
    if (options2.pageBorderBottom) {
      this.root.push(new BorderElement("w:bottom", options2.pageBorderBottom));
    }
    if (options2.pageBorderRight) {
      this.root.push(new BorderElement("w:right", options2.pageBorderRight));
    }
  }
}

class PageMargin extends XmlComponent {
  constructor(top, right, bottom, left, header, footer, gutter) {
    super("w:pgMar");
    this.root.push(new NextAttributeComponent({
      top: { key: "w:top", value: signedTwipsMeasureValue(top) },
      right: { key: "w:right", value: twipsMeasureValue(right) },
      bottom: { key: "w:bottom", value: signedTwipsMeasureValue(bottom) },
      left: { key: "w:left", value: twipsMeasureValue(left) },
      header: { key: "w:header", value: twipsMeasureValue(header) },
      footer: { key: "w:footer", value: twipsMeasureValue(footer) },
      gutter: { key: "w:gutter", value: twipsMeasureValue(gutter) }
    }));
  }
}
class PageNumberTypeAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      start: "w:start",
      formatType: "w:fmt",
      separator: "w:chapSep"
    });
  }
}

class PageNumberType extends XmlComponent {
  constructor({ start, formatType, separator }) {
    super("w:pgNumType");
    this.root.push(new PageNumberTypeAttributes({
      start: start === undefined ? undefined : decimalNumber(start),
      formatType,
      separator
    }));
  }
}
var PageOrientation = {
  PORTRAIT: "portrait",
  LANDSCAPE: "landscape"
};

class PageSize extends XmlComponent {
  constructor(width, height, orientation) {
    super("w:pgSz");
    const flip = orientation === PageOrientation.LANDSCAPE;
    const widthTwips = twipsMeasureValue(width);
    const heightTwips = twipsMeasureValue(height);
    this.root.push(new NextAttributeComponent({
      width: { key: "w:w", value: flip ? heightTwips : widthTwips },
      height: { key: "w:h", value: flip ? widthTwips : heightTwips },
      orientation: { key: "w:orient", value: orientation }
    }));
  }
}
class PageTextDirectionAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
}

class PageTextDirection extends XmlComponent {
  constructor(value) {
    super("w:textDirection");
    this.root.push(new PageTextDirectionAttributes({
      val: value
    }));
  }
}
class SectionTypeAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      val: "w:val"
    });
  }
}

class Type extends XmlComponent {
  constructor(value) {
    super("w:type");
    this.root.push(new SectionTypeAttributes({ val: value }));
  }
}
var sectionMarginDefaults = {
  TOP: 1440,
  RIGHT: 1440,
  BOTTOM: 1440,
  LEFT: 1440,
  HEADER: 708,
  FOOTER: 708,
  GUTTER: 0
};
var sectionPageSizeDefaults = {
  WIDTH: 11906,
  HEIGHT: 16838,
  ORIENTATION: PageOrientation.PORTRAIT
};

class SectionProperties extends XmlComponent {
  constructor({
    page: {
      size: {
        width = sectionPageSizeDefaults.WIDTH,
        height = sectionPageSizeDefaults.HEIGHT,
        orientation = sectionPageSizeDefaults.ORIENTATION
      } = {},
      margin: {
        top = sectionMarginDefaults.TOP,
        right = sectionMarginDefaults.RIGHT,
        bottom = sectionMarginDefaults.BOTTOM,
        left = sectionMarginDefaults.LEFT,
        header = sectionMarginDefaults.HEADER,
        footer = sectionMarginDefaults.FOOTER,
        gutter = sectionMarginDefaults.GUTTER
      } = {},
      pageNumbers = {},
      borders,
      textDirection
    } = {},
    grid: { linePitch = 360, charSpace, type: gridType } = {},
    headerWrapperGroup = {},
    footerWrapperGroup = {},
    lineNumbers,
    titlePage,
    verticalAlign,
    column,
    type
  } = {}) {
    super("w:sectPr");
    this.addHeaderFooterGroup(HeaderFooterType.HEADER, headerWrapperGroup);
    this.addHeaderFooterGroup(HeaderFooterType.FOOTER, footerWrapperGroup);
    if (type) {
      this.root.push(new Type(type));
    }
    this.root.push(new PageSize(width, height, orientation));
    this.root.push(new PageMargin(top, right, bottom, left, header, footer, gutter));
    if (borders) {
      this.root.push(new PageBorders(borders));
    }
    if (lineNumbers) {
      this.root.push(createLineNumberType(lineNumbers));
    }
    this.root.push(new PageNumberType(pageNumbers));
    if (column) {
      this.root.push(new Columns(column));
    }
    if (verticalAlign) {
      this.root.push(new VerticalAlignElement(verticalAlign));
    }
    if (titlePage !== undefined) {
      this.root.push(new OnOffElement("w:titlePg", titlePage));
    }
    if (textDirection) {
      this.root.push(new PageTextDirection(textDirection));
    }
    this.root.push(new DocumentGrid(linePitch, charSpace, gridType));
  }
  addHeaderFooterGroup(type, group) {
    if (group.default) {
      this.root.push(new HeaderFooterReference(type, {
        type: HeaderFooterReferenceType.DEFAULT,
        id: group.default.View.ReferenceId
      }));
    }
    if (group.first) {
      this.root.push(new HeaderFooterReference(type, {
        type: HeaderFooterReferenceType.FIRST,
        id: group.first.View.ReferenceId
      }));
    }
    if (group.even) {
      this.root.push(new HeaderFooterReference(type, {
        type: HeaderFooterReferenceType.EVEN,
        id: group.even.View.ReferenceId
      }));
    }
  }
}

class Body extends XmlComponent {
  constructor() {
    super("w:body");
    __publicField(this, "sections", []);
  }
  addSection(options2) {
    const currentSection = this.sections.pop();
    this.root.push(this.createSectionParagraph(currentSection));
    this.sections.push(new SectionProperties(options2));
  }
  prepForXml(context) {
    if (this.sections.length === 1) {
      this.root.splice(0, 1);
      this.root.push(this.sections.pop());
    }
    return super.prepForXml(context);
  }
  push(component) {
    this.root.push(component);
  }
  createSectionParagraph(section) {
    const paragraph2 = new Paragraph({});
    const properties = new ParagraphProperties({});
    properties.push(section);
    paragraph2.addChildElement(properties);
    return paragraph2;
  }
}
class DocumentAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type",
      cx: "xmlns:cx",
      cx1: "xmlns:cx1",
      cx2: "xmlns:cx2",
      cx3: "xmlns:cx3",
      cx4: "xmlns:cx4",
      cx5: "xmlns:cx5",
      cx6: "xmlns:cx6",
      cx7: "xmlns:cx7",
      cx8: "xmlns:cx8",
      aink: "xmlns:aink",
      am3d: "xmlns:am3d",
      w16cex: "xmlns:w16cex",
      w16cid: "xmlns:w16cid",
      w16: "xmlns:w16",
      w16sdtdh: "xmlns:w16sdtdh",
      w16se: "xmlns:w16se"
    });
  }
}

class DocumentBackgroundAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      color: "w:color",
      themeColor: "w:themeColor",
      themeShade: "w:themeShade",
      themeTint: "w:themeTint"
    });
  }
}

class DocumentBackground extends XmlComponent {
  constructor(options2) {
    super("w:background");
    this.root.push(new DocumentBackgroundAttributes({
      color: options2.color === undefined ? undefined : hexColorValue(options2.color),
      themeColor: options2.themeColor,
      themeShade: options2.themeShade === undefined ? undefined : uCharHexNumber(options2.themeShade),
      themeTint: options2.themeTint === undefined ? undefined : uCharHexNumber(options2.themeTint)
    }));
  }
}

class Document extends XmlComponent {
  constructor(options2) {
    super("w:document");
    __publicField(this, "body");
    this.root.push(new DocumentAttributes({
      wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
      mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
      o: "urn:schemas-microsoft-com:office:office",
      r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
      v: "urn:schemas-microsoft-com:vml",
      wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
      wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
      w10: "urn:schemas-microsoft-com:office:word",
      w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
      w14: "http://schemas.microsoft.com/office/word/2010/wordml",
      w15: "http://schemas.microsoft.com/office/word/2012/wordml",
      wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
      wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
      wne: "http://schemas.microsoft.com/office/word/2006/wordml",
      wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
      cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
      cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
      cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
      cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
      cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
      cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
      cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
      cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
      cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
      aink: "http://schemas.microsoft.com/office/drawing/2016/ink",
      am3d: "http://schemas.microsoft.com/office/drawing/2017/model3d",
      w16cex: "http://schemas.microsoft.com/office/word/2018/wordml/cex",
      w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
      w16: "http://schemas.microsoft.com/office/word/2018/wordml",
      w16sdtdh: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
      w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex",
      Ignorable: "w14 w15 wp14"
    }));
    this.body = new Body;
    if (options2.background) {
      this.root.push(new DocumentBackground(options2.background));
    }
    this.root.push(this.body);
  }
  add(item) {
    this.body.push(item);
    return this;
  }
  get Body() {
    return this.body;
  }
}

class RelationshipsAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns"
    });
  }
}

class Relationships extends XmlComponent {
  constructor() {
    super("Relationships");
    this.root.push(new RelationshipsAttributes({
      xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
    }));
  }
  createRelationship(id, type, target, targetMode) {
    const relationship = new Relationship(`rId${id}`, type, target, targetMode);
    this.root.push(relationship);
    return relationship;
  }
  get RelationshipCount() {
    return this.root.length - 1;
  }
}

class DocumentWrapper {
  constructor(options2) {
    __publicField(this, "document");
    __publicField(this, "relationships");
    this.document = new Document(options2);
    this.relationships = new Relationships;
  }
  get View() {
    return this.document;
  }
  get Relationships() {
    return this.relationships;
  }
}

class WordWrapAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
}

class WordWrap extends XmlComponent {
  constructor() {
    super("w:wordWrap");
    this.root.push(new WordWrapAttributes({ val: 0 }));
  }
}
var createFrameProperties = (options2) => {
  var _a, _b;
  return new BuilderElement({
    name: "w:framePr",
    attributes: {
      anchorLock: {
        key: "w:anchorLock",
        value: options2.anchorLock
      },
      dropCap: {
        key: "w:dropCap",
        value: options2.dropCap
      },
      width: {
        key: "w:w",
        value: options2.width
      },
      height: {
        key: "w:h",
        value: options2.height
      },
      x: {
        key: "w:x",
        value: options2.position ? options2.position.x : undefined
      },
      y: {
        key: "w:y",
        value: options2.position ? options2.position.y : undefined
      },
      anchorHorizontal: {
        key: "w:hAnchor",
        value: options2.anchor.horizontal
      },
      anchorVertical: {
        key: "w:vAnchor",
        value: options2.anchor.vertical
      },
      spaceHorizontal: {
        key: "w:hSpace",
        value: (_a = options2.space) == null ? undefined : _a.horizontal
      },
      spaceVertical: {
        key: "w:vSpace",
        value: (_b = options2.space) == null ? undefined : _b.vertical
      },
      rule: {
        key: "w:hRule",
        value: options2.rule
      },
      alignmentX: {
        key: "w:xAlign",
        value: options2.alignment ? options2.alignment.x : undefined
      },
      alignmentY: {
        key: "w:yAlign",
        value: options2.alignment ? options2.alignment.y : undefined
      },
      lines: {
        key: "w:lines",
        value: options2.lines
      },
      wrap: {
        key: "w:wrap",
        value: options2.wrap
      }
    }
  });
};

class ParagraphProperties extends IgnoreIfEmptyXmlComponent {
  constructor(options2) {
    var _a, _b;
    super("w:pPr");
    __publicField(this, "numberingReferences", []);
    if (!options2) {
      return this;
    }
    if (options2.heading) {
      this.push(new Style$1(options2.heading));
    }
    if (options2.bullet) {
      this.push(new Style$1("ListParagraph"));
    }
    if (options2.numbering) {
      if (!options2.style && !options2.heading) {
        if (!options2.numbering.custom) {
          this.push(new Style$1("ListParagraph"));
        }
      }
    }
    if (options2.style) {
      this.push(new Style$1(options2.style));
    }
    if (options2.keepNext !== undefined) {
      this.push(new OnOffElement("w:keepNext", options2.keepNext));
    }
    if (options2.keepLines !== undefined) {
      this.push(new OnOffElement("w:keepLines", options2.keepLines));
    }
    if (options2.pageBreakBefore) {
      this.push(new PageBreakBefore);
    }
    if (options2.frame) {
      this.push(createFrameProperties(options2.frame));
    }
    if (options2.widowControl !== undefined) {
      this.push(new OnOffElement("w:widowControl", options2.widowControl));
    }
    if (options2.bullet) {
      this.push(new NumberProperties(1, options2.bullet.level));
    }
    if (options2.numbering) {
      this.numberingReferences.push({
        reference: options2.numbering.reference,
        instance: (_a = options2.numbering.instance) != null ? _a : 0
      });
      this.push(new NumberProperties(`${options2.numbering.reference}-${(_b = options2.numbering.instance) != null ? _b : 0}`, options2.numbering.level));
    } else if (options2.numbering === false) {
      this.push(new NumberProperties(0, 0));
    }
    if (options2.border) {
      this.push(new Border(options2.border));
    }
    if (options2.thematicBreak) {
      this.push(new ThematicBreak);
    }
    if (options2.shading) {
      this.push(new Shading(options2.shading));
    }
    if (options2.wordWrap) {
      this.push(new WordWrap);
    }
    if (options2.overflowPunctuation) {
      this.push(new OnOffElement("w:overflowPunct", options2.overflowPunctuation));
    }
    const tabDefinitions = [
      ...options2.rightTabStop !== undefined ? [{ type: TabStopType.RIGHT, position: options2.rightTabStop }] : [],
      ...options2.tabStops ? options2.tabStops : [],
      ...options2.leftTabStop !== undefined ? [{ type: TabStopType.LEFT, position: options2.leftTabStop }] : []
    ];
    if (tabDefinitions.length > 0) {
      this.push(new TabStop(tabDefinitions));
    }
    if (options2.bidirectional !== undefined) {
      this.push(new OnOffElement("w:bidi", options2.bidirectional));
    }
    if (options2.spacing) {
      this.push(new Spacing(options2.spacing));
    }
    if (options2.indent) {
      this.push(new Indent(options2.indent));
    }
    if (options2.contextualSpacing !== undefined) {
      this.push(new OnOffElement("w:contextualSpacing", options2.contextualSpacing));
    }
    if (options2.alignment) {
      this.push(new Alignment(options2.alignment));
    }
    if (options2.outlineLevel !== undefined) {
      this.push(new OutlineLevel(options2.outlineLevel));
    }
    if (options2.suppressLineNumbers !== undefined) {
      this.push(new OnOffElement("w:suppressLineNumbers", options2.suppressLineNumbers));
    }
    if (options2.autoSpaceEastAsianText !== undefined) {
      this.push(new OnOffElement("w:autoSpaceDN", options2.autoSpaceEastAsianText));
    }
    if (options2.run) {
      this.push(new RunProperties(options2.run));
    }
  }
  push(item) {
    this.root.push(item);
  }
  prepForXml(context) {
    if (context.viewWrapper instanceof DocumentWrapper) {
      for (const reference of this.numberingReferences) {
        context.file.Numbering.createConcreteNumberingInstance(reference.reference, reference.instance);
      }
    }
    return super.prepForXml(context);
  }
}

class Paragraph extends FileChild {
  constructor(options2) {
    super("w:p");
    __publicField(this, "properties");
    if (typeof options2 === "string") {
      this.properties = new ParagraphProperties({});
      this.root.push(this.properties);
      this.root.push(new TextRun(options2));
      return this;
    }
    this.properties = new ParagraphProperties(options2);
    this.root.push(this.properties);
    if (options2.text) {
      this.root.push(new TextRun(options2.text));
    }
    if (options2.children) {
      for (const child of options2.children) {
        if (child instanceof Bookmark) {
          this.root.push(child.start);
          for (const textRun of child.children) {
            this.root.push(textRun);
          }
          this.root.push(child.end);
          continue;
        }
        this.root.push(child);
      }
    }
  }
  prepForXml(context) {
    for (const element2 of this.root) {
      if (element2 instanceof ExternalHyperlink) {
        const index2 = this.root.indexOf(element2);
        const concreteHyperlink = new ConcreteHyperlink(element2.options.children, uniqueId());
        context.viewWrapper.Relationships.createRelationship(concreteHyperlink.linkId, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", element2.options.link, TargetModeType.EXTERNAL);
        this.root[index2] = concreteHyperlink;
      }
    }
    return super.prepForXml(context);
  }
  addRunToFront(run) {
    this.root.splice(1, 0, run);
    return this;
  }
}
var Math$1 = class Math2 extends XmlComponent {
  constructor(options2) {
    super("m:oMath");
    for (const child of options2.children) {
      this.root.push(child);
    }
  }
};

class MathText extends XmlComponent {
  constructor(text5) {
    super("m:t");
    this.root.push(text5);
  }
}

class MathRun extends XmlComponent {
  constructor(text5) {
    super("m:r");
    this.root.push(new MathText(text5));
  }
}

class MathDenominator extends XmlComponent {
  constructor(children) {
    super("m:den");
    for (const child of children) {
      this.root.push(child);
    }
  }
}

class MathNumerator extends XmlComponent {
  constructor(children) {
    super("m:num");
    for (const child of children) {
      this.root.push(child);
    }
  }
}

class MathFraction extends XmlComponent {
  constructor(options2) {
    super("m:f");
    this.root.push(new MathNumerator(options2.numerator));
    this.root.push(new MathDenominator(options2.denominator));
  }
}

class MathAccentCharacterAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { accent: "m:val" });
  }
}

class MathAccentCharacter extends XmlComponent {
  constructor(accent) {
    super("m:chr");
    this.root.push(new MathAccentCharacterAttributes({ accent }));
  }
}

class MathBase extends XmlComponent {
  constructor(children) {
    super("m:e");
    for (const child of children) {
      this.root.push(child);
    }
  }
}

class MathLimitLocationAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { value: "m:val" });
  }
}

class MathLimitLocation extends XmlComponent {
  constructor(value) {
    super("m:limLoc");
    this.root.push(new MathLimitLocationAttributes({ value: value || "undOvr" }));
  }
}

class MathSubScriptHideAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { hide: "m:val" });
  }
}

class MathSubScriptHide extends XmlComponent {
  constructor() {
    super("m:subHide");
    this.root.push(new MathSubScriptHideAttributes({ hide: 1 }));
  }
}

class MathSuperScriptHideAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { hide: "m:val" });
  }
}

class MathSuperScriptHide extends XmlComponent {
  constructor() {
    super("m:supHide");
    this.root.push(new MathSuperScriptHideAttributes({ hide: 1 }));
  }
}

class MathNAryProperties extends XmlComponent {
  constructor(accent, hasSuperScript, hasSubScript, limitLocationVal) {
    super("m:naryPr");
    if (!!accent) {
      this.root.push(new MathAccentCharacter(accent));
    }
    this.root.push(new MathLimitLocation(limitLocationVal));
    if (!hasSuperScript) {
      this.root.push(new MathSuperScriptHide);
    }
    if (!hasSubScript) {
      this.root.push(new MathSubScriptHide);
    }
  }
}

class MathSubScriptElement extends XmlComponent {
  constructor(children) {
    super("m:sub");
    for (const child of children) {
      this.root.push(child);
    }
  }
}

class MathSuperScriptElement extends XmlComponent {
  constructor(children) {
    super("m:sup");
    for (const child of children) {
      this.root.push(child);
    }
  }
}

class MathSum extends XmlComponent {
  constructor(options2) {
    super("m:nary");
    this.root.push(new MathNAryProperties("", !!options2.superScript, !!options2.subScript));
    if (!!options2.subScript) {
      this.root.push(new MathSubScriptElement(options2.subScript));
    }
    if (!!options2.superScript) {
      this.root.push(new MathSuperScriptElement(options2.superScript));
    }
    this.root.push(new MathBase(options2.children));
  }
}
class MathSuperScriptProperties extends XmlComponent {
  constructor() {
    super("m:sSupPr");
  }
}

class MathSuperScript extends XmlComponent {
  constructor(options2) {
    super("m:sSup");
    this.root.push(new MathSuperScriptProperties);
    this.root.push(new MathBase(options2.children));
    this.root.push(new MathSuperScriptElement(options2.superScript));
  }
}

class MathSubScriptProperties extends XmlComponent {
  constructor() {
    super("m:sSubPr");
  }
}

class MathSubScript extends XmlComponent {
  constructor(options2) {
    super("m:sSub");
    this.root.push(new MathSubScriptProperties);
    this.root.push(new MathBase(options2.children));
    this.root.push(new MathSubScriptElement(options2.subScript));
  }
}
class MathDegree extends XmlComponent {
  constructor(children) {
    super("m:deg");
    if (!!children) {
      for (const child of children) {
        this.root.push(child);
      }
    }
  }
}

class MathDegreeHideAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { hide: "m:val" });
  }
}

class MathDegreeHide extends XmlComponent {
  constructor() {
    super("m:degHide");
    this.root.push(new MathDegreeHideAttributes({ hide: 1 }));
  }
}

class MathRadicalProperties extends XmlComponent {
  constructor(hasDegree) {
    super("m:radPr");
    if (!hasDegree) {
      this.root.push(new MathDegreeHide);
    }
  }
}

class MathRadical extends XmlComponent {
  constructor(options2) {
    super("m:rad");
    this.root.push(new MathRadicalProperties(!!options2.degree));
    this.root.push(new MathDegree(options2.degree));
    this.root.push(new MathBase(options2.children));
  }
}
class TableGrid extends XmlComponent {
  constructor(widths) {
    super("w:tblGrid");
    for (const width of widths) {
      this.root.push(new GridCol(width));
    }
  }
}

class GridCol extends XmlComponent {
  constructor(width) {
    super("w:gridCol");
    if (width !== undefined) {
      this.root.push(new NextAttributeComponent({
        width: { key: "w:w", value: twipsMeasureValue(width) }
      }));
    }
  }
}
var TableCellMarginElementType = {
  TABLE: "w:tblCellMar",
  TABLE_CELL: "w:tcMar"
};

class TableCellMargin extends IgnoreIfEmptyXmlComponent {
  constructor(type, { marginUnitType = WidthType.DXA, top, left, bottom, right }) {
    super(type);
    if (top !== undefined) {
      this.root.push(new TableWidthElement("w:top", { type: marginUnitType, size: top }));
    }
    if (left !== undefined) {
      this.root.push(new TableWidthElement("w:left", { type: marginUnitType, size: left }));
    }
    if (bottom !== undefined) {
      this.root.push(new TableWidthElement("w:bottom", { type: marginUnitType, size: bottom }));
    }
    if (right !== undefined) {
      this.root.push(new TableWidthElement("w:right", { type: marginUnitType, size: right }));
    }
  }
}
var WidthType = {
  AUTO: "auto",
  DXA: "dxa",
  NIL: "nil",
  PERCENTAGE: "pct"
};

class TableWidthElement extends XmlComponent {
  constructor(name, { type = WidthType.AUTO, size }) {
    super(name);
    let tableWidthValue = size;
    if (type === WidthType.PERCENTAGE && typeof size === "number") {
      tableWidthValue = `${size}%`;
    }
    this.root.push(new NextAttributeComponent({
      type: { key: "w:type", value: type },
      size: { key: "w:w", value: measurementOrPercentValue(tableWidthValue) }
    }));
  }
}

class TableCellBorders extends IgnoreIfEmptyXmlComponent {
  constructor(options2) {
    super("w:tcBorders");
    if (options2.top) {
      this.root.push(new BorderElement("w:top", options2.top));
    }
    if (options2.start) {
      this.root.push(new BorderElement("w:start", options2.start));
    }
    if (options2.left) {
      this.root.push(new BorderElement("w:left", options2.left));
    }
    if (options2.bottom) {
      this.root.push(new BorderElement("w:bottom", options2.bottom));
    }
    if (options2.end) {
      this.root.push(new BorderElement("w:end", options2.end));
    }
    if (options2.right) {
      this.root.push(new BorderElement("w:right", options2.right));
    }
  }
}

class GridSpanAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
}

class GridSpan extends XmlComponent {
  constructor(value) {
    super("w:gridSpan");
    this.root.push(new GridSpanAttributes({
      val: decimalNumber(value)
    }));
  }
}
var VerticalMergeType = {
  CONTINUE: "continue",
  RESTART: "restart"
};

class VerticalMergeAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
}

class VerticalMerge extends XmlComponent {
  constructor(value) {
    super("w:vMerge");
    this.root.push(new VerticalMergeAttributes({
      val: value
    }));
  }
}
class TDirectionAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
}

class TDirection extends XmlComponent {
  constructor(value) {
    super("w:textDirection");
    this.root.push(new TDirectionAttributes({
      val: value
    }));
  }
}

class TableCellProperties extends IgnoreIfEmptyXmlComponent {
  constructor(options2) {
    super("w:tcPr");
    if (options2.width) {
      this.root.push(new TableWidthElement("w:tcW", options2.width));
    }
    if (options2.columnSpan) {
      this.root.push(new GridSpan(options2.columnSpan));
    }
    if (options2.verticalMerge) {
      this.root.push(new VerticalMerge(options2.verticalMerge));
    } else if (options2.rowSpan && options2.rowSpan > 1) {
      this.root.push(new VerticalMerge(VerticalMergeType.RESTART));
    }
    if (options2.borders) {
      this.root.push(new TableCellBorders(options2.borders));
    }
    if (options2.shading) {
      this.root.push(new Shading(options2.shading));
    }
    if (options2.margins) {
      this.root.push(new TableCellMargin(TableCellMarginElementType.TABLE_CELL, options2.margins));
    }
    if (options2.textDirection) {
      this.root.push(new TDirection(options2.textDirection));
    }
    if (options2.verticalAlign) {
      this.root.push(new VerticalAlignElement(options2.verticalAlign));
    }
  }
}

class TableCell extends XmlComponent {
  constructor(options2) {
    super("w:tc");
    this.options = options2;
    this.root.push(new TableCellProperties(options2));
    for (const child of options2.children) {
      this.root.push(child);
    }
  }
  prepForXml(context) {
    if (!(this.root[this.root.length - 1] instanceof Paragraph)) {
      this.root.push(new Paragraph({}));
    }
    return super.prepForXml(context);
  }
}
var NONE_BORDER = {
  style: BorderStyle.NONE,
  size: 0,
  color: "auto"
};
var DEFAULT_BORDER = {
  style: BorderStyle.SINGLE,
  size: 4,
  color: "auto"
};

class TableBorders extends XmlComponent {
  constructor(options2) {
    super("w:tblBorders");
    if (options2.top) {
      this.root.push(new BorderElement("w:top", options2.top));
    } else {
      this.root.push(new BorderElement("w:top", DEFAULT_BORDER));
    }
    if (options2.left) {
      this.root.push(new BorderElement("w:left", options2.left));
    } else {
      this.root.push(new BorderElement("w:left", DEFAULT_BORDER));
    }
    if (options2.bottom) {
      this.root.push(new BorderElement("w:bottom", options2.bottom));
    } else {
      this.root.push(new BorderElement("w:bottom", DEFAULT_BORDER));
    }
    if (options2.right) {
      this.root.push(new BorderElement("w:right", options2.right));
    } else {
      this.root.push(new BorderElement("w:right", DEFAULT_BORDER));
    }
    if (options2.insideHorizontal) {
      this.root.push(new BorderElement("w:insideH", options2.insideHorizontal));
    } else {
      this.root.push(new BorderElement("w:insideH", DEFAULT_BORDER));
    }
    if (options2.insideVertical) {
      this.root.push(new BorderElement("w:insideV", options2.insideVertical));
    } else {
      this.root.push(new BorderElement("w:insideV", DEFAULT_BORDER));
    }
  }
}
__publicField(TableBorders, "NONE", {
  top: NONE_BORDER,
  bottom: NONE_BORDER,
  left: NONE_BORDER,
  right: NONE_BORDER,
  insideHorizontal: NONE_BORDER,
  insideVertical: NONE_BORDER
});
class TableFloatProperties extends XmlComponent {
  constructor({
    horizontalAnchor,
    verticalAnchor,
    absoluteHorizontalPosition,
    relativeHorizontalPosition,
    absoluteVerticalPosition,
    relativeVerticalPosition,
    bottomFromText,
    topFromText,
    leftFromText,
    rightFromText,
    overlap
  }) {
    super("w:tblpPr");
    this.root.push(new NextAttributeComponent({
      leftFromText: {
        key: "w:leftFromText",
        value: leftFromText === undefined ? undefined : twipsMeasureValue(leftFromText)
      },
      rightFromText: {
        key: "w:rightFromText",
        value: rightFromText === undefined ? undefined : twipsMeasureValue(rightFromText)
      },
      topFromText: {
        key: "w:topFromText",
        value: topFromText === undefined ? undefined : twipsMeasureValue(topFromText)
      },
      bottomFromText: {
        key: "w:bottomFromText",
        value: bottomFromText === undefined ? undefined : twipsMeasureValue(bottomFromText)
      },
      absoluteHorizontalPosition: {
        key: "w:tblpX",
        value: absoluteHorizontalPosition === undefined ? undefined : signedTwipsMeasureValue(absoluteHorizontalPosition)
      },
      absoluteVerticalPosition: {
        key: "w:tblpY",
        value: absoluteVerticalPosition === undefined ? undefined : signedTwipsMeasureValue(absoluteVerticalPosition)
      },
      horizontalAnchor: {
        key: "w:horzAnchor",
        value: horizontalAnchor === undefined ? undefined : horizontalAnchor
      },
      relativeHorizontalPosition: {
        key: "w:tblpXSpec",
        value: relativeHorizontalPosition
      },
      relativeVerticalPosition: {
        key: "w:tblpYSpec",
        value: relativeVerticalPosition
      },
      verticalAnchor: {
        key: "w:vertAnchor",
        value: verticalAnchor
      }
    }));
    if (overlap) {
      this.root.push(new StringEnumValueElement("w:tblOverlap", overlap));
    }
  }
}
class TableLayoutAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { type: "w:type" });
  }
}

class TableLayout extends XmlComponent {
  constructor(type) {
    super("w:tblLayout");
    this.root.push(new TableLayoutAttributes({ type }));
  }
}

class TableProperties extends IgnoreIfEmptyXmlComponent {
  constructor(options2) {
    super("w:tblPr");
    if (options2.style) {
      this.root.push(new StringValueElement("w:tblStyle", options2.style));
    }
    if (options2.float) {
      this.root.push(new TableFloatProperties(options2.float));
    }
    if (options2.visuallyRightToLeft !== undefined) {
      this.root.push(new OnOffElement("w:bidiVisual", options2.visuallyRightToLeft));
    }
    if (options2.width) {
      this.root.push(new TableWidthElement("w:tblW", options2.width));
    }
    if (options2.alignment) {
      this.root.push(new Alignment(options2.alignment));
    }
    if (options2.indent) {
      this.root.push(new TableWidthElement("w:tblInd", options2.indent));
    }
    if (options2.borders) {
      this.root.push(new TableBorders(options2.borders));
    }
    if (options2.shading) {
      this.root.push(new Shading(options2.shading));
    }
    if (options2.layout) {
      this.root.push(new TableLayout(options2.layout));
    }
    if (options2.cellMargin) {
      this.root.push(new TableCellMargin(TableCellMarginElementType.TABLE, options2.cellMargin));
    }
  }
}

class Table extends FileChild {
  constructor({
    rows,
    width,
    columnWidths = Array(Math.max(...rows.map((row) => row.CellCount))).fill(100),
    margins,
    indent: indent2,
    float,
    layout,
    style,
    borders,
    alignment,
    visuallyRightToLeft
  }) {
    super("w:tbl");
    this.root.push(new TableProperties({
      borders: borders != null ? borders : {},
      width: width != null ? width : { size: 100 },
      indent: indent2,
      float,
      layout,
      style,
      alignment,
      cellMargin: margins,
      visuallyRightToLeft
    }));
    this.root.push(new TableGrid(columnWidths));
    for (const row of rows) {
      this.root.push(row);
    }
    rows.forEach((row, rowIndex) => {
      if (rowIndex === rows.length - 1) {
        return;
      }
      let columnIndex = 0;
      row.cells.forEach((cell) => {
        if (cell.options.rowSpan && cell.options.rowSpan > 1) {
          const continueCell = new TableCell({
            rowSpan: cell.options.rowSpan - 1,
            columnSpan: cell.options.columnSpan,
            borders: cell.options.borders,
            children: [],
            verticalMerge: VerticalMergeType.CONTINUE
          });
          rows[rowIndex + 1].addCellToColumnIndex(continueCell, columnIndex);
        }
        columnIndex += cell.options.columnSpan || 1;
      });
    });
  }
}
class TableRowHeightAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { value: "w:val", rule: "w:hRule" });
  }
}

class TableRowHeight extends XmlComponent {
  constructor(value, rule) {
    super("w:trHeight");
    this.root.push(new TableRowHeightAttributes({
      value: twipsMeasureValue(value),
      rule
    }));
  }
}

class TableRowProperties extends IgnoreIfEmptyXmlComponent {
  constructor(options2) {
    super("w:trPr");
    if (options2.cantSplit !== undefined) {
      this.root.push(new OnOffElement("w:cantSplit", options2.cantSplit));
    }
    if (options2.tableHeader !== undefined) {
      this.root.push(new OnOffElement("w:tblHeader", options2.tableHeader));
    }
    if (options2.height) {
      this.root.push(new TableRowHeight(options2.height.value, options2.height.rule));
    }
  }
}

class TableRow extends XmlComponent {
  constructor(options2) {
    super("w:tr");
    this.options = options2;
    this.root.push(new TableRowProperties(options2));
    for (const child of options2.children) {
      this.root.push(child);
    }
  }
  get CellCount() {
    return this.options.children.length;
  }
  get cells() {
    return this.root.filter((xmlComponent) => xmlComponent instanceof TableCell);
  }
  addCellToIndex(cell, index2) {
    this.root.splice(index2 + 1, 0, cell);
  }
  addCellToColumnIndex(cell, columnIndex) {
    const rootIndex = this.columnIndexToRootIndex(columnIndex, true);
    this.addCellToIndex(cell, rootIndex - 1);
  }
  rootIndexToColumnIndex(rootIndex) {
    if (rootIndex < 1 || rootIndex >= this.root.length) {
      throw new Error(`cell 'rootIndex' should between 1 to ${this.root.length - 1}`);
    }
    let colIdx = 0;
    for (let rootIdx = 1;rootIdx < rootIndex; rootIdx++) {
      const cell = this.root[rootIdx];
      colIdx += cell.options.columnSpan || 1;
    }
    return colIdx;
  }
  columnIndexToRootIndex(columnIndex, allowEndNewCell = false) {
    if (columnIndex < 0) {
      throw new Error(`cell 'columnIndex' should not less than zero`);
    }
    let colIdx = 0;
    let rootIdx = 1;
    while (colIdx <= columnIndex) {
      if (rootIdx >= this.root.length) {
        if (allowEndNewCell) {
          return this.root.length;
        } else {
          throw new Error(`cell 'columnIndex' should not great than ${colIdx - 1}`);
        }
      }
      const cell = this.root[rootIdx];
      rootIdx += 1;
      colIdx += cell && cell.options.columnSpan || 1;
    }
    return rootIdx - 1;
  }
}

class AppPropertiesAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns",
      vt: "xmlns:vt"
    });
  }
}

class AppProperties extends XmlComponent {
  constructor() {
    super("Properties");
    this.root.push(new AppPropertiesAttributes({
      xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
      vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
    }));
  }
}

class ContentTypeAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns"
    });
  }
}

class DefaultAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      contentType: "ContentType",
      extension: "Extension"
    });
  }
}

class Default extends XmlComponent {
  constructor(contentType, extension2) {
    super("Default");
    this.root.push(new DefaultAttributes({
      contentType,
      extension: extension2
    }));
  }
}

class OverrideAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      contentType: "ContentType",
      partName: "PartName"
    });
  }
}

class Override extends XmlComponent {
  constructor(contentType, partName) {
    super("Override");
    this.root.push(new OverrideAttributes({
      contentType,
      partName
    }));
  }
}

class ContentTypes extends XmlComponent {
  constructor() {
    super("Types");
    this.root.push(new ContentTypeAttributes({
      xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
    }));
    this.root.push(new Default("image/png", "png"));
    this.root.push(new Default("image/jpeg", "jpeg"));
    this.root.push(new Default("image/jpeg", "jpg"));
    this.root.push(new Default("image/bmp", "bmp"));
    this.root.push(new Default("image/gif", "gif"));
    this.root.push(new Default("image/svg+xml", "svg"));
    this.root.push(new Default("application/vnd.openxmlformats-package.relationships+xml", "rels"));
    this.root.push(new Default("application/xml", "xml"));
    this.root.push(new Default("application/vnd.openxmlformats-officedocument.obfuscatedFont", "odttf"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", "/word/document.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml", "/word/styles.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-package.core-properties+xml", "/docProps/core.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.custom-properties+xml", "/docProps/custom.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.extended-properties+xml", "/docProps/app.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml", "/word/numbering.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml", "/word/footnotes.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml", "/word/settings.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml", "/word/comments.xml"));
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml", "/word/fontTable.xml"));
  }
  addFooter(index2) {
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml", `/word/footer${index2}.xml`));
  }
  addHeader(index2) {
    this.root.push(new Override("application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml", `/word/header${index2}.xml`));
  }
}

class CoreProperties extends XmlComponent {
  constructor(options2) {
    super("cp:coreProperties");
    this.root.push(new DocumentAttributes({
      cp: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
      dc: "http://purl.org/dc/elements/1.1/",
      dcterms: "http://purl.org/dc/terms/",
      dcmitype: "http://purl.org/dc/dcmitype/",
      xsi: "http://www.w3.org/2001/XMLSchema-instance"
    }));
    if (options2.title) {
      this.root.push(new StringContainer("dc:title", options2.title));
    }
    if (options2.subject) {
      this.root.push(new StringContainer("dc:subject", options2.subject));
    }
    if (options2.creator) {
      this.root.push(new StringContainer("dc:creator", options2.creator));
    }
    if (options2.keywords) {
      this.root.push(new StringContainer("cp:keywords", options2.keywords));
    }
    if (options2.description) {
      this.root.push(new StringContainer("dc:description", options2.description));
    }
    if (options2.lastModifiedBy) {
      this.root.push(new StringContainer("cp:lastModifiedBy", options2.lastModifiedBy));
    }
    if (options2.revision) {
      this.root.push(new StringContainer("cp:revision", String(options2.revision)));
    }
    this.root.push(new TimestampElement("dcterms:created"));
    this.root.push(new TimestampElement("dcterms:modified"));
  }
}

class TimestampElement extends XmlComponent {
  constructor(name) {
    super(name);
    this.root.push(new DocumentAttributes({
      type: "dcterms:W3CDTF"
    }));
    this.root.push(dateTimeValue(/* @__PURE__ */ new Date));
  }
}

class CustomPropertiesAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      xmlns: "xmlns",
      vt: "xmlns:vt"
    });
  }
}

class CustomPropertyAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      fmtid: "fmtid",
      pid: "pid",
      name: "name"
    });
  }
}

class CustomProperty extends XmlComponent {
  constructor(id, properties) {
    super("property");
    this.root.push(new CustomPropertyAttributes({
      fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      pid: id.toString(),
      name: properties.name
    }));
    this.root.push(new CustomPropertyValue(properties.value));
  }
}

class CustomPropertyValue extends XmlComponent {
  constructor(value) {
    super("vt:lpwstr");
    this.root.push(value);
  }
}

class CustomProperties extends XmlComponent {
  constructor(properties) {
    super("Properties");
    __publicField(this, "nextId");
    __publicField(this, "properties", []);
    this.root.push(new CustomPropertiesAttributes({
      xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
      vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
    }));
    this.nextId = 2;
    for (const property of properties) {
      this.addCustomProperty(property);
    }
  }
  prepForXml(context) {
    this.properties.forEach((x) => this.root.push(x));
    return super.prepForXml(context);
  }
  addCustomProperty(property) {
    this.properties.push(new CustomProperty(this.nextId++, property));
  }
}

class FooterAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type"
    });
  }
}
var Footer$1 = class Footer extends InitializableXmlComponent {
  constructor(referenceNumber, initContent) {
    super("w:ftr", initContent);
    __publicField(this, "refId");
    this.refId = referenceNumber;
    if (!initContent) {
      this.root.push(new FooterAttributes({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
      }));
    }
  }
  get ReferenceId() {
    return this.refId;
  }
  add(item) {
    this.root.push(item);
  }
};

class FooterWrapper {
  constructor(media, referenceId, initContent) {
    __publicField(this, "footer");
    __publicField(this, "relationships");
    this.media = media;
    this.footer = new Footer$1(referenceId, initContent);
    this.relationships = new Relationships;
  }
  add(item) {
    this.footer.add(item);
  }
  addChildElement(childElement) {
    this.footer.addChildElement(childElement);
  }
  get View() {
    return this.footer;
  }
  get Relationships() {
    return this.relationships;
  }
  get Media() {
    return this.media;
  }
}

class FootnoteAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      type: "w:type",
      id: "w:id"
    });
  }
}

class FootnoteRef extends XmlComponent {
  constructor() {
    super("w:footnoteRef");
  }
}

class FootnoteRefRun extends Run {
  constructor() {
    super({
      style: "FootnoteReference"
    });
    this.root.push(new FootnoteRef);
  }
}
var FootnoteType = {
  SEPERATOR: "separator",
  CONTINUATION_SEPERATOR: "continuationSeparator"
};

class Footnote extends XmlComponent {
  constructor(options2) {
    super("w:footnote");
    this.root.push(new FootnoteAttributes({
      type: options2.type,
      id: options2.id
    }));
    for (let i = 0;i < options2.children.length; i++) {
      const child = options2.children[i];
      if (i === 0) {
        child.addRunToFront(new FootnoteRefRun);
      }
      this.root.push(child);
    }
  }
}

class ContinuationSeperator extends XmlComponent {
  constructor() {
    super("w:continuationSeparator");
  }
}

class ContinuationSeperatorRun extends Run {
  constructor() {
    super({});
    this.root.push(new ContinuationSeperator);
  }
}

class Seperator extends XmlComponent {
  constructor() {
    super("w:separator");
  }
}

class SeperatorRun extends Run {
  constructor() {
    super({});
    this.root.push(new Seperator);
  }
}

class FootnotesAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable"
    });
  }
}

class FootNotes extends XmlComponent {
  constructor() {
    super("w:footnotes");
    this.root.push(new FootnotesAttributes({
      wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
      mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
      o: "urn:schemas-microsoft-com:office:office",
      r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
      v: "urn:schemas-microsoft-com:vml",
      wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
      wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
      w10: "urn:schemas-microsoft-com:office:word",
      w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
      w14: "http://schemas.microsoft.com/office/word/2010/wordml",
      w15: "http://schemas.microsoft.com/office/word/2012/wordml",
      wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
      wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
      wne: "http://schemas.microsoft.com/office/word/2006/wordml",
      wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
      Ignorable: "w14 w15 wp14"
    }));
    const begin = new Footnote({
      id: -1,
      type: FootnoteType.SEPERATOR,
      children: [
        new Paragraph({
          spacing: {
            after: 0,
            line: 240,
            lineRule: LineRuleType.AUTO
          },
          children: [new SeperatorRun]
        })
      ]
    });
    this.root.push(begin);
    const spacing = new Footnote({
      id: 0,
      type: FootnoteType.CONTINUATION_SEPERATOR,
      children: [
        new Paragraph({
          spacing: {
            after: 0,
            line: 240,
            lineRule: LineRuleType.AUTO
          },
          children: [new ContinuationSeperatorRun]
        })
      ]
    });
    this.root.push(spacing);
  }
  createFootNote(id, paragraph2) {
    const footnote = new Footnote({
      id,
      children: paragraph2
    });
    this.root.push(footnote);
  }
}

class FootnotesWrapper {
  constructor() {
    __publicField(this, "footnotess");
    __publicField(this, "relationships");
    this.footnotess = new FootNotes;
    this.relationships = new Relationships;
  }
  get View() {
    return this.footnotess;
  }
  get Relationships() {
    return this.relationships;
  }
}

class HeaderAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type",
      cx: "xmlns:cx",
      cx1: "xmlns:cx1",
      cx2: "xmlns:cx2",
      cx3: "xmlns:cx3",
      cx4: "xmlns:cx4",
      cx5: "xmlns:cx5",
      cx6: "xmlns:cx6",
      cx7: "xmlns:cx7",
      cx8: "xmlns:cx8",
      w16cid: "xmlns:w16cid",
      w16se: "xmlns:w16se"
    });
  }
}
var Header$1 = class Header extends InitializableXmlComponent {
  constructor(referenceNumber, initContent) {
    super("w:hdr", initContent);
    __publicField(this, "refId");
    this.refId = referenceNumber;
    if (!initContent) {
      this.root.push(new HeaderAttributes({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
        cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex"
      }));
    }
  }
  get ReferenceId() {
    return this.refId;
  }
  add(item) {
    this.root.push(item);
  }
};

class HeaderWrapper {
  constructor(media, referenceId, initContent) {
    __publicField(this, "header");
    __publicField(this, "relationships");
    this.media = media;
    this.header = new Header$1(referenceId, initContent);
    this.relationships = new Relationships;
  }
  add(item) {
    this.header.add(item);
    return this;
  }
  addChildElement(childElement) {
    this.header.addChildElement(childElement);
  }
  get View() {
    return this.header;
  }
  get Relationships() {
    return this.relationships;
  }
  get Media() {
    return this.media;
  }
}

class Media {
  constructor() {
    __publicField(this, "map");
    this.map = /* @__PURE__ */ new Map;
  }
  addImage(key, mediaData) {
    this.map.set(key, mediaData);
  }
  get Array() {
    return Array.from(this.map.values());
  }
}
var LevelFormat = {
  DECIMAL: "decimal",
  UPPER_ROMAN: "upperRoman",
  LOWER_ROMAN: "lowerRoman",
  UPPER_LETTER: "upperLetter",
  LOWER_LETTER: "lowerLetter",
  ORDINAL: "ordinal",
  CARDINAL_TEXT: "cardinalText",
  ORDINAL_TEXT: "ordinalText",
  HEX: "hex",
  CHICAGO: "chicago",
  IDEOGRAPH__DIGITAL: "ideographDigital",
  JAPANESE_COUNTING: "japaneseCounting",
  AIUEO: "aiueo",
  IROHA: "iroha",
  DECIMAL_FULL_WIDTH: "decimalFullWidth",
  DECIMAL_HALF_WIDTH: "decimalHalfWidth",
  JAPANESE_LEGAL: "japaneseLegal",
  JAPANESE_DIGITAL_TEN_THOUSAND: "japaneseDigitalTenThousand",
  DECIMAL_ENCLOSED_CIRCLE: "decimalEnclosedCircle",
  DECIMAL_FULL_WIDTH2: "decimalFullWidth2",
  AIUEO_FULL_WIDTH: "aiueoFullWidth",
  IROHA_FULL_WIDTH: "irohaFullWidth",
  DECIMAL_ZERO: "decimalZero",
  BULLET: "bullet",
  GANADA: "ganada",
  CHOSUNG: "chosung",
  DECIMAL_ENCLOSED_FULLSTOP: "decimalEnclosedFullstop",
  DECIMAL_ENCLOSED_PARENTHESES: "decimalEnclosedParen",
  DECIMAL_ENCLOSED_CIRCLE_CHINESE: "decimalEnclosedCircleChinese",
  IDEOGRAPH_ENCLOSED_CIRCLE: "ideographEnclosedCircle",
  IDEOGRAPH_TRADITIONAL: "ideographTraditional",
  IDEOGRAPH_ZODIAC: "ideographZodiac",
  IDEOGRAPH_ZODIAC_TRADITIONAL: "ideographZodiacTraditional",
  TAIWANESE_COUNTING: "taiwaneseCounting",
  IDEOGRAPH_LEGAL_TRADITIONAL: "ideographLegalTraditional",
  TAIWANESE_COUNTING_THOUSAND: "taiwaneseCountingThousand",
  TAIWANESE_DIGITAL: "taiwaneseDigital",
  CHINESE_COUNTING: "chineseCounting",
  CHINESE_LEGAL_SIMPLIFIED: "chineseLegalSimplified",
  CHINESE_COUNTING_THOUSAND: "chineseCountingThousand",
  KOREAN_DIGITAL: "koreanDigital",
  KOREAN_COUNTING: "koreanCounting",
  KOREAN_LEGAL: "koreanLegal",
  KOREAN_DIGITAL2: "koreanDigital2",
  VIETNAMESE_COUNTING: "vietnameseCounting",
  RUSSIAN_LOWER: "russianLower",
  RUSSIAN_UPPER: "russianUpper",
  NONE: "none",
  NUMBER_IN_DASH: "numberInDash",
  HEBREW1: "hebrew1",
  HEBREW2: "hebrew2",
  ARABIC_ALPHA: "arabicAlpha",
  ARABIC_ABJAD: "arabicAbjad",
  HINDI_VOWELS: "hindiVowels",
  HINDI_CONSONANTS: "hindiConsonants",
  HINDI_NUMBERS: "hindiNumbers",
  HINDI_COUNTING: "hindiCounting",
  THAI_LETTERS: "thaiLetters",
  THAI_NUMBERS: "thaiNumbers",
  THAI_COUNTING: "thaiCounting",
  BAHT_TEXT: "bahtText",
  DOLLAR_TEXT: "dollarText",
  CUSTOM: "custom"
};

class LevelAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      ilvl: "w:ilvl",
      tentative: "w15:tentative"
    });
  }
}

class NumberFormat extends XmlComponent {
  constructor(value) {
    super("w:numFmt");
    this.root.push(new Attributes({
      val: value
    }));
  }
}

class LevelText extends XmlComponent {
  constructor(value) {
    super("w:lvlText");
    this.root.push(new Attributes({
      val: value
    }));
  }
}

class LevelJc extends XmlComponent {
  constructor(value) {
    super("w:lvlJc");
    this.root.push(new Attributes({
      val: value
    }));
  }
}
class Suffix extends XmlComponent {
  constructor(value) {
    super("w:suff");
    this.root.push(new Attributes({
      val: value
    }));
  }
}

class IsLegalNumberingStyle extends XmlComponent {
  constructor() {
    super("w:isLgl");
  }
}

class LevelBase extends XmlComponent {
  constructor({
    level,
    format: format2,
    text: text5,
    alignment = AlignmentType.START,
    start = 1,
    style,
    suffix,
    isLegalNumberingStyle
  }) {
    super("w:lvl");
    __publicField(this, "paragraphProperties");
    __publicField(this, "runProperties");
    this.root.push(new NumberValueElement("w:start", decimalNumber(start)));
    if (format2) {
      this.root.push(new NumberFormat(format2));
    }
    if (suffix) {
      this.root.push(new Suffix(suffix));
    }
    if (isLegalNumberingStyle) {
      this.root.push(new IsLegalNumberingStyle);
    }
    if (text5) {
      this.root.push(new LevelText(text5));
    }
    this.root.push(new LevelJc(alignment));
    this.paragraphProperties = new ParagraphProperties(style && style.paragraph);
    this.runProperties = new RunProperties(style && style.run);
    this.root.push(this.paragraphProperties);
    this.root.push(this.runProperties);
    if (level > 9) {
      throw new Error("Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7");
    }
    this.root.push(new LevelAttributes({
      ilvl: decimalNumber(level),
      tentative: 1
    }));
  }
}

class Level extends LevelBase {
}
class MultiLevelType extends XmlComponent {
  constructor(value) {
    super("w:multiLevelType");
    this.root.push(new Attributes({
      val: value
    }));
  }
}

class AbstractNumberingAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      abstractNumId: "w:abstractNumId",
      restartNumberingAfterBreak: "w15:restartNumberingAfterBreak"
    });
  }
}

class AbstractNumbering extends XmlComponent {
  constructor(id, levelOptions) {
    super("w:abstractNum");
    __publicField(this, "id");
    this.root.push(new AbstractNumberingAttributes({
      abstractNumId: decimalNumber(id),
      restartNumberingAfterBreak: 0
    }));
    this.root.push(new MultiLevelType("hybridMultilevel"));
    this.id = id;
    for (const option of levelOptions) {
      this.root.push(new Level(option));
    }
  }
}

class AbstractNumId extends XmlComponent {
  constructor(value) {
    super("w:abstractNumId");
    this.root.push(new Attributes({
      val: value
    }));
  }
}

class NumAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { numId: "w:numId" });
  }
}

class ConcreteNumbering extends XmlComponent {
  constructor(options2) {
    super("w:num");
    __publicField(this, "numId");
    __publicField(this, "reference");
    __publicField(this, "instance");
    this.numId = options2.numId;
    this.reference = options2.reference;
    this.instance = options2.instance;
    this.root.push(new NumAttributes({
      numId: decimalNumber(options2.numId)
    }));
    this.root.push(new AbstractNumId(decimalNumber(options2.abstractNumId)));
    if (options2.overrideLevels && options2.overrideLevels.length) {
      for (const level of options2.overrideLevels) {
        this.root.push(new LevelOverride(level.num, level.start));
      }
    }
  }
}

class LevelOverrideAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { ilvl: "w:ilvl" });
  }
}

class LevelOverride extends XmlComponent {
  constructor(levelNum, start) {
    super("w:lvlOverride");
    this.root.push(new LevelOverrideAttributes({ ilvl: levelNum }));
    if (start !== undefined) {
      this.root.push(new StartOverride(start));
    }
  }
}

class StartOverrideAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
}

class StartOverride extends XmlComponent {
  constructor(start) {
    super("w:startOverride");
    this.root.push(new StartOverrideAttributes({ val: start }));
  }
}

class Numbering extends XmlComponent {
  constructor(options2) {
    super("w:numbering");
    __publicField(this, "abstractNumberingMap", /* @__PURE__ */ new Map);
    __publicField(this, "concreteNumberingMap", /* @__PURE__ */ new Map);
    __publicField(this, "referenceConfigMap", /* @__PURE__ */ new Map);
    __publicField(this, "abstractNumUniqueNumericId", abstractNumUniqueNumericIdGen());
    __publicField(this, "concreteNumUniqueNumericId", concreteNumUniqueNumericIdGen());
    this.root.push(new DocumentAttributes({
      wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
      mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
      o: "urn:schemas-microsoft-com:office:office",
      r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
      v: "urn:schemas-microsoft-com:vml",
      wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
      wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
      w10: "urn:schemas-microsoft-com:office:word",
      w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
      w14: "http://schemas.microsoft.com/office/word/2010/wordml",
      w15: "http://schemas.microsoft.com/office/word/2012/wordml",
      wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
      wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
      wne: "http://schemas.microsoft.com/office/word/2006/wordml",
      wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
      Ignorable: "w14 w15 wp14"
    }));
    const abstractNumbering = new AbstractNumbering(this.abstractNumUniqueNumericId(), [
      {
        level: 0,
        format: LevelFormat.BULLET,
        text: "",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: convertInchesToTwip(0.5), hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 1,
        format: LevelFormat.BULLET,
        text: "",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: convertInchesToTwip(1), hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 2,
        format: LevelFormat.BULLET,
        text: "",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 2160, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 3,
        format: LevelFormat.BULLET,
        text: "",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 2880, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 4,
        format: LevelFormat.BULLET,
        text: "",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 3600, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 5,
        format: LevelFormat.BULLET,
        text: "",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 4320, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 6,
        format: LevelFormat.BULLET,
        text: "",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 5040, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 7,
        format: LevelFormat.BULLET,
        text: "",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 5760, hanging: convertInchesToTwip(0.25) }
          }
        }
      },
      {
        level: 8,
        format: LevelFormat.BULLET,
        text: "",
        alignment: AlignmentType.LEFT,
        style: {
          paragraph: {
            indent: { left: 6480, hanging: convertInchesToTwip(0.25) }
          }
        }
      }
    ]);
    this.concreteNumberingMap.set("default-bullet-numbering", new ConcreteNumbering({
      numId: 1,
      abstractNumId: abstractNumbering.id,
      reference: "default-bullet-numbering",
      instance: 0,
      overrideLevels: [
        {
          num: 0,
          start: 1
        }
      ]
    }));
    this.abstractNumberingMap.set("default-bullet-numbering", abstractNumbering);
    for (const con of options2.config) {
      this.abstractNumberingMap.set(con.reference, new AbstractNumbering(this.abstractNumUniqueNumericId(), con.levels));
      this.referenceConfigMap.set(con.reference, con.levels);
    }
  }
  prepForXml(context) {
    for (const numbering of this.abstractNumberingMap.values()) {
      this.root.push(numbering);
    }
    for (const numbering of this.concreteNumberingMap.values()) {
      this.root.push(numbering);
    }
    return super.prepForXml(context);
  }
  createConcreteNumberingInstance(reference, instance) {
    const abstractNumbering = this.abstractNumberingMap.get(reference);
    if (!abstractNumbering) {
      return;
    }
    const fullReference = `${reference}-${instance}`;
    if (this.concreteNumberingMap.has(fullReference)) {
      return;
    }
    const referenceConfigLevels = this.referenceConfigMap.get(reference);
    const firstLevelStartNumber = referenceConfigLevels && referenceConfigLevels[0].start;
    const concreteNumberingSettings = {
      numId: this.concreteNumUniqueNumericId(),
      abstractNumId: abstractNumbering.id,
      reference,
      instance,
      overrideLevels: [
        firstLevelStartNumber && Number.isInteger(firstLevelStartNumber) ? {
          num: 0,
          start: firstLevelStartNumber
        } : {
          num: 0,
          start: 1
        }
      ]
    };
    this.concreteNumberingMap.set(fullReference, new ConcreteNumbering(concreteNumberingSettings));
  }
  get ConcreteNumbering() {
    return Array.from(this.concreteNumberingMap.values());
  }
  get ReferenceConfig() {
    return Array.from(this.referenceConfigMap.values());
  }
}

class CompatibilitySettingAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      version: "w:val",
      name: "w:name",
      uri: "w:uri"
    });
  }
}

class CompatibilitySetting extends XmlComponent {
  constructor(version) {
    super("w:compatSetting");
    this.root.push(new CompatibilitySettingAttributes({
      version,
      uri: "http://schemas.microsoft.com/office/word",
      name: "compatibilityMode"
    }));
  }
}

class Compatibility extends XmlComponent {
  constructor(options2) {
    super("w:compat");
    if (options2.version) {
      this.root.push(new CompatibilitySetting(options2.version));
    }
    if (options2.useSingleBorderforContiguousCells) {
      this.root.push(new OnOffElement("w:useSingleBorderforContiguousCells", options2.useSingleBorderforContiguousCells));
    }
    if (options2.wordPerfectJustification) {
      this.root.push(new OnOffElement("w:wpJustification", options2.wordPerfectJustification));
    }
    if (options2.noTabStopForHangingIndent) {
      this.root.push(new OnOffElement("w:noTabHangInd", options2.noTabStopForHangingIndent));
    }
    if (options2.noLeading) {
      this.root.push(new OnOffElement("w:noLeading", options2.noLeading));
    }
    if (options2.spaceForUnderline) {
      this.root.push(new OnOffElement("w:spaceForUL", options2.spaceForUnderline));
    }
    if (options2.noColumnBalance) {
      this.root.push(new OnOffElement("w:noColumnBalance", options2.noColumnBalance));
    }
    if (options2.balanceSingleByteDoubleByteWidth) {
      this.root.push(new OnOffElement("w:balanceSingleByteDoubleByteWidth", options2.balanceSingleByteDoubleByteWidth));
    }
    if (options2.noExtraLineSpacing) {
      this.root.push(new OnOffElement("w:noExtraLineSpacing", options2.noExtraLineSpacing));
    }
    if (options2.doNotLeaveBackslashAlone) {
      this.root.push(new OnOffElement("w:doNotLeaveBackslashAlone", options2.doNotLeaveBackslashAlone));
    }
    if (options2.underlineTrailingSpaces) {
      this.root.push(new OnOffElement("w:ulTrailSpace", options2.underlineTrailingSpaces));
    }
    if (options2.doNotExpandShiftReturn) {
      this.root.push(new OnOffElement("w:doNotExpandShiftReturn", options2.doNotExpandShiftReturn));
    }
    if (options2.spacingInWholePoints) {
      this.root.push(new OnOffElement("w:spacingInWholePoints", options2.spacingInWholePoints));
    }
    if (options2.lineWrapLikeWord6) {
      this.root.push(new OnOffElement("w:lineWrapLikeWord6", options2.lineWrapLikeWord6));
    }
    if (options2.printBodyTextBeforeHeader) {
      this.root.push(new OnOffElement("w:printBodyTextBeforeHeader", options2.printBodyTextBeforeHeader));
    }
    if (options2.printColorsBlack) {
      this.root.push(new OnOffElement("w:printColBlack", options2.printColorsBlack));
    }
    if (options2.spaceWidth) {
      this.root.push(new OnOffElement("w:wpSpaceWidth", options2.spaceWidth));
    }
    if (options2.showBreaksInFrames) {
      this.root.push(new OnOffElement("w:showBreaksInFrames", options2.showBreaksInFrames));
    }
    if (options2.subFontBySize) {
      this.root.push(new OnOffElement("w:subFontBySize", options2.subFontBySize));
    }
    if (options2.suppressBottomSpacing) {
      this.root.push(new OnOffElement("w:suppressBottomSpacing", options2.suppressBottomSpacing));
    }
    if (options2.suppressTopSpacing) {
      this.root.push(new OnOffElement("w:suppressTopSpacing", options2.suppressTopSpacing));
    }
    if (options2.suppressSpacingAtTopOfPage) {
      this.root.push(new OnOffElement("w:suppressSpacingAtTopOfPage", options2.suppressSpacingAtTopOfPage));
    }
    if (options2.suppressTopSpacingWP) {
      this.root.push(new OnOffElement("w:suppressTopSpacingWP", options2.suppressTopSpacingWP));
    }
    if (options2.suppressSpBfAfterPgBrk) {
      this.root.push(new OnOffElement("w:suppressSpBfAfterPgBrk", options2.suppressSpBfAfterPgBrk));
    }
    if (options2.swapBordersFacingPages) {
      this.root.push(new OnOffElement("w:swapBordersFacingPages", options2.swapBordersFacingPages));
    }
    if (options2.convertMailMergeEsc) {
      this.root.push(new OnOffElement("w:convMailMergeEsc", options2.convertMailMergeEsc));
    }
    if (options2.truncateFontHeightsLikeWP6) {
      this.root.push(new OnOffElement("w:truncateFontHeightsLikeWP6", options2.truncateFontHeightsLikeWP6));
    }
    if (options2.macWordSmallCaps) {
      this.root.push(new OnOffElement("w:mwSmallCaps", options2.macWordSmallCaps));
    }
    if (options2.usePrinterMetrics) {
      this.root.push(new OnOffElement("w:usePrinterMetrics", options2.usePrinterMetrics));
    }
    if (options2.doNotSuppressParagraphBorders) {
      this.root.push(new OnOffElement("w:doNotSuppressParagraphBorders", options2.doNotSuppressParagraphBorders));
    }
    if (options2.wrapTrailSpaces) {
      this.root.push(new OnOffElement("w:wrapTrailSpaces", options2.wrapTrailSpaces));
    }
    if (options2.footnoteLayoutLikeWW8) {
      this.root.push(new OnOffElement("w:footnoteLayoutLikeWW8", options2.footnoteLayoutLikeWW8));
    }
    if (options2.shapeLayoutLikeWW8) {
      this.root.push(new OnOffElement("w:shapeLayoutLikeWW8", options2.shapeLayoutLikeWW8));
    }
    if (options2.alignTablesRowByRow) {
      this.root.push(new OnOffElement("w:alignTablesRowByRow", options2.alignTablesRowByRow));
    }
    if (options2.forgetLastTabAlignment) {
      this.root.push(new OnOffElement("w:forgetLastTabAlignment", options2.forgetLastTabAlignment));
    }
    if (options2.adjustLineHeightInTable) {
      this.root.push(new OnOffElement("w:adjustLineHeightInTable", options2.adjustLineHeightInTable));
    }
    if (options2.autoSpaceLikeWord95) {
      this.root.push(new OnOffElement("w:autoSpaceLikeWord95", options2.autoSpaceLikeWord95));
    }
    if (options2.noSpaceRaiseLower) {
      this.root.push(new OnOffElement("w:noSpaceRaiseLower", options2.noSpaceRaiseLower));
    }
    if (options2.doNotUseHTMLParagraphAutoSpacing) {
      this.root.push(new OnOffElement("w:doNotUseHTMLParagraphAutoSpacing", options2.doNotUseHTMLParagraphAutoSpacing));
    }
    if (options2.layoutRawTableWidth) {
      this.root.push(new OnOffElement("w:layoutRawTableWidth", options2.layoutRawTableWidth));
    }
    if (options2.layoutTableRowsApart) {
      this.root.push(new OnOffElement("w:layoutTableRowsApart", options2.layoutTableRowsApart));
    }
    if (options2.useWord97LineBreakRules) {
      this.root.push(new OnOffElement("w:useWord97LineBreakRules", options2.useWord97LineBreakRules));
    }
    if (options2.doNotBreakWrappedTables) {
      this.root.push(new OnOffElement("w:doNotBreakWrappedTables", options2.doNotBreakWrappedTables));
    }
    if (options2.doNotSnapToGridInCell) {
      this.root.push(new OnOffElement("w:doNotSnapToGridInCell", options2.doNotSnapToGridInCell));
    }
    if (options2.selectFieldWithFirstOrLastCharacter) {
      this.root.push(new OnOffElement("w:selectFldWithFirstOrLastChar", options2.selectFieldWithFirstOrLastCharacter));
    }
    if (options2.applyBreakingRules) {
      this.root.push(new OnOffElement("w:applyBreakingRules", options2.applyBreakingRules));
    }
    if (options2.doNotWrapTextWithPunctuation) {
      this.root.push(new OnOffElement("w:doNotWrapTextWithPunct", options2.doNotWrapTextWithPunctuation));
    }
    if (options2.doNotUseEastAsianBreakRules) {
      this.root.push(new OnOffElement("w:doNotUseEastAsianBreakRules", options2.doNotUseEastAsianBreakRules));
    }
    if (options2.useWord2002TableStyleRules) {
      this.root.push(new OnOffElement("w:useWord2002TableStyleRules", options2.useWord2002TableStyleRules));
    }
    if (options2.growAutofit) {
      this.root.push(new OnOffElement("w:growAutofit", options2.growAutofit));
    }
    if (options2.useFELayout) {
      this.root.push(new OnOffElement("w:useFELayout", options2.useFELayout));
    }
    if (options2.useNormalStyleForList) {
      this.root.push(new OnOffElement("w:useNormalStyleForList", options2.useNormalStyleForList));
    }
    if (options2.doNotUseIndentAsNumberingTabStop) {
      this.root.push(new OnOffElement("w:doNotUseIndentAsNumberingTabStop", options2.doNotUseIndentAsNumberingTabStop));
    }
    if (options2.useAlternateEastAsianLineBreakRules) {
      this.root.push(new OnOffElement("w:useAltKinsokuLineBreakRules", options2.useAlternateEastAsianLineBreakRules));
    }
    if (options2.allowSpaceOfSameStyleInTable) {
      this.root.push(new OnOffElement("w:allowSpaceOfSameStyleInTable", options2.allowSpaceOfSameStyleInTable));
    }
    if (options2.doNotSuppressIndentation) {
      this.root.push(new OnOffElement("w:doNotSuppressIndentation", options2.doNotSuppressIndentation));
    }
    if (options2.doNotAutofitConstrainedTables) {
      this.root.push(new OnOffElement("w:doNotAutofitConstrainedTables", options2.doNotAutofitConstrainedTables));
    }
    if (options2.autofitToFirstFixedWidthCell) {
      this.root.push(new OnOffElement("w:autofitToFirstFixedWidthCell", options2.autofitToFirstFixedWidthCell));
    }
    if (options2.underlineTabInNumberingList) {
      this.root.push(new OnOffElement("w:underlineTabInNumList", options2.underlineTabInNumberingList));
    }
    if (options2.displayHangulFixedWidth) {
      this.root.push(new OnOffElement("w:displayHangulFixedWidth", options2.displayHangulFixedWidth));
    }
    if (options2.splitPgBreakAndParaMark) {
      this.root.push(new OnOffElement("w:splitPgBreakAndParaMark", options2.splitPgBreakAndParaMark));
    }
    if (options2.doNotVerticallyAlignCellWithSp) {
      this.root.push(new OnOffElement("w:doNotVertAlignCellWithSp", options2.doNotVerticallyAlignCellWithSp));
    }
    if (options2.doNotBreakConstrainedForcedTable) {
      this.root.push(new OnOffElement("w:doNotBreakConstrainedForcedTable", options2.doNotBreakConstrainedForcedTable));
    }
    if (options2.ignoreVerticalAlignmentInTextboxes) {
      this.root.push(new OnOffElement("w:doNotVertAlignInTxbx", options2.ignoreVerticalAlignmentInTextboxes));
    }
    if (options2.useAnsiKerningPairs) {
      this.root.push(new OnOffElement("w:useAnsiKerningPairs", options2.useAnsiKerningPairs));
    }
    if (options2.cachedColumnBalance) {
      this.root.push(new OnOffElement("w:cachedColBalance", options2.cachedColumnBalance));
    }
  }
}

class SettingsAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable"
    });
  }
}

class Settings extends XmlComponent {
  constructor(options2) {
    var _a, _b, _c, _d;
    super("w:settings");
    this.root.push(new SettingsAttributes({
      wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
      mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
      o: "urn:schemas-microsoft-com:office:office",
      r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
      v: "urn:schemas-microsoft-com:vml",
      wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
      wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
      w10: "urn:schemas-microsoft-com:office:word",
      w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
      w14: "http://schemas.microsoft.com/office/word/2010/wordml",
      w15: "http://schemas.microsoft.com/office/word/2012/wordml",
      wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
      wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
      wne: "http://schemas.microsoft.com/office/word/2006/wordml",
      wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
      Ignorable: "w14 w15 wp14"
    }));
    this.root.push(new OnOffElement("w:displayBackgroundShape", true));
    if (options2.trackRevisions !== undefined) {
      this.root.push(new OnOffElement("w:trackRevisions", options2.trackRevisions));
    }
    if (options2.evenAndOddHeaders !== undefined) {
      this.root.push(new OnOffElement("w:evenAndOddHeaders", options2.evenAndOddHeaders));
    }
    if (options2.updateFields !== undefined) {
      this.root.push(new OnOffElement("w:updateFields", options2.updateFields));
    }
    if (options2.defaultTabStop !== undefined) {
      this.root.push(new NumberValueElement("w:defaultTabStop", options2.defaultTabStop));
    }
    this.root.push(new Compatibility(__spreadProps(__spreadValues({}, (_a = options2.compatibility) != null ? _a : {}), {
      version: (_d = (_c = (_b = options2.compatibility) == null ? undefined : _b.version) != null ? _c : options2.compatibilityModeVersion) != null ? _d : 15
    })));
  }
}

class ComponentAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", { val: "w:val" });
  }
}

class Name extends XmlComponent {
  constructor(value) {
    super("w:name");
    this.root.push(new ComponentAttributes({ val: value }));
  }
}

class UiPriority extends XmlComponent {
  constructor(value) {
    super("w:uiPriority");
    this.root.push(new ComponentAttributes({ val: decimalNumber(value) }));
  }
}

class StyleAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      type: "w:type",
      styleId: "w:styleId",
      default: "w:default",
      customStyle: "w:customStyle"
    });
  }
}

class Style2 extends XmlComponent {
  constructor(attributes, options2) {
    super("w:style");
    this.root.push(new StyleAttributes(attributes));
    if (options2.name) {
      this.root.push(new Name(options2.name));
    }
    if (options2.basedOn) {
      this.root.push(new StringValueElement("w:basedOn", options2.basedOn));
    }
    if (options2.next) {
      this.root.push(new StringValueElement("w:next", options2.next));
    }
    if (options2.link) {
      this.root.push(new StringValueElement("w:link", options2.link));
    }
    if (options2.uiPriority !== undefined) {
      this.root.push(new UiPriority(options2.uiPriority));
    }
    if (options2.semiHidden !== undefined) {
      this.root.push(new OnOffElement("w:semiHidden", options2.semiHidden));
    }
    if (options2.unhideWhenUsed !== undefined) {
      this.root.push(new OnOffElement("w:unhideWhenUsed", options2.unhideWhenUsed));
    }
    if (options2.quickFormat !== undefined) {
      this.root.push(new OnOffElement("w:qFormat", options2.quickFormat));
    }
  }
}

class StyleForParagraph extends Style2 {
  constructor(options2) {
    super({ type: "paragraph", styleId: options2.id }, options2);
    __publicField(this, "paragraphProperties");
    __publicField(this, "runProperties");
    this.paragraphProperties = new ParagraphProperties(options2.paragraph);
    this.runProperties = new RunProperties(options2.run);
    this.root.push(this.paragraphProperties);
    this.root.push(this.runProperties);
  }
}

class StyleForCharacter extends Style2 {
  constructor(options2) {
    super({ type: "character", styleId: options2.id }, __spreadValues({
      uiPriority: 99,
      unhideWhenUsed: true
    }, options2));
    __publicField(this, "runProperties");
    this.runProperties = new RunProperties(options2.run);
    this.root.push(this.runProperties);
  }
}

class HeadingStyle extends StyleForParagraph {
  constructor(options2) {
    super(__spreadValues({
      basedOn: "Normal",
      next: "Normal",
      quickFormat: true
    }, options2));
  }
}

class TitleStyle extends HeadingStyle {
  constructor(options2) {
    super(__spreadValues({
      id: "Title",
      name: "Title"
    }, options2));
  }
}

class Heading1Style extends HeadingStyle {
  constructor(options2) {
    super(__spreadValues({
      id: "Heading1",
      name: "Heading 1"
    }, options2));
  }
}

class Heading2Style extends HeadingStyle {
  constructor(options2) {
    super(__spreadValues({
      id: "Heading2",
      name: "Heading 2"
    }, options2));
  }
}

class Heading3Style extends HeadingStyle {
  constructor(options2) {
    super(__spreadValues({
      id: "Heading3",
      name: "Heading 3"
    }, options2));
  }
}

class Heading4Style extends HeadingStyle {
  constructor(options2) {
    super(__spreadValues({
      id: "Heading4",
      name: "Heading 4"
    }, options2));
  }
}

class Heading5Style extends HeadingStyle {
  constructor(options2) {
    super(__spreadValues({
      id: "Heading5",
      name: "Heading 5"
    }, options2));
  }
}

class Heading6Style extends HeadingStyle {
  constructor(options2) {
    super(__spreadValues({
      id: "Heading6",
      name: "Heading 6"
    }, options2));
  }
}

class StrongStyle extends HeadingStyle {
  constructor(options2) {
    super(__spreadValues({
      id: "Strong",
      name: "Strong"
    }, options2));
  }
}

class ListParagraph extends StyleForParagraph {
  constructor(options2) {
    super(__spreadValues({
      id: "ListParagraph",
      name: "List Paragraph",
      basedOn: "Normal",
      quickFormat: true
    }, options2));
  }
}

class FootnoteText extends StyleForParagraph {
  constructor(options2) {
    super(__spreadValues({
      id: "FootnoteText",
      name: "footnote text",
      link: "FootnoteTextChar",
      basedOn: "Normal",
      uiPriority: 99,
      semiHidden: true,
      unhideWhenUsed: true,
      paragraph: {
        spacing: {
          after: 0,
          line: 240,
          lineRule: LineRuleType.AUTO
        }
      },
      run: {
        size: 20
      }
    }, options2));
  }
}

class FootnoteReferenceStyle extends StyleForCharacter {
  constructor(options2) {
    super(__spreadValues({
      id: "FootnoteReference",
      name: "footnote reference",
      basedOn: "DefaultParagraphFont",
      semiHidden: true,
      run: {
        superScript: true
      }
    }, options2));
  }
}

class FootnoteTextChar extends StyleForCharacter {
  constructor(options2) {
    super(__spreadValues({
      id: "FootnoteTextChar",
      name: "Footnote Text Char",
      basedOn: "DefaultParagraphFont",
      link: "FootnoteText",
      semiHidden: true,
      run: {
        size: 20
      }
    }, options2));
  }
}

class HyperlinkStyle extends StyleForCharacter {
  constructor(options2) {
    super(__spreadValues({
      id: "Hyperlink",
      name: "Hyperlink",
      basedOn: "DefaultParagraphFont",
      run: {
        color: "0563C1",
        underline: {
          type: UnderlineType.SINGLE
        }
      }
    }, options2));
  }
}

class Styles extends XmlComponent {
  constructor(options2) {
    super("w:styles");
    if (options2.initialStyles) {
      this.root.push(options2.initialStyles);
    }
    if (options2.importedStyles) {
      for (const style of options2.importedStyles) {
        this.root.push(style);
      }
    }
    if (options2.paragraphStyles) {
      for (const style of options2.paragraphStyles) {
        this.root.push(new StyleForParagraph(style));
      }
    }
    if (options2.characterStyles) {
      for (const style of options2.characterStyles) {
        this.root.push(new StyleForCharacter(style));
      }
    }
  }
}

class ParagraphPropertiesDefaults extends XmlComponent {
  constructor(options2) {
    super("w:pPrDefault");
    this.root.push(new ParagraphProperties(options2));
  }
}

class RunPropertiesDefaults extends XmlComponent {
  constructor(options2) {
    super("w:rPrDefault");
    this.root.push(new RunProperties(options2));
  }
}

class DocumentDefaults extends XmlComponent {
  constructor(options2) {
    super("w:docDefaults");
    __publicField(this, "runPropertiesDefaults");
    __publicField(this, "paragraphPropertiesDefaults");
    this.runPropertiesDefaults = new RunPropertiesDefaults(options2.run);
    this.paragraphPropertiesDefaults = new ParagraphPropertiesDefaults(options2.paragraph);
    this.root.push(this.runPropertiesDefaults);
    this.root.push(this.paragraphPropertiesDefaults);
  }
}

class ExternalStylesFactory {
  newInstance(xmlData) {
    const xmlObj = lib.xml2js(xmlData, { compact: false });
    let stylesXmlElement;
    for (const xmlElm of xmlObj.elements || []) {
      if (xmlElm.name === "w:styles") {
        stylesXmlElement = xmlElm;
      }
    }
    if (stylesXmlElement === undefined) {
      throw new Error("can not find styles element");
    }
    const stylesElements = stylesXmlElement.elements || [];
    const importedStyle = new Styles({
      initialStyles: new ImportedRootElementAttributes(stylesXmlElement.attributes),
      importedStyles: stylesElements.map((childElm) => convertToXmlComponent(childElm))
    });
    return importedStyle;
  }
}

class DefaultStylesFactory {
  newInstance(options2 = {}) {
    var _a;
    const documentAttributes = new DocumentAttributes({
      mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
      r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
      w14: "http://schemas.microsoft.com/office/word/2010/wordml",
      w15: "http://schemas.microsoft.com/office/word/2012/wordml",
      Ignorable: "w14 w15"
    });
    return {
      initialStyles: documentAttributes,
      importedStyles: [
        new DocumentDefaults((_a = options2.document) != null ? _a : {}),
        new TitleStyle(__spreadValues({
          run: {
            size: 56
          }
        }, options2.title)),
        new Heading1Style(__spreadValues({
          run: {
            color: "2E74B5",
            size: 32
          }
        }, options2.heading1)),
        new Heading2Style(__spreadValues({
          run: {
            color: "2E74B5",
            size: 26
          }
        }, options2.heading2)),
        new Heading3Style(__spreadValues({
          run: {
            color: "1F4D78",
            size: 24
          }
        }, options2.heading3)),
        new Heading4Style(__spreadValues({
          run: {
            color: "2E74B5",
            italics: true
          }
        }, options2.heading4)),
        new Heading5Style(__spreadValues({
          run: {
            color: "2E74B5"
          }
        }, options2.heading5)),
        new Heading6Style(__spreadValues({
          run: {
            color: "1F4D78"
          }
        }, options2.heading6)),
        new StrongStyle(__spreadValues({
          run: {
            bold: true
          }
        }, options2.strong)),
        new ListParagraph(options2.listParagraph || {}),
        new HyperlinkStyle(options2.hyperlink || {}),
        new FootnoteReferenceStyle(options2.footnoteReference || {}),
        new FootnoteText(options2.footnoteText || {}),
        new FootnoteTextChar(options2.footnoteTextChar || {})
      ]
    };
  }
}
var createFontRelationship = ({ id, fontKey, subsetted }, name) => new BuilderElement({
  name,
  attributes: __spreadValues({
    id: { key: "r:id", value: id }
  }, fontKey ? { fontKey: { key: "w:fontKey", value: `{${fontKey}}` } } : {}),
  children: [...subsetted ? [new OnOffElement("w:subsetted", subsetted)] : []]
});
var createFont = ({
  name,
  altName,
  panose1,
  charset,
  family,
  notTrueType,
  pitch,
  sig,
  embedRegular,
  embedBold,
  embedItalic,
  embedBoldItalic
}) => new BuilderElement({
  name: "w:font",
  attributes: {
    name: { key: "w:name", value: name }
  },
  children: [
    ...altName ? [createStringElement("w:altName", altName)] : [],
    ...panose1 ? [createStringElement("w:panose1", panose1)] : [],
    ...charset ? [createStringElement("w:charset", charset)] : [],
    ...family ? [createStringElement("w:family", family)] : [],
    ...notTrueType ? [new OnOffElement("w:notTrueType", notTrueType)] : [],
    ...pitch ? [createStringElement("w:pitch", pitch)] : [],
    ...sig ? [
      new BuilderElement({
        name: "w:sig",
        attributes: {
          usb0: { key: "w:usb0", value: sig.usb0 },
          usb1: { key: "w:usb1", value: sig.usb1 },
          usb2: { key: "w:usb2", value: sig.usb2 },
          usb3: { key: "w:usb3", value: sig.usb3 },
          csb0: { key: "w:csb0", value: sig.csb0 },
          csb1: { key: "w:csb1", value: sig.csb1 }
        }
      })
    ] : [],
    ...embedRegular ? [createFontRelationship(embedRegular, "w:embedRegular")] : [],
    ...embedBold ? [createFontRelationship(embedBold, "w:embedBold")] : [],
    ...embedItalic ? [createFontRelationship(embedItalic, "w:embedItalic")] : [],
    ...embedBoldItalic ? [createFontRelationship(embedBoldItalic, "w:embedBoldItalic")] : []
  ]
});
var createRegularFont = ({
  name,
  index: index2,
  fontKey,
  characterSet
}) => createFont({
  name,
  sig: {
    usb0: "E0002AFF",
    usb1: "C000247B",
    usb2: "00000009",
    usb3: "00000000",
    csb0: "000001FF",
    csb1: "00000000"
  },
  charset: characterSet,
  family: "auto",
  pitch: "variable",
  embedRegular: {
    fontKey,
    id: `rId${index2}`
  }
});
var createFontTable = (fonts) => new BuilderElement({
  name: "w:fonts",
  attributes: {
    mc: { key: "xmlns:mc", value: "http://schemas.openxmlformats.org/markup-compatibility/2006" },
    r: { key: "xmlns:r", value: "http://schemas.openxmlformats.org/officeDocument/2006/relationships" },
    w: { key: "xmlns:w", value: "http://schemas.openxmlformats.org/wordprocessingml/2006/main" },
    w14: { key: "xmlns:w14", value: "http://schemas.microsoft.com/office/word/2010/wordml" },
    w15: { key: "xmlns:w15", value: "http://schemas.microsoft.com/office/word/2012/wordml" },
    w16cex: { key: "xmlns:w16cex", value: "http://schemas.microsoft.com/office/word/2018/wordml/cex" },
    w16cid: { key: "xmlns:w16cid", value: "http://schemas.microsoft.com/office/word/2016/wordml/cid" },
    w16: { key: "xmlns:w16", value: "http://schemas.microsoft.com/office/word/2018/wordml" },
    w16sdtdh: { key: "xmlns:w16sdtdh", value: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" },
    w16se: { key: "xmlns:w16se", value: "http://schemas.microsoft.com/office/word/2015/wordml/symex" },
    Ignorable: { key: "mc:Ignorable", value: "w14 w15 w16se w16cid w16 w16cex w16sdtdh" }
  },
  children: fonts.map((font, i) => createRegularFont({
    name: font.name,
    index: i + 1,
    fontKey: font.fontKey
  }))
});

class FontWrapper {
  constructor(options2) {
    __publicField(this, "fontTable");
    __publicField(this, "relationships");
    __publicField(this, "fontOptionsWithKey", []);
    this.options = options2;
    this.fontOptionsWithKey = options2.map((o) => __spreadProps(__spreadValues({}, o), { fontKey: uniqueUuid() }));
    this.fontTable = createFontTable(this.fontOptionsWithKey);
    this.relationships = new Relationships;
    for (let i = 0;i < options2.length; i++) {
      this.relationships.createRelationship(i + 1, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/font", `fonts/${options2[i].name}.odttf`);
    }
  }
  get View() {
    return this.fontTable;
  }
  get Relationships() {
    return this.relationships;
  }
}

class File {
  constructor(options2) {
    __publicField(this, "currentRelationshipId", 1);
    __publicField(this, "documentWrapper");
    __publicField(this, "headers", []);
    __publicField(this, "footers", []);
    __publicField(this, "coreProperties");
    __publicField(this, "numbering");
    __publicField(this, "media");
    __publicField(this, "fileRelationships");
    __publicField(this, "footnotesWrapper");
    __publicField(this, "settings");
    __publicField(this, "contentTypes");
    __publicField(this, "customProperties");
    __publicField(this, "appProperties");
    __publicField(this, "styles");
    __publicField(this, "comments");
    __publicField(this, "fontWrapper");
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.coreProperties = new CoreProperties(__spreadProps(__spreadValues({}, options2), {
      creator: (_a = options2.creator) != null ? _a : "Un-named",
      revision: (_b = options2.revision) != null ? _b : 1,
      lastModifiedBy: (_c = options2.lastModifiedBy) != null ? _c : "Un-named"
    }));
    this.numbering = new Numbering(options2.numbering ? options2.numbering : { config: [] });
    this.comments = new Comments((_d = options2.comments) != null ? _d : { children: [] });
    this.fileRelationships = new Relationships;
    this.customProperties = new CustomProperties((_e = options2.customProperties) != null ? _e : []);
    this.appProperties = new AppProperties;
    this.footnotesWrapper = new FootnotesWrapper;
    this.contentTypes = new ContentTypes;
    this.documentWrapper = new DocumentWrapper({ background: options2.background });
    this.settings = new Settings({
      compatibilityModeVersion: options2.compatabilityModeVersion,
      compatibility: options2.compatibility,
      evenAndOddHeaders: options2.evenAndOddHeaderAndFooters ? true : false,
      trackRevisions: (_f = options2.features) == null ? undefined : _f.trackRevisions,
      updateFields: (_g = options2.features) == null ? undefined : _g.updateFields,
      defaultTabStop: options2.defaultTabStop
    });
    this.media = new Media;
    if (options2.externalStyles !== undefined) {
      const stylesFactory = new ExternalStylesFactory;
      this.styles = stylesFactory.newInstance(options2.externalStyles);
    } else if (options2.styles) {
      const stylesFactory = new DefaultStylesFactory;
      const defaultStyles = stylesFactory.newInstance(options2.styles.default);
      this.styles = new Styles(__spreadValues(__spreadValues({}, defaultStyles), options2.styles));
    } else {
      const stylesFactory = new DefaultStylesFactory;
      this.styles = new Styles(stylesFactory.newInstance());
    }
    this.addDefaultRelationships();
    for (const section of options2.sections) {
      this.addSection(section);
    }
    if (options2.footnotes) {
      for (const key in options2.footnotes) {
        this.footnotesWrapper.View.createFootNote(parseFloat(key), options2.footnotes[key].children);
      }
    }
    this.fontWrapper = new FontWrapper((_h = options2.fonts) != null ? _h : []);
  }
  addSection({ headers = {}, footers = {}, children, properties }) {
    this.documentWrapper.View.Body.addSection(__spreadProps(__spreadValues({}, properties), {
      headerWrapperGroup: {
        default: headers.default ? this.createHeader(headers.default) : undefined,
        first: headers.first ? this.createHeader(headers.first) : undefined,
        even: headers.even ? this.createHeader(headers.even) : undefined
      },
      footerWrapperGroup: {
        default: footers.default ? this.createFooter(footers.default) : undefined,
        first: footers.first ? this.createFooter(footers.first) : undefined,
        even: footers.even ? this.createFooter(footers.even) : undefined
      }
    }));
    for (const child of children) {
      this.documentWrapper.View.add(child);
    }
  }
  createHeader(header) {
    const wrapper = new HeaderWrapper(this.media, this.currentRelationshipId++);
    for (const child of header.options.children) {
      wrapper.add(child);
    }
    this.addHeaderToDocument(wrapper);
    return wrapper;
  }
  createFooter(footer) {
    const wrapper = new FooterWrapper(this.media, this.currentRelationshipId++);
    for (const child of footer.options.children) {
      wrapper.add(child);
    }
    this.addFooterToDocument(wrapper);
    return wrapper;
  }
  addHeaderToDocument(header, type = HeaderFooterReferenceType.DEFAULT) {
    this.headers.push({ header, type });
    this.documentWrapper.Relationships.createRelationship(header.View.ReferenceId, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header", `header${this.headers.length}.xml`);
    this.contentTypes.addHeader(this.headers.length);
  }
  addFooterToDocument(footer, type = HeaderFooterReferenceType.DEFAULT) {
    this.footers.push({ footer, type });
    this.documentWrapper.Relationships.createRelationship(footer.View.ReferenceId, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer", `footer${this.footers.length}.xml`);
    this.contentTypes.addFooter(this.footers.length);
  }
  addDefaultRelationships() {
    this.fileRelationships.createRelationship(1, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument", "word/document.xml");
    this.fileRelationships.createRelationship(2, "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties", "docProps/core.xml");
    this.fileRelationships.createRelationship(3, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties", "docProps/app.xml");
    this.fileRelationships.createRelationship(4, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties", "docProps/custom.xml");
    this.documentWrapper.Relationships.createRelationship(this.currentRelationshipId++, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", "styles.xml");
    this.documentWrapper.Relationships.createRelationship(this.currentRelationshipId++, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering", "numbering.xml");
    this.documentWrapper.Relationships.createRelationship(this.currentRelationshipId++, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes", "footnotes.xml");
    this.documentWrapper.Relationships.createRelationship(this.currentRelationshipId++, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings", "settings.xml");
    this.documentWrapper.Relationships.createRelationship(this.currentRelationshipId++, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments", "comments.xml");
  }
  get Document() {
    return this.documentWrapper;
  }
  get Styles() {
    return this.styles;
  }
  get CoreProperties() {
    return this.coreProperties;
  }
  get Numbering() {
    return this.numbering;
  }
  get Media() {
    return this.media;
  }
  get FileRelationships() {
    return this.fileRelationships;
  }
  get Headers() {
    return this.headers.map((item) => item.header);
  }
  get Footers() {
    return this.footers.map((item) => item.footer);
  }
  get ContentTypes() {
    return this.contentTypes;
  }
  get CustomProperties() {
    return this.customProperties;
  }
  get AppProperties() {
    return this.appProperties;
  }
  get FootNotes() {
    return this.footnotesWrapper;
  }
  get Settings() {
    return this.settings;
  }
  get Comments() {
    return this.comments;
  }
  get FontTable() {
    return this.fontWrapper;
  }
}
class StructuredDocumentTagContent extends XmlComponent {
  constructor() {
    super("w:sdtContent");
  }
}

class StructuredDocumentTagProperties extends XmlComponent {
  constructor(alias) {
    super("w:sdtPr");
    if (alias) {
      this.root.push(new StringValueElement("w:alias", alias));
    }
  }
}
class FootNoteReferenceRunAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      id: "w:id"
    });
  }
}

class FootnoteReference extends XmlComponent {
  constructor(id) {
    super("w:footnoteReference");
    this.root.push(new FootNoteReferenceRunAttributes({
      id
    }));
  }
}

class FootnoteReferenceRun extends Run {
  constructor(id) {
    super({ style: "FootnoteReference" });
    this.root.push(new FootnoteReference(id));
  }
}
class CheckboxSymbolAttributes extends XmlAttributeComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "xmlKeys", {
      val: "w14:val",
      symbolfont: "w14:font"
    });
  }
}

class CheckBoxSymbolElement extends XmlComponent {
  constructor(name, val, font) {
    super(name);
    if (font) {
      this.root.push(new CheckboxSymbolAttributes({ val: shortHexNumber(val), symbolfont: font }));
    } else {
      this.root.push(new CheckboxSymbolAttributes({ val }));
    }
  }
}

class CheckBoxUtil extends XmlComponent {
  constructor(options2) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    super("w14:checkbox");
    __publicField(this, "DEFAULT_UNCHECKED_SYMBOL", "2610");
    __publicField(this, "DEFAULT_CHECKED_SYMBOL", "2612");
    __publicField(this, "DEFAULT_FONT", "MS Gothic");
    const value = (options2 == null ? undefined : options2.checked) ? "1" : "0";
    let symbol;
    let font;
    this.root.push(new CheckBoxSymbolElement("w14:checked", value));
    symbol = ((_a = options2 == null ? undefined : options2.checkedState) == null ? undefined : _a.value) ? (_b = options2 == null ? undefined : options2.checkedState) == null ? undefined : _b.value : this.DEFAULT_CHECKED_SYMBOL;
    font = ((_c = options2 == null ? undefined : options2.checkedState) == null ? undefined : _c.font) ? (_d = options2 == null ? undefined : options2.checkedState) == null ? undefined : _d.font : this.DEFAULT_FONT;
    this.root.push(new CheckBoxSymbolElement("w14:checkedState", symbol, font));
    symbol = ((_e = options2 == null ? undefined : options2.uncheckedState) == null ? undefined : _e.value) ? (_f = options2 == null ? undefined : options2.uncheckedState) == null ? undefined : _f.value : this.DEFAULT_UNCHECKED_SYMBOL;
    font = ((_g = options2 == null ? undefined : options2.uncheckedState) == null ? undefined : _g.font) ? (_h = options2 == null ? undefined : options2.uncheckedState) == null ? undefined : _h.font : this.DEFAULT_FONT;
    this.root.push(new CheckBoxSymbolElement("w14:uncheckedState", symbol, font));
  }
}

class CheckBox extends XmlComponent {
  constructor(options2) {
    var _a, _b, _c, _d;
    super("w:sdt");
    __publicField(this, "DEFAULT_UNCHECKED_SYMBOL", "2610");
    __publicField(this, "DEFAULT_CHECKED_SYMBOL", "2612");
    __publicField(this, "DEFAULT_FONT", "MS Gothic");
    const properties = new StructuredDocumentTagProperties(options2 == null ? undefined : options2.alias);
    properties.addChildElement(new CheckBoxUtil(options2));
    this.root.push(properties);
    const content3 = new StructuredDocumentTagContent;
    const checkedFont = (_a = options2 == null ? undefined : options2.checkedState) == null ? undefined : _a.font;
    const checkedText = (_b = options2 == null ? undefined : options2.checkedState) == null ? undefined : _b.value;
    const uncheckedFont = (_c = options2 == null ? undefined : options2.uncheckedState) == null ? undefined : _c.font;
    const uncheckedText = (_d = options2 == null ? undefined : options2.uncheckedState) == null ? undefined : _d.value;
    let symbolFont;
    let char;
    if (options2 == null ? undefined : options2.checked) {
      symbolFont = checkedFont ? checkedFont : this.DEFAULT_FONT;
      char = checkedText ? checkedText : this.DEFAULT_CHECKED_SYMBOL;
    } else {
      symbolFont = uncheckedFont ? uncheckedFont : this.DEFAULT_FONT;
      char = uncheckedText ? uncheckedText : this.DEFAULT_UNCHECKED_SYMBOL;
    }
    const initialRenderedChar = new SymbolRun({
      char,
      symbolfont: symbolFont
    });
    content3.addChildElement(initialRenderedChar);
    this.root.push(content3);
  }
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
(function(module, exports) {
  (function(e) {
    module.exports = e();
  })(function() {
    return function s(a, o, h) {
      function u(r, e2) {
        if (!o[r]) {
          if (!a[r]) {
            var t = typeof commonjsRequire == "function" && commonjsRequire;
            if (!e2 && t)
              return t(r, true);
            if (l)
              return l(r, true);
            var n = new Error("Cannot find module '" + r + "'");
            throw n.code = "MODULE_NOT_FOUND", n;
          }
          var i = o[r] = { exports: {} };
          a[r][0].call(i.exports, function(e3) {
            var t2 = a[r][1][e3];
            return u(t2 || e3);
          }, i, i.exports, s, a, o, h);
        }
        return o[r].exports;
      }
      for (var l = typeof commonjsRequire == "function" && commonjsRequire, e = 0;e < h.length; e++)
        u(h[e]);
      return u;
    }({ 1: [function(e, t, r) {
      var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(e2) {
        for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = d.getTypeOf(e2) !== "string";u < e2.length; )
          f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
        return h.join("");
      }, r.decode = function(e2) {
        var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
        if (e2.substr(0, u.length) === u)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f);o < e2.length; )
          t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, s !== 64 && (l[h++] = r2), a !== 64 && (l[h++] = n);
        return l;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
      var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
      function o(e2, t2, r2, n2, i2) {
        this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
      }
      o.prototype = { getContentWorker: function() {
        var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
        return e2.on("end", function() {
          if (this.streamInfo.data_length !== t2.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), e2;
      }, getCompressedWorker: function() {
        return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o.createWorkerFrom = function(e2, t2, r2) {
        return e2.pipe(new s).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
      }, t.exports = o;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
      var n = e("./stream/GenericWorker");
      r.STORE = { magic: "\x00\x00", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, r.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
      var n = e("./utils");
      var o = function() {
        for (var e2, t2 = [], r2 = 0;r2 < 256; r2++) {
          e2 = r2;
          for (var n2 = 0;n2 < 8; n2++)
            e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[r2] = e2;
        }
        return t2;
      }();
      t.exports = function(e2, t2) {
        return e2 !== undefined && e2.length ? n.getTypeOf(e2) !== "string" ? function(e3, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2;a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
          return -1 ^ e3;
        }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2;a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
          return -1 ^ e3;
        }(0 | t2, e2, e2.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, t, r) {
      r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e, t, r) {
      var n = null;
      n = typeof Promise != "undefined" ? Promise : e("lie"), t.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(e, t, r) {
      var n = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
      function h(e2, t2) {
        a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
      }
      r.magic = "\b\x00", s.inherits(h, a), h.prototype.processChunk = function(e2) {
        this.meta = e2.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var t2 = this;
        this._pako.onData = function(e2) {
          t2.push({ data: e2, meta: t2.meta });
        };
      }, r.compressWorker = function(e2) {
        return new h("Deflate", e2);
      }, r.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
      function A(e2, t2) {
        var r2, n2 = "";
        for (r2 = 0;r2 < t2; r2++)
          n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
        return n2;
      }
      function n(e2, t2, r2, n2, i2, s2) {
        var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
        var S = 0;
        t2 && (S |= 8), l || !_ && !g || (S |= 2048);
        var z = 0, C = 0;
        w && (z |= 16), i2 === "UNIX" ? (C = 798, z |= function(e3, t3) {
          var r3 = e3;
          return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
        }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
          return 63 & (e3 || 0);
        }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
        var E = "";
        return E += `
\x00`, E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R2.LOCAL_FILE_HEADER + E + f + b, dirRecord: R2.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\x00\x00\x00\x00" + A(z, 4) + A(n2, 4) + f + b + p };
      }
      var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R2 = e("../signature");
      function s(e2, t2, r2, n2) {
        i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I.inherits(s, i), s.prototype.push = function(e2) {
        var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
      }, s.prototype.openedSource = function(e2) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
        var t2 = this.streamFiles && !e2.file.dir;
        if (t2) {
          var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r2.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s.prototype.closedSource = function(e2) {
        this.accumulate = false;
        var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r2.dirRecord), t2)
          this.push({ data: function(e3) {
            return R2.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
          }(e2), meta: { percent: 100 } });
        else
          for (this.push({ data: r2.fileRecord, meta: { percent: 0 } });this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s.prototype.flush = function() {
        for (var e2 = this.bytesWritten, t2 = 0;t2 < this.dirRecords.length; t2++)
          this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
        var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
          var s2 = I.transformTo("string", i2(n3));
          return R2.CENTRAL_DIRECTORY_END + "\x00\x00\x00\x00" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
        }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
        this.push({ data: n2, meta: { percent: 100 } });
      }, s.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s.prototype.registerPrevious = function(e2) {
        this._sources.push(e2);
        var t2 = this;
        return e2.on("data", function(e3) {
          t2.processChunk(e3);
        }), e2.on("end", function() {
          t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
        }), e2.on("error", function(e3) {
          t2.error(e3);
        }), this;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? undefined : (this.end(), true));
      }, s.prototype.error = function(e2) {
        var t2 = this._sources;
        if (!i.prototype.error.call(this, e2))
          return false;
        for (var r2 = 0;r2 < t2.length; r2++)
          try {
            t2[r2].error(e2);
          } catch (e3) {}
        return true;
      }, s.prototype.lock = function() {
        i.prototype.lock.call(this);
        for (var e2 = this._sources, t2 = 0;t2 < e2.length; t2++)
          e2[t2].lock();
      }, t.exports = s;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
      var u = e("../compressions"), n = e("./ZipFileWorker");
      r.generateWorker = function(e2, a, t2) {
        var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
        try {
          e2.forEach(function(e3, t3) {
            h++;
            var r2 = function(e4, t4) {
              var r3 = e4 || t4, n3 = u[r3];
              if (!n3)
                throw new Error(r3 + " is not a valid compression method !");
              return n3;
            }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
            t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
          }), o.entriesCount = h;
        } catch (e3) {
          o.error(e3);
        }
        return o;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
      function n() {
        if (!(this instanceof n))
          return new n;
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var e2 = new n;
          for (var t2 in this)
            typeof this[t2] != "function" && (e2[t2] = this[t2]);
          return e2;
        };
      }
      (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
        return new n().loadAsync(e2, t2);
      }, n.external = e("./external"), t.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
      var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
      function f(n2) {
        return new i.Promise(function(e2, t2) {
          var r2 = n2.decompressed.getContentWorker().pipe(new a);
          r2.on("error", function(e3) {
            t2(e3);
          }).on("end", function() {
            r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
          }).resume();
        });
      }
      t.exports = function(e2, o) {
        var h = this;
        return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
          var t2 = new s(o);
          return t2.load(e3), t2;
        }).then(function(e3) {
          var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
          if (o.checkCRC32)
            for (var n2 = 0;n2 < r2.length; n2++)
              t2.push(f(r2[n2]));
          return i.Promise.all(t2);
        }).then(function(e3) {
          for (var t2 = e3.shift(), r2 = t2.files, n2 = 0;n2 < r2.length; n2++) {
            var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
            h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
          }
          return t2.zipComment.length && (h.comment = t2.zipComment), h;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
      var n = e("../utils"), i = e("../stream/GenericWorker");
      function s(e2, t2) {
        i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
      }
      n.inherits(s, i), s.prototype._bindStream = function(e2) {
        var t2 = this;
        (this._stream = e2).pause(), e2.on("data", function(e3) {
          t2.push({ data: e3, meta: { percent: 0 } });
        }).on("error", function(e3) {
          t2.isPaused ? this.generatedError = e3 : t2.error(e3);
        }).on("end", function() {
          t2.isPaused ? t2._upstreamEnded = true : t2.end();
        });
      }, s.prototype.pause = function() {
        return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, t.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
      var i = e("readable-stream").Readable;
      function n(e2, t2, r2) {
        i.call(this, t2), this._helper = e2;
        var n2 = this;
        e2.on("data", function(e3, t3) {
          n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
        }).on("error", function(e3) {
          n2.emit("error", e3);
        }).on("end", function() {
          n2.push(null);
        });
      }
      e("../utils").inherits(n, i), n.prototype._read = function() {
        this._helper.resume();
      }, t.exports = n;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
      t.exports = { isNode: typeof Buffer != "undefined", newBufferFrom: function(e2, t2) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(e2, t2);
        if (typeof e2 == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(e2, t2);
      }, allocBuffer: function(e2) {
        if (Buffer.alloc)
          return Buffer.alloc(e2);
        var t2 = new Buffer(e2);
        return t2.fill(0), t2;
      }, isBuffer: function(e2) {
        return Buffer.isBuffer(e2);
      }, isStream: function(e2) {
        return e2 && typeof e2.on == "function" && typeof e2.pause == "function" && typeof e2.resume == "function";
      } };
    }, {}], 15: [function(e, t, r) {
      function s(e2, t2, r2) {
        var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
        s2.date = s2.date || /* @__PURE__ */ new Date, s2.compression !== null && (s2.compression = s2.compression.toUpperCase()), typeof s2.unixPermissions == "string" && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
        var a2 = i2 === "string" && s2.binary === false && s2.base64 === false;
        r2 && r2.binary !== undefined || (s2.binary = !a2), (t2 instanceof c && t2.uncompressedSize === 0 || s2.dir || !t2 || t2.length === 0) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
        var o2 = null;
        o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
        var h2 = new d(e2, o2, s2);
        this.files[e2] = h2;
      }
      var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
        e2.slice(-1) === "/" && (e2 = e2.substring(0, e2.length - 1));
        var t2 = e2.lastIndexOf("/");
        return 0 < t2 ? e2.substring(0, t2) : "";
      }, g = function(e2) {
        return e2.slice(-1) !== "/" && (e2 += "/"), e2;
      }, b = function(e2, t2) {
        return t2 = t2 !== undefined ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
      };
      function h(e2) {
        return Object.prototype.toString.call(e2) === "[object RegExp]";
      }
      var n = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(e2) {
        var t2, r2, n2;
        for (t2 in this.files)
          n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
      }, filter: function(r2) {
        var n2 = [];
        return this.forEach(function(e2, t2) {
          r2(e2, t2) && n2.push(t2);
        }), n2;
      }, file: function(e2, t2, r2) {
        if (arguments.length !== 1)
          return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
        if (h(e2)) {
          var n2 = e2;
          return this.filter(function(e3, t3) {
            return !t3.dir && n2.test(e3);
          });
        }
        var i2 = this.files[this.root + e2];
        return i2 && !i2.dir ? i2 : null;
      }, folder: function(r2) {
        if (!r2)
          return this;
        if (h(r2))
          return this.filter(function(e3, t3) {
            return t3.dir && r2.test(e3);
          });
        var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
        return n2.root = t2.name, n2;
      }, remove: function(r2) {
        r2 = this.root + r2;
        var e2 = this.files[r2];
        if (e2 || (r2.slice(-1) !== "/" && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
          delete this.files[r2];
        else
          for (var t2 = this.filter(function(e3, t3) {
            return t3.name.slice(0, r2.length) === r2;
          }), n2 = 0;n2 < t2.length; n2++)
            delete this.files[t2[n2].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(e2) {
        var t2, r2 = {};
        try {
          if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), r2.type === "binarystring" && (r2.type = "string"), !r2.type)
            throw new Error("No output type specified.");
          u.checkSupport(r2.type), r2.platform !== "darwin" && r2.platform !== "freebsd" && r2.platform !== "linux" && r2.platform !== "sunos" || (r2.platform = "UNIX"), r2.platform === "win32" && (r2.platform = "DOS");
          var n2 = r2.comment || this.comment || "";
          t2 = o.generateWorker(this, r2, n2);
        } catch (e3) {
          (t2 = new l("error")).error(e3);
        }
        return new a(t2, r2.type || "string", r2.mimeType);
      }, generateAsync: function(e2, t2) {
        return this.generateInternalStream(e2).accumulate(t2);
      }, generateNodeStream: function(e2, t2) {
        return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
      } };
      t.exports = n;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
      t.exports = e("stream");
    }, { stream: undefined }], 17: [function(e, t, r) {
      var n = e("./DataReader");
      function i(e2) {
        n.call(this, e2);
        for (var t2 = 0;t2 < this.data.length; t2++)
          e2[t2] = 255 & e2[t2];
      }
      e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
        return this.data[this.zero + e2];
      }, i.prototype.lastIndexOfSignature = function(e2) {
        for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4;0 <= s; --s)
          if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
            return s - this.zero;
        return -1;
      }, i.prototype.readAndCheckSignature = function(e2) {
        var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
        return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
      }, i.prototype.readData = function(e2) {
        if (this.checkOffset(e2), e2 === 0)
          return [];
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
      var n = e("../utils");
      function i(e2) {
        this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
      }
      i.prototype = { checkOffset: function(e2) {
        this.checkIndex(this.index + e2);
      }, checkIndex: function(e2) {
        if (this.length < this.zero + e2 || e2 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
      }, setIndex: function(e2) {
        this.checkIndex(e2), this.index = e2;
      }, skip: function(e2) {
        this.setIndex(this.index + e2);
      }, byteAt: function() {}, readInt: function(e2) {
        var t2, r2 = 0;
        for (this.checkOffset(e2), t2 = this.index + e2 - 1;t2 >= this.index; t2--)
          r2 = (r2 << 8) + this.byteAt(t2);
        return this.index += e2, r2;
      }, readString: function(e2) {
        return n.transformTo("string", this.readData(e2));
      }, readData: function() {}, lastIndexOfSignature: function() {}, readAndCheckSignature: function() {}, readDate: function() {
        var e2 = this.readInt(4);
        return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
      } }, t.exports = i;
    }, { "../utils": 32 }], 19: [function(e, t, r) {
      var n = e("./Uint8ArrayReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
        this.checkOffset(e2);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
      var n = e("./DataReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
        return this.data.charCodeAt(this.zero + e2);
      }, i.prototype.lastIndexOfSignature = function(e2) {
        return this.data.lastIndexOf(e2) - this.zero;
      }, i.prototype.readAndCheckSignature = function(e2) {
        return e2 === this.readData(4);
      }, i.prototype.readData = function(e2) {
        this.checkOffset(e2);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
      var n = e("./ArrayReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
        if (this.checkOffset(e2), e2 === 0)
          return new Uint8Array(0);
        var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
      var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
      t.exports = function(e2) {
        var t2 = n.getTypeOf(e2);
        return n.checkSupport(t2), t2 !== "string" || i.uint8array ? t2 === "nodebuffer" ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
      r.LOCAL_FILE_HEADER = "PK\x03\x04", r.CENTRAL_FILE_HEADER = "PK\x01\x02", r.CENTRAL_DIRECTORY_END = "PK\x05\x06", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, t, r) {
      var n = e("./GenericWorker"), i = e("../utils");
      function s(e2) {
        n.call(this, "ConvertWorker to " + e2), this.destType = e2;
      }
      i.inherits(s, n), s.prototype.processChunk = function(e2) {
        this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
      var n = e("./GenericWorker"), i = e("../crc32");
      function s() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
        this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
      }, t.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
      var n = e("../utils"), i = e("./GenericWorker");
      function s(e2) {
        i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
      }
      n.inherits(s, i), s.prototype.processChunk = function(e2) {
        if (e2) {
          var t2 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = t2 + e2.data.length;
        }
        i.prototype.processChunk.call(this, e2);
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
      var n = e("../utils"), i = e("./GenericWorker");
      function s(e2) {
        i.call(this, "DataWorker");
        var t2 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
          t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
        }, function(e3) {
          t2.error(e3);
        });
      }
      n.inherits(s, i), s.prototype.cleanUp = function() {
        i.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var e2 = null, t2 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            e2 = this.data.substring(this.index, t2);
            break;
          case "uint8array":
            e2 = this.data.subarray(this.index, t2);
            break;
          case "array":
          case "nodebuffer":
            e2 = this.data.slice(this.index, t2);
        }
        return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
      function n(e2) {
        this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(e2) {
        this.emit("data", e2);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (e2) {
          this.emit("error", e2);
        }
        return true;
      }, error: function(e2) {
        return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
      }, on: function(e2, t2) {
        return this._listeners[e2].push(t2), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(e2, t2) {
        if (this._listeners[e2])
          for (var r2 = 0;r2 < this._listeners[e2].length; r2++)
            this._listeners[e2][r2].call(this, t2);
      }, pipe: function(e2) {
        return e2.registerPrevious(this);
      }, registerPrevious: function(e2) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
        var t2 = this;
        return e2.on("data", function(e3) {
          t2.processChunk(e3);
        }), e2.on("end", function() {
          t2.end();
        }), e2.on("error", function(e3) {
          t2.error(e3);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var e2 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
      }, flush: function() {}, processChunk: function(e2) {
        this.push(e2);
      }, withStreamInfo: function(e2, t2) {
        return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var e2 in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var e2 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + e2 : e2;
      } }, t.exports = n;
    }, {}], 29: [function(e, t, r) {
      var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
      if (n.nodestream)
        try {
          o = e("../nodejs/NodejsStreamOutputAdapter");
        } catch (e2) {}
      function l(e2, o2) {
        return new a.Promise(function(t2, r2) {
          var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
          e2.on("data", function(e3, t3) {
            n2.push(e3), o2 && o2(t3);
          }).on("error", function(e3) {
            n2 = [], r2(e3);
          }).on("end", function() {
            try {
              var e3 = function(e4, t3, r3) {
                switch (e4) {
                  case "blob":
                    return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                  case "base64":
                    return u.encode(t3);
                  default:
                    return h.transformTo(e4, t3);
                }
              }(s2, function(e4, t3) {
                var r3, n3 = 0, i3 = null, s3 = 0;
                for (r3 = 0;r3 < t3.length; r3++)
                  s3 += t3[r3].length;
                switch (e4) {
                  case "string":
                    return t3.join("");
                  case "array":
                    return Array.prototype.concat.apply([], t3);
                  case "uint8array":
                    for (i3 = new Uint8Array(s3), r3 = 0;r3 < t3.length; r3++)
                      i3.set(t3[r3], n3), n3 += t3[r3].length;
                    return i3;
                  case "nodebuffer":
                    return Buffer.concat(t3);
                  default:
                    throw new Error("concat : unsupported type '" + e4 + "'");
                }
              }(i2, n2), a2);
              t2(e3);
            } catch (e4) {
              r2(e4);
            }
            n2 = [];
          }).resume();
        });
      }
      function f(e2, t2, r2) {
        var n2 = t2;
        switch (t2) {
          case "blob":
          case "arraybuffer":
            n2 = "uint8array";
            break;
          case "base64":
            n2 = "string";
        }
        try {
          this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
        } catch (e3) {
          this._worker = new s("error"), this._worker.error(e3);
        }
      }
      f.prototype = { accumulate: function(e2) {
        return l(this, e2);
      }, on: function(e2, t2) {
        var r2 = this;
        return e2 === "data" ? this._worker.on(e2, function(e3) {
          t2.call(r2, e3.data, e3.meta);
        }) : this._worker.on(e2, function() {
          h.delay(t2, arguments, r2);
        }), this;
      }, resume: function() {
        return h.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(e2) {
        if (h.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new o(this, { objectMode: this._outputType !== "nodebuffer" }, e2);
      } }, t.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
      if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", r.nodebuffer = typeof Buffer != "undefined", r.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined")
        r.blob = false;
      else {
        var n = new ArrayBuffer(0);
        try {
          r.blob = new Blob([n], { type: "application/zip" }).size === 0;
        } catch (e2) {
          try {
            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
            i.append(n), r.blob = i.getBlob("application/zip").size === 0;
          } catch (e3) {
            r.blob = false;
          }
        }
      }
      try {
        r.nodestream = !!e("readable-stream").Readable;
      } catch (e2) {
        r.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e, t, s) {
      for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0;i < 256; i++)
        u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
      u[254] = u[254] = 1;
      function a() {
        n.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l() {
        n.call(this, "utf-8 encode");
      }
      s.utf8encode = function(e2) {
        return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
          var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
          for (i2 = 0;i2 < a2; i2++)
            (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n2 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0;s2 < o2; i2++)
            (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n2 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }(e2);
      }, s.utf8decode = function(e2) {
        return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
          var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
          for (t2 = r2 = 0;t2 < s2; )
            if ((n2 = e3[t2++]) < 128)
              a2[r2++] = n2;
            else if (4 < (i2 = u[n2]))
              a2[r2++] = 65533, t2 += i2 - 1;
            else {
              for (n2 &= i2 === 2 ? 31 : i2 === 3 ? 15 : 7;1 < i2 && t2 < s2; )
                n2 = n2 << 6 | 63 & e3[t2++], i2--;
              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
            }
          return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
        }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
      }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
        var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
        if (this.leftOver && this.leftOver.length) {
          if (h.uint8array) {
            var r2 = t2;
            (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
          } else
            t2 = this.leftOver.concat(t2);
          this.leftOver = null;
        }
        var n2 = function(e3, t3) {
          var r3;
          for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1;0 <= r3 && (192 & e3[r3]) == 128; )
            r3--;
          return r3 < 0 ? t3 : r3 === 0 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
        }(t2), i2 = t2;
        n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
      }, a.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
        this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
      }, s.Utf8EncodeWorker = l;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
      var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
      function n(e2) {
        return e2;
      }
      function l(e2, t2) {
        for (var r2 = 0;r2 < e2.length; ++r2)
          t2[r2] = 255 & e2.charCodeAt(r2);
        return t2;
      }
      e("setimmediate"), a.newBlob = function(t2, r2) {
        a.checkSupport("blob");
        try {
          return new Blob([t2], { type: r2 });
        } catch (e2) {
          try {
            var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
            return n2.append(t2), n2.getBlob(r2);
          } catch (e3) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var i = { stringifyByChunk: function(e2, t2, r2) {
        var n2 = [], i2 = 0, s2 = e2.length;
        if (s2 <= r2)
          return String.fromCharCode.apply(null, e2);
        for (;i2 < s2; )
          t2 === "array" || t2 === "nodebuffer" ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
        return n2.join("");
      }, stringifyByChar: function(e2) {
        for (var t2 = "", r2 = 0;r2 < e2.length; r2++)
          t2 += String.fromCharCode(e2[r2]);
        return t2;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch (e2) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1;
        } catch (e2) {
          return false;
        }
      }() } };
      function s(e2) {
        var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
        if (r2 === "uint8array" ? n2 = i.applyCanBeUsed.uint8array : r2 === "nodebuffer" && (n2 = i.applyCanBeUsed.nodebuffer), n2)
          for (;1 < t2; )
            try {
              return i.stringifyByChunk(e2, r2, t2);
            } catch (e3) {
              t2 = Math.floor(t2 / 2);
            }
        return i.stringifyByChar(e2);
      }
      function f(e2, t2) {
        for (var r2 = 0;r2 < e2.length; r2++)
          t2[r2] = e2[r2];
        return t2;
      }
      a.applyFromCharCode = s;
      var c = {};
      c.string = { string: n, array: function(e2) {
        return l(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return c.string.uint8array(e2).buffer;
      }, uint8array: function(e2) {
        return l(e2, new Uint8Array(e2.length));
      }, nodebuffer: function(e2) {
        return l(e2, r.allocBuffer(e2.length));
      } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
        return new Uint8Array(e2).buffer;
      }, uint8array: function(e2) {
        return new Uint8Array(e2);
      }, nodebuffer: function(e2) {
        return r.newBufferFrom(e2);
      } }, c.arraybuffer = { string: function(e2) {
        return s(new Uint8Array(e2));
      }, array: function(e2) {
        return f(new Uint8Array(e2), new Array(e2.byteLength));
      }, arraybuffer: n, uint8array: function(e2) {
        return new Uint8Array(e2);
      }, nodebuffer: function(e2) {
        return r.newBufferFrom(new Uint8Array(e2));
      } }, c.uint8array = { string: s, array: function(e2) {
        return f(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return e2.buffer;
      }, uint8array: n, nodebuffer: function(e2) {
        return r.newBufferFrom(e2);
      } }, c.nodebuffer = { string: s, array: function(e2) {
        return f(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return c.nodebuffer.uint8array(e2).buffer;
      }, uint8array: function(e2) {
        return f(e2, new Uint8Array(e2.length));
      }, nodebuffer: n }, a.transformTo = function(e2, t2) {
        if (t2 = t2 || "", !e2)
          return t2;
        a.checkSupport(e2);
        var r2 = a.getTypeOf(t2);
        return c[r2][e2](t2);
      }, a.resolve = function(e2) {
        for (var t2 = e2.split("/"), r2 = [], n2 = 0;n2 < t2.length; n2++) {
          var i2 = t2[n2];
          i2 === "." || i2 === "" && n2 !== 0 && n2 !== t2.length - 1 || (i2 === ".." ? r2.pop() : r2.push(i2));
        }
        return r2.join("/");
      }, a.getTypeOf = function(e2) {
        return typeof e2 == "string" ? "string" : Object.prototype.toString.call(e2) === "[object Array]" ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : undefined;
      }, a.checkSupport = function(e2) {
        if (!o[e2.toLowerCase()])
          throw new Error(e2 + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
        var t2, r2, n2 = "";
        for (r2 = 0;r2 < (e2 || "").length; r2++)
          n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
        return n2;
      }, a.delay = function(e2, t2, r2) {
        setImmediate(function() {
          e2.apply(r2 || null, t2 || []);
        });
      }, a.inherits = function(e2, t2) {
        function r2() {}
        r2.prototype = t2.prototype, e2.prototype = new r2;
      }, a.extend = function() {
        var e2, t2, r2 = {};
        for (e2 = 0;e2 < arguments.length; e2++)
          for (t2 in arguments[e2])
            Object.prototype.hasOwnProperty.call(arguments[e2], t2) && r2[t2] === undefined && (r2[t2] = arguments[e2][t2]);
        return r2;
      }, a.prepareContent = function(r2, e2, n2, i2, s2) {
        return u.Promise.resolve(e2).then(function(n3) {
          return o.blob && (n3 instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3)) !== -1) && typeof FileReader != "undefined" ? new u.Promise(function(t2, r3) {
            var e3 = new FileReader;
            e3.onload = function(e4) {
              t2(e4.target.result);
            }, e3.onerror = function(e4) {
              r3(e4.target.error);
            }, e3.readAsArrayBuffer(n3);
          }) : n3;
        }).then(function(e3) {
          var t2 = a.getTypeOf(e3);
          return t2 ? (t2 === "arraybuffer" ? e3 = a.transformTo("uint8array", e3) : t2 === "string" && (s2 ? e3 = h.decode(e3) : n2 && i2 !== true && (e3 = function(e4) {
            return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
          }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
      var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
      function h(e2) {
        this.files = [], this.loadOptions = e2;
      }
      h.prototype = { checkSignature: function(e2) {
        if (!this.reader.readAndCheckSignature(e2)) {
          this.reader.index -= 4;
          var t2 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
        }
      }, isSignature: function(e2, t2) {
        var r2 = this.reader.index;
        this.reader.setIndex(e2);
        var n2 = this.reader.readString(4) === t2;
        return this.reader.setIndex(r2), n2;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
        this.zipComment = this.loadOptions.decodeFileName(r2);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44;0 < n2; )
          e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var e2, t2;
        for (e2 = 0;e2 < this.files.length; e2++)
          t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
      }, readCentralDir: function() {
        var e2;
        for (this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
          (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (e2 < 0)
          throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(e2);
        var t2 = e2;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r2 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
        var n2 = t2 - r2;
        if (0 < n2)
          this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
        else if (n2 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
      }, prepareReader: function(e2) {
        this.reader = n(e2);
      }, load: function(e2) {
        this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, t.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
      var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
      function l(e2, t2) {
        this.options = e2, this.loadOptions = t2;
      }
      l.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(e2) {
        var t2, r2;
        if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((t2 = function(e3) {
          for (var t3 in h)
            if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
              return h[t3];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
        this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
      }, readCentralPart: function(e2) {
        this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
        var t2 = e2.readInt(2);
        if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var e2 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), e2 == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), e2 == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var e2 = n(this.extraFields[1].value);
          this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
        }
      }, readExtraFields: function(e2) {
        var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {});e2.index + 4 < i2; )
          t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
        e2.setIndex(i2);
      }, handleUTF8: function() {
        var e2 = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
        else {
          var t2 = this.findExtraFieldUnicodePath();
          if (t2 !== null)
            this.fileNameStr = t2;
          else {
            var r2 = s.transformTo(e2, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r2);
          }
          var n2 = this.findExtraFieldUnicodeComment();
          if (n2 !== null)
            this.fileCommentStr = n2;
          else {
            var i2 = s.transformTo(e2, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(i2);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var e2 = this.extraFields[28789];
        if (e2) {
          var t2 = n(e2.value);
          return t2.readInt(1) !== 1 ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var e2 = this.extraFields[25461];
        if (e2) {
          var t2 = n(e2.value);
          return t2.readInt(1) !== 1 ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
        }
        return null;
      } }, t.exports = l;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
      function n(e2, t2, r2) {
        this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
      }
      var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
      n.prototype = { internalStream: function(e2) {
        var t2 = null, r2 = "string";
        try {
          if (!e2)
            throw new Error("No output type specified.");
          var n2 = (r2 = e2.toLowerCase()) === "string" || r2 === "text";
          r2 !== "binarystring" && r2 !== "text" || (r2 = "string"), t2 = this._decompressWorker();
          var i2 = !this._dataBinary;
          i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker)), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker));
        } catch (e3) {
          (t2 = new h("error")).error(e3);
        }
        return new s(t2, r2, "");
      }, async: function(e2, t2) {
        return this.internalStream(e2).accumulate(t2);
      }, nodeStream: function(e2, t2) {
        return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
      }, _compressWorker: function(e2, t2) {
        if (this._data instanceof o && this._data.compression.magic === e2.magic)
          return this._data.getCompressedWorker();
        var r2 = this._decompressWorker();
        return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker)), o.createWorkerFrom(r2, e2, t2);
      }, _decompressWorker: function() {
        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0;f < u.length; f++)
        n.prototype[u[f]] = l;
      t.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
      (function(t2) {
        var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
        if (e2) {
          var i = 0, s = new e2(u), a = t2.document.createTextNode("");
          s.observe(a, { characterData: true }), r = function() {
            a.data = i = ++i % 2;
          };
        } else if (t2.setImmediate || t2.MessageChannel === undefined)
          r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e3 = t2.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t2.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
        else {
          var o = new t2.MessageChannel;
          o.port1.onmessage = u, r = function() {
            o.port2.postMessage(0);
          };
        }
        var h = [];
        function u() {
          var e3, t3;
          n = true;
          for (var r2 = h.length;r2; ) {
            for (t3 = h, h = [], e3 = -1;++e3 < r2; )
              t3[e3]();
            r2 = h.length;
          }
          n = false;
        }
        l.exports = function(e3) {
          h.push(e3) !== 1 || n || r();
        };
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 37: [function(e, t, r) {
      var i = e("immediate");
      function u() {}
      var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
      function o(e2) {
        if (typeof e2 != "function")
          throw new TypeError("resolver must be a function");
        this.state = n, this.queue = [], this.outcome = undefined, e2 !== u && d(this, e2);
      }
      function h(e2, t2, r2) {
        this.promise = e2, typeof t2 == "function" && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), typeof r2 == "function" && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
      }
      function f(t2, r2, n2) {
        i(function() {
          var e2;
          try {
            e2 = r2(n2);
          } catch (e3) {
            return l.reject(t2, e3);
          }
          e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
        });
      }
      function c(e2) {
        var t2 = e2 && e2.then;
        if (e2 && (typeof e2 == "object" || typeof e2 == "function") && typeof t2 == "function")
          return function() {
            t2.apply(e2, arguments);
          };
      }
      function d(t2, e2) {
        var r2 = false;
        function n2(e3) {
          r2 || (r2 = true, l.reject(t2, e3));
        }
        function i2(e3) {
          r2 || (r2 = true, l.resolve(t2, e3));
        }
        var s2 = p(function() {
          e2(i2, n2);
        });
        s2.status === "error" && n2(s2.value);
      }
      function p(e2, t2) {
        var r2 = {};
        try {
          r2.value = e2(t2), r2.status = "success";
        } catch (e3) {
          r2.status = "error", r2.value = e3;
        }
        return r2;
      }
      (t.exports = o).prototype.finally = function(t2) {
        if (typeof t2 != "function")
          return this;
        var r2 = this.constructor;
        return this.then(function(e2) {
          return r2.resolve(t2()).then(function() {
            return e2;
          });
        }, function(e2) {
          return r2.resolve(t2()).then(function() {
            throw e2;
          });
        });
      }, o.prototype.catch = function(e2) {
        return this.then(null, e2);
      }, o.prototype.then = function(e2, t2) {
        if (typeof e2 != "function" && this.state === a || typeof t2 != "function" && this.state === s)
          return this;
        var r2 = new this.constructor(u);
        this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
        return r2;
      }, h.prototype.callFulfilled = function(e2) {
        l.resolve(this.promise, e2);
      }, h.prototype.otherCallFulfilled = function(e2) {
        f(this.promise, this.onFulfilled, e2);
      }, h.prototype.callRejected = function(e2) {
        l.reject(this.promise, e2);
      }, h.prototype.otherCallRejected = function(e2) {
        f(this.promise, this.onRejected, e2);
      }, l.resolve = function(e2, t2) {
        var r2 = p(c, t2);
        if (r2.status === "error")
          return l.reject(e2, r2.value);
        var n2 = r2.value;
        if (n2)
          d(e2, n2);
        else {
          e2.state = a, e2.outcome = t2;
          for (var i2 = -1, s2 = e2.queue.length;++i2 < s2; )
            e2.queue[i2].callFulfilled(t2);
        }
        return e2;
      }, l.reject = function(e2, t2) {
        e2.state = s, e2.outcome = t2;
        for (var r2 = -1, n2 = e2.queue.length;++r2 < n2; )
          e2.queue[r2].callRejected(t2);
        return e2;
      }, o.resolve = function(e2) {
        if (e2 instanceof this)
          return e2;
        return l.resolve(new this(u), e2);
      }, o.reject = function(e2) {
        var t2 = new this(u);
        return l.reject(t2, e2);
      }, o.all = function(e2) {
        var r2 = this;
        if (Object.prototype.toString.call(e2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var n2 = e2.length, i2 = false;
        if (!n2)
          return this.resolve([]);
        var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
        for (;++t2 < n2; )
          h2(e2[t2], t2);
        return o2;
        function h2(e3, t3) {
          r2.resolve(e3).then(function(e4) {
            s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
          }, function(e4) {
            i2 || (i2 = true, l.reject(o2, e4));
          });
        }
      }, o.race = function(e2) {
        var t2 = this;
        if (Object.prototype.toString.call(e2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var r2 = e2.length, n2 = false;
        if (!r2)
          return this.resolve([]);
        var i2 = -1, s2 = new this(u);
        for (;++i2 < r2; )
          a2 = e2[i2], t2.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l.resolve(s2, e3));
          }, function(e3) {
            n2 || (n2 = true, l.reject(s2, e3));
          });
        var a2;
        return s2;
      };
    }, { immediate: 36 }], 38: [function(e, t, r) {
      var n = {};
      (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
      var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
      function p(e2) {
        if (!(this instanceof p))
          return new p(e2);
        this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
        var t2 = this.options;
        t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s, this.strm.avail_out = 0;
        var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (r2 !== l)
          throw new Error(i[r2]);
        if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
          var n2;
          if (n2 = typeof t2.dictionary == "string" ? h.string2buf(t2.dictionary) : u.call(t2.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
            throw new Error(i[r2]);
          this._dict_set = true;
        }
      }
      function n(e2, t2) {
        var r2 = new p(t2);
        if (r2.push(e2, true), r2.err)
          throw r2.msg || i[r2.err];
        return r2.result;
      }
      p.prototype.push = function(e2, t2) {
        var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : t2 === true ? 4 : 0, typeof e2 == "string" ? i2.input = h.string2buf(e2) : u.call(e2) === "[object ArrayBuffer]" ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
        do {
          if (i2.avail_out === 0 && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), (r2 = a.deflate(i2, n2)) !== 1 && r2 !== l)
            return this.onEnd(r2), !(this.ended = true);
          i2.avail_out !== 0 && (i2.avail_in !== 0 || n2 !== 4 && n2 !== 2) || (this.options.to === "string" ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
        } while ((0 < i2.avail_in || i2.avail_out === 0) && r2 !== 1);
        return n2 === 4 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : n2 !== 2 || (this.onEnd(l), !(i2.avail_out = 0));
      }, p.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, p.prototype.onEnd = function(e2) {
        e2 === l && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
        return (t2 = t2 || {}).raw = true, n(e2, t2);
      }, r.gzip = function(e2, t2) {
        return (t2 = t2 || {}).gzip = true, n(e2, t2);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
      var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
      function a(e2) {
        if (!(this instanceof a))
          return new a(e2);
        this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
        var t2 = this.options;
        t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, t2.windowBits === 0 && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && (15 & t2.windowBits) == 0 && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i, this.strm.avail_out = 0;
        var r2 = c.inflateInit2(this.strm, t2.windowBits);
        if (r2 !== m.Z_OK)
          throw new Error(n[r2]);
        this.header = new s, c.inflateGetHeader(this.strm, this.header);
      }
      function o(e2, t2) {
        var r2 = new a(t2);
        if (r2.push(e2, true), r2.err)
          throw r2.msg || n[r2.err];
        return r2.result;
      }
      a.prototype.push = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : t2 === true ? m.Z_FINISH : m.Z_NO_FLUSH, typeof e2 == "string" ? h.input = p.binstring2buf(e2) : _.call(e2) === "[object ArrayBuffer]" ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
        do {
          if (h.avail_out === 0 && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = typeof l == "string" ? p.string2buf(l) : _.call(l) === "[object ArrayBuffer]" ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && f === true && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
            return this.onEnd(r2), !(this.ended = true);
          h.next_out && (h.avail_out !== 0 && r2 !== m.Z_STREAM_END && (h.avail_in !== 0 || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || (this.options.to === "string" ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), h.avail_in === 0 && h.avail_out === 0 && (f = true);
        } while ((0 < h.avail_in || h.avail_out === 0) && r2 !== m.Z_STREAM_END);
        return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
      }, a.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, a.prototype.onEnd = function(e2) {
        e2 === m.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
        return (t2 = t2 || {}).raw = true, o(e2, t2);
      }, r.ungzip = o;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
      var n = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
      r.assign = function(e2) {
        for (var t2 = Array.prototype.slice.call(arguments, 1);t2.length; ) {
          var r2 = t2.shift();
          if (r2) {
            if (typeof r2 != "object")
              throw new TypeError(r2 + "must be non-object");
            for (var n2 in r2)
              r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
          }
        }
        return e2;
      }, r.shrinkBuf = function(e2, t2) {
        return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
      };
      var i = { arraySet: function(e2, t2, r2, n2, i2) {
        if (t2.subarray && e2.subarray)
          e2.set(t2.subarray(r2, r2 + n2), i2);
        else
          for (var s2 = 0;s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e2) {
        var t2, r2, n2, i2, s2, a;
        for (t2 = n2 = 0, r2 = e2.length;t2 < r2; t2++)
          n2 += e2[t2].length;
        for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length;t2 < r2; t2++)
          s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
        return a;
      } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
        for (var s2 = 0;s2 < n2; s2++)
          e2[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e2) {
        return [].concat.apply([], e2);
      } };
      r.setTyped = function(e2) {
        e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
      }, r.setTyped(n);
    }, {}], 42: [function(e, t, r) {
      var h = e("./common"), i = true, s = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (e2) {
        i = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e2) {
        s = false;
      }
      for (var u = new h.Buf8(256), n = 0;n < 256; n++)
        u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
      function l(e2, t2) {
        if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
          return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
        for (var r2 = "", n2 = 0;n2 < t2; n2++)
          r2 += String.fromCharCode(e2[n2]);
        return r2;
      }
      u[254] = u[254] = 1, r.string2buf = function(e2) {
        var t2, r2, n2, i2, s2, a = e2.length, o = 0;
        for (i2 = 0;i2 < a; i2++)
          (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n2 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
        for (t2 = new h.Buf8(o), i2 = s2 = 0;s2 < o; i2++)
          (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n2 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
        return t2;
      }, r.buf2binstring = function(e2) {
        return l(e2, e2.length);
      }, r.binstring2buf = function(e2) {
        for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length;r2 < n2; r2++)
          t2[r2] = e2.charCodeAt(r2);
        return t2;
      }, r.buf2string = function(e2, t2) {
        var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
        for (r2 = n2 = 0;r2 < a; )
          if ((i2 = e2[r2++]) < 128)
            o[n2++] = i2;
          else if (4 < (s2 = u[i2]))
            o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= s2 === 2 ? 31 : s2 === 3 ? 15 : 7;1 < s2 && r2 < a; )
              i2 = i2 << 6 | 63 & e2[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
        return l(o, n2);
      }, r.utf8border = function(e2, t2) {
        var r2;
        for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1;0 <= r2 && (192 & e2[r2]) == 128; )
          r2--;
        return r2 < 0 ? t2 : r2 === 0 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
      };
    }, { "./common": 41 }], 43: [function(e, t, r) {
      t.exports = function(e2, t2, r2, n) {
        for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0;r2 !== 0; ) {
          for (r2 -= a = 2000 < r2 ? 2000 : r2;s = s + (i = i + t2[n++] | 0) | 0, --a; )
            ;
          i %= 65521, s %= 65521;
        }
        return i | s << 16 | 0;
      };
    }, {}], 44: [function(e, t, r) {
      t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, t, r) {
      var o = function() {
        for (var e2, t2 = [], r2 = 0;r2 < 256; r2++) {
          e2 = r2;
          for (var n = 0;n < 8; n++)
            e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[r2] = e2;
        }
        return t2;
      }();
      t.exports = function(e2, t2, r2, n) {
        var i = o, s = n + r2;
        e2 ^= -1;
        for (var a = n;a < s; a++)
          e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
        return -1 ^ e2;
      };
    }, {}], 46: [function(e, t, r) {
      var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
      function R2(e2, t2) {
        return e2.msg = n[t2], t2;
      }
      function T(e2) {
        return (e2 << 1) - (4 < e2 ? 9 : 0);
      }
      function D(e2) {
        for (var t2 = e2.length;0 <= --t2; )
          e2[t2] = 0;
      }
      function F(e2) {
        var t2 = e2.state, r2 = t2.pending;
        r2 > e2.avail_out && (r2 = e2.avail_out), r2 !== 0 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, t2.pending === 0 && (t2.pending_out = 0));
      }
      function N(e2, t2) {
        u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
      }
      function U(e2, t2) {
        e2.pending_buf[e2.pending++] = t2;
      }
      function P(e2, t2) {
        e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
      }
      function L(e2, t2) {
        var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
        e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
        do {
          if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
            s2 += 2, r2++;
            do {} while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
            if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
              if (e2.match_start = t2, o2 <= (a2 = n2))
                break;
              d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
            }
          }
        } while ((t2 = f2[t2 & l2]) > h2 && --i2 != 0);
        return a2 <= e2.lookahead ? a2 : e2.lookahead;
      }
      function j(e2) {
        var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
        do {
          if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
            for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size;n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            for (t2 = r2 = f2;n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            i2 += f2;
          }
          if (e2.strm.avail_in === 0)
            break;
          if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = undefined, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = l2 === 0 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), a2.state.wrap === 1 ? a2.adler = d(a2.adler, o2, l2, h2) : a2.state.wrap === 2 && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
            for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask;e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
              ;
        } while (e2.lookahead < z && e2.strm.avail_in !== 0);
      }
      function Z(e2, t2) {
        for (var r2, n2;; ) {
          if (e2.lookahead < z) {
            if (j(e2), e2.lookahead < z && t2 === l)
              return A;
            if (e2.lookahead === 0)
              break;
          }
          if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), r2 !== 0 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
            if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
              for (e2.match_length--;e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, --e2.match_length != 0; )
                ;
              e2.strstart++;
            } else
              e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
          else
            n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
          if (n2 && (N(e2, false), e2.strm.avail_out === 0))
            return A;
        }
        return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
      }
      function W(e2, t2) {
        for (var r2, n2, i2;; ) {
          if (e2.lookahead < z) {
            if (j(e2), e2.lookahead < z && t2 === l)
              return A;
            if (e2.lookahead === 0)
              break;
          }
          if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, r2 !== 0 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (e2.strategy === 1 || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
            for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), --e2.prev_length != 0; )
              ;
            if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), e2.strm.avail_out === 0))
              return A;
          } else if (e2.match_available) {
            if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, e2.strm.avail_out === 0)
              return A;
          } else
            e2.match_available = 1, e2.strstart++, e2.lookahead--;
        }
        return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
      }
      function M(e2, t2, r2, n2, i2) {
        this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
      }
      function H() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G(e2) {
        var t2;
        return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = t2.wrap === 2 ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R2(e2, _);
      }
      function K(e2) {
        var t2 = G(e2);
        return t2 === m && function(e3) {
          e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
        }(e2.state), t2;
      }
      function Y(e2, t2, r2, n2, i2, s2) {
        if (!e2)
          return _;
        var a2 = 1;
        if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
          return R2(e2, _);
        n2 === 8 && (n2 = 9);
        var o2 = new H;
        return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
      }
      h = [new M(0, 0, 0, 0, function(e2, t2) {
        var r2 = 65535;
        for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5);; ) {
          if (e2.lookahead <= 1) {
            if (j(e2), e2.lookahead === 0 && t2 === l)
              return A;
            if (e2.lookahead === 0)
              break;
          }
          e2.strstart += e2.lookahead, e2.lookahead = 0;
          var n2 = e2.block_start + r2;
          if ((e2.strstart === 0 || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), e2.strm.avail_out === 0))
            return A;
          if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), e2.strm.avail_out === 0))
            return A;
        }
        return e2.insert = 0, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
      }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
        return Y(e2, t2, v, 15, 8, 0);
      }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
        return e2 && e2.state ? e2.state.wrap !== 2 ? _ : (e2.state.gzhead = t2, m) : _;
      }, r.deflate = function(e2, t2) {
        var r2, n2, i2, s2;
        if (!e2 || !e2.state || 5 < t2 || t2 < 0)
          return e2 ? R2(e2, _) : _;
        if (n2 = e2.state, !e2.output || !e2.input && e2.avail_in !== 0 || n2.status === 666 && t2 !== f)
          return R2(e2, e2.avail_out === 0 ? -5 : _);
        if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
          if (n2.wrap === 2)
            e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, n2.level === 9 ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, n2.level === 9 ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
          else {
            var a2 = v + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : n2.level === 6 ? 2 : 3) << 6, n2.strstart !== 0 && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), n2.strstart !== 0 && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
          }
        if (n2.status === 69)
          if (n2.gzhead.extra) {
            for (i2 = n2.pending;n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
              U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else
            n2.status = 73;
        if (n2.status === 73)
          if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (s2 !== 0);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), s2 === 0 && (n2.gzindex = 0, n2.status = 91);
          } else
            n2.status = 91;
        if (n2.status === 91)
          if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (s2 !== 0);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), s2 === 0 && (n2.status = 103);
          } else
            n2.status = 103;
        if (n2.status === 103 && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), n2.pending !== 0) {
          if (F(e2), e2.avail_out === 0)
            return n2.last_flush = -1, m;
        } else if (e2.avail_in === 0 && T(t2) <= T(r2) && t2 !== f)
          return R2(e2, -5);
        if (n2.status === 666 && e2.avail_in !== 0)
          return R2(e2, -5);
        if (e2.avail_in !== 0 || n2.lookahead !== 0 || t2 !== l && n2.status !== 666) {
          var o2 = n2.strategy === 2 ? function(e3, t3) {
            for (var r3;; ) {
              if (e3.lookahead === 0 && (j(e3), e3.lookahead === 0)) {
                if (t3 === l)
                  return A;
                break;
              }
              if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), e3.strm.avail_out === 0))
                return A;
            }
            return e3.insert = 0, t3 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
          }(n2, t2) : n2.strategy === 3 ? function(e3, t3) {
            for (var r3, n3, i3, s3, a3 = e3.window;; ) {
              if (e3.lookahead <= S) {
                if (j(e3), e3.lookahead <= S && t3 === l)
                  return A;
                if (e3.lookahead === 0)
                  break;
              }
              if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                s3 = e3.strstart + S;
                do {} while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
              }
              if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), e3.strm.avail_out === 0))
                return A;
            }
            return e3.insert = 0, t3 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
          }(n2, t2) : h[n2.level].func(n2, t2);
          if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
            return e2.avail_out === 0 && (n2.last_flush = -1), m;
          if (o2 === I && (t2 === 1 ? u._tr_align(n2) : t2 !== 5 && (u._tr_stored_block(n2, 0, 0, false), t2 === 3 && (D(n2.head), n2.lookahead === 0 && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), e2.avail_out === 0))
            return n2.last_flush = -1, m;
        }
        return t2 !== f ? m : n2.wrap <= 0 ? 1 : (n2.wrap === 2 ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), n2.pending !== 0 ? m : 1);
      }, r.deflateEnd = function(e2) {
        var t2;
        return e2 && e2.state ? (t2 = e2.state.status) !== C && t2 !== 69 && t2 !== 73 && t2 !== 91 && t2 !== 103 && t2 !== E && t2 !== 666 ? R2(e2, _) : (e2.state = null, t2 === E ? R2(e2, -3) : m) : _;
      }, r.deflateSetDictionary = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
        if (!e2 || !e2.state)
          return _;
        if ((s2 = (r2 = e2.state).wrap) === 2 || s2 === 1 && r2.status !== C || r2.lookahead)
          return _;
        for (s2 === 1 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (s2 === 0 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2);r2.lookahead >= x; ) {
          for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1);r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
            ;
          r2.strstart = n2, r2.lookahead = x - 1, j(r2);
        }
        return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
      t.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e, t, r) {
      t.exports = function(e2, t2) {
        var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
        r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
        e:
          do {
            p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
            t:
              for (;; ) {
                if (d >>>= y = v >>> 24, p -= y, (y = v >>> 16 & 255) === 0)
                  C[s++] = 65535 & v;
                else {
                  if (!(16 & y)) {
                    if ((64 & y) == 0) {
                      v = m[(65535 & v) + (d & (1 << y) - 1)];
                      continue t;
                    }
                    if (32 & y) {
                      r2.mode = 12;
                      break e;
                    }
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break e;
                  }
                  w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                  r:
                    for (;; ) {
                      if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                        if ((64 & y) == 0) {
                          v = _[(65535 & v) + (d & (1 << y) - 1)];
                          continue r;
                        }
                        e2.msg = "invalid distance code", r2.mode = 30;
                        break e;
                      }
                      if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                        e2.msg = "invalid distance too far back", r2.mode = 30;
                        break e;
                      }
                      if (d >>>= y, p -= y, (y = s - a) < k) {
                        if (l < (y = k - y) && r2.sane) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (S = c, (x = 0) === f) {
                          if (x += u - y, y < w) {
                            for (w -= y;C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                        } else if (f < y) {
                          if (x += u + f - y, (y -= f) < w) {
                            for (w -= y;C[s++] = c[x++], --y; )
                              ;
                            if (x = 0, f < w) {
                              for (w -= y = f;C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          }
                        } else if (x += f - y, y < w) {
                          for (w -= y;C[s++] = c[x++], --y; )
                            ;
                          x = s - k, S = C;
                        }
                        for (;2 < w; )
                          C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                        w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                      } else {
                        for (x = s - k;C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                          ;
                        w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (n < i && s < o);
        n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
      };
    }, {}], 49: [function(e, t, r) {
      var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R2 = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
      function L(e2) {
        return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
      }
      function s() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a(e2) {
        var t2;
        return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
      }
      function o(e2) {
        var t2;
        return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
      }
      function h(e2, t2) {
        var r2, n2;
        return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (n2.window !== null && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
      }
      function u(e2, t2) {
        var r2, n2;
        return e2 ? (n2 = new s, (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
      }
      var l, f, c = true;
      function j(e2) {
        if (c) {
          var t2;
          for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0;t2 < 144; )
            e2.lens[t2++] = 8;
          for (;t2 < 256; )
            e2.lens[t2++] = 9;
          for (;t2 < 280; )
            e2.lens[t2++] = 7;
          for (;t2 < 288; )
            e2.lens[t2++] = 8;
          for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0;t2 < 32; )
            e2.lens[t2++] = 5;
          T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
        }
        e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
      }
      function Z(e2, t2, r2, n2) {
        var i2, s2 = e2.state;
        return s2.window === null && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
      }
      r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
        return u(e2, 15);
      }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!e2 || !e2.state || !e2.output || !e2.input && e2.avail_in !== 0)
          return U;
        (r2 = e2.state).mode === 12 && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
        e:
          for (;; )
            switch (r2.mode) {
              case P:
                if (r2.wrap === 0) {
                  r2.mode = 13;
                  break;
                }
                for (;l2 < 16; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (2 & r2.wrap && u2 === 35615) {
                  E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  e2.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if ((15 & u2) != 8) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), r2.wbits === 0)
                  r2.wbits = k;
                else if (k > r2.wbits) {
                  e2.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                break;
              case 2:
                for (;l2 < 16; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.flags = u2, (255 & r2.flags) != 8) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  e2.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
              case 3:
                for (;l2 < 32; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
              case 4:
                for (;l2 < 16; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (;l2 < 16; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                } else
                  r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                  break e;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (o2 === 0)
                    break e;
                  for (d = 0;k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (o2 === 0)
                    break e;
                  for (d = 0;k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (;l2 < 16; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    e2.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (;l2 < 32; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
              case 11:
                if (r2.havedict === 0)
                  return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                e2.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (t2 === 5 || t2 === 6)
                  break e;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                  break;
                }
                for (;l2 < 3; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j(r2), r2.mode = 20, t2 !== 6)
                      break;
                    u2 >>>= 2, l2 -= 2;
                    break e;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    e2.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l2 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l2, l2 -= 7 & l2;l2 < 32; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  e2.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, t2 === 6)
                  break e;
              case 15:
                r2.mode = 16;
              case 16:
                if (d = r2.length) {
                  if (o2 < d && (d = o2), h2 < d && (d = h2), d === 0)
                    break e;
                  I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (;l2 < 14; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  e2.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (;r2.have < r2.ncode; ) {
                  for (;l2 < 3; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                }
                for (;r2.have < 19; )
                  r2.lens[A[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e2.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (;r2.have < r2.nlen + r2.ndist; ) {
                  for (;g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (b < 16)
                    u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                  else {
                    if (b === 16) {
                      for (z = _ + 2;l2 < z; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 >>>= _, l2 -= _, r2.have === 0) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                    } else if (b === 17) {
                      for (z = _ + 3;l2 < z; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                    } else {
                      for (z = _ + 7;l2 < z; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                    }
                    if (r2.have + d > r2.nlen + r2.ndist) {
                      e2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (;d--; )
                      r2.lens[r2.have++] = k;
                  }
                }
                if (r2.mode === 30)
                  break;
                if (r2.lens[256] === 0) {
                  e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e2.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                  e2.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, t2 === 6)
                  break e;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h2) {
                  e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R2(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, r2.mode === 12 && (r2.back = -1);
                  break;
                }
                for (r2.back = 0;g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (g && (240 & g) == 0) {
                  for (v = _, y = g, w = b;g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, g === 0) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  e2.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z = r2.extra;l2 < z; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (;g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if ((240 & g) == 0) {
                  for (v = _, y = g, w = b;g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                  e2.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z = r2.extra;l2 < z; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  e2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (h2 === 0)
                  break e;
                if (d = c2 - h2, r2.offset > d) {
                  if ((d = r2.offset - d) > r2.whave && r2.sane) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                } else
                  m = i2, p = a2 - r2.offset, d = r2.length;
                for (h2 < d && (d = h2), h2 -= d, r2.length -= d;i2[a2++] = m[p++], --d; )
                  ;
                r2.length === 0 && (r2.mode = 21);
                break;
              case 26:
                if (h2 === 0)
                  break e;
                i2[a2++] = r2.length, h2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (;l2 < 32; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 |= n2[s2++] << l2, l2 += 8;
                  }
                  if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                    e2.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (;l2 < 32; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    e2.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x = 1;
                break e;
              case 30:
                x = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return U;
            }
        return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || t2 !== 4)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === 12 ? 128 : 0) + (r2.mode === 20 || r2.mode === 15 ? 256 : 0), (f2 == 0 && c2 === 0 || t2 === 4) && x === N && (x = -5), x);
      }, r.inflateEnd = function(e2) {
        if (!e2 || !e2.state)
          return U;
        var t2 = e2.state;
        return t2.window && (t2.window = null), e2.state = null, N;
      }, r.inflateGetHeader = function(e2, t2) {
        var r2;
        return e2 && e2.state ? (2 & (r2 = e2.state).wrap) == 0 ? U : ((r2.head = t2).done = false, N) : U;
      }, r.inflateSetDictionary = function(e2, t2) {
        var r2, n2 = t2.length;
        return e2 && e2.state ? (r2 = e2.state).wrap !== 0 && r2.mode !== 11 ? U : r2.mode === 11 && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
      var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      t.exports = function(e2, t2, r2, n, i, s, a, o) {
        var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R2 = null, T = 0;
        for (b = 0;b <= 15; b++)
          O[b] = 0;
        for (v = 0;v < n; v++)
          O[t2[r2 + v]]++;
        for (k = g, w = 15;1 <= w && O[w] === 0; w--)
          ;
        if (w < k && (k = w), w === 0)
          return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
        for (y = 1;y < w && O[y] === 0; y++)
          ;
        for (k < y && (k = y), b = z = 1;b <= 15; b++)
          if (z <<= 1, (z -= O[b]) < 0)
            return -1;
        if (0 < z && (e2 === 0 || w !== 1))
          return -1;
        for (B[1] = 0, b = 1;b < 15; b++)
          B[b + 1] = B[b] + O[b];
        for (v = 0;v < n; v++)
          t2[r2 + v] !== 0 && (a[B[t2[r2 + v]]++] = v);
        if (d = e2 === 0 ? (A = R2 = a, 19) : e2 === 1 ? (A = F, I -= 257, R2 = N, T -= 257, 256) : (A = U, R2 = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, e2 === 1 && 852 < C || e2 === 2 && 592 < C)
          return 1;
        for (;; ) {
          for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R2[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x;i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, u !== 0; )
            ;
          for (h = 1 << b - 1;E & h; )
            h >>= 1;
          if (h !== 0 ? (E &= h - 1, E += h) : E = 0, v++, --O[b] == 0) {
            if (b === w)
              break;
            b = t2[r2 + a[v]];
          }
          if (k < b && (E & f) !== l) {
            for (S === 0 && (S = k), c += y, z = 1 << (x = b - S);x + S < w && !((z -= O[x + S]) <= 0); )
              x++, z <<= 1;
            if (C += 1 << x, e2 === 1 && 852 < C || e2 === 2 && 592 < C)
              return 1;
            i[l = E & f] = k << 24 | x << 16 | c - s | 0;
          }
        }
        return E !== 0 && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, t, r) {
      t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, t, r) {
      var i = e("../utils/common"), o = 0, h = 1;
      function n(e2) {
        for (var t2 = e2.length;0 <= --t2; )
          e2[t2] = 0;
      }
      var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
      n(z);
      var C = new Array(2 * f);
      n(C);
      var E = new Array(512);
      n(E);
      var A = new Array(256);
      n(A);
      var I = new Array(a);
      n(I);
      var O, B, R2, T = new Array(f);
      function D(e2, t2, r2, n2, i2) {
        this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
      }
      function F(e2, t2) {
        this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
      }
      function N(e2) {
        return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
      }
      function U(e2, t2) {
        e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
      }
      function P(e2, t2, r2) {
        e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
      }
      function L(e2, t2, r2) {
        P(e2, r2[2 * t2], r2[2 * t2 + 1]);
      }
      function j(e2, t2) {
        for (var r2 = 0;r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
          ;
        return r2 >>> 1;
      }
      function Z(e2, t2, r2) {
        var n2, i2, s2 = new Array(g + 1), a2 = 0;
        for (n2 = 1;n2 <= g; n2++)
          s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
        for (i2 = 0;i2 <= t2; i2++) {
          var o2 = e2[2 * i2 + 1];
          o2 !== 0 && (e2[2 * i2] = j(s2[o2]++, o2));
        }
      }
      function W(e2) {
        var t2;
        for (t2 = 0;t2 < l; t2++)
          e2.dyn_ltree[2 * t2] = 0;
        for (t2 = 0;t2 < f; t2++)
          e2.dyn_dtree[2 * t2] = 0;
        for (t2 = 0;t2 < c; t2++)
          e2.bl_tree[2 * t2] = 0;
        e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
      }
      function M(e2) {
        8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
      }
      function H(e2, t2, r2, n2) {
        var i2 = 2 * t2, s2 = 2 * r2;
        return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
      }
      function G(e2, t2, r2) {
        for (var n2 = e2.heap[r2], i2 = r2 << 1;i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
          e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
        e2.heap[r2] = n2;
      }
      function K(e2, t2, r2) {
        var n2, i2, s2, a2, o2 = 0;
        if (e2.last_lit !== 0)
          for (;n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, n2 === 0 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), (a2 = w[s2]) !== 0 && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), (a2 = k[s2]) !== 0 && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
            ;
        L(e2, m, t2);
      }
      function Y(e2, t2) {
        var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
        for (e2.heap_len = 0, e2.heap_max = _, r2 = 0;r2 < h2; r2++)
          s2[2 * r2] !== 0 ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
        for (;e2.heap_len < 2; )
          s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
        for (t2.max_code = u2, r2 = e2.heap_len >> 1;1 <= r2; r2--)
          G(e2, s2, r2);
        for (i2 = h2;r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
          ;
        e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
          for (s3 = 0;s3 <= g; s3++)
            e3.bl_count[s3] = 0;
          for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1;r3 < _; r3++)
            p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
          if (m2 !== 0) {
            do {
              for (s3 = p2 - 1;e3.bl_count[s3] === 0; )
                s3--;
              e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
            } while (0 < m2);
            for (s3 = p2;s3 !== 0; s3--)
              for (n3 = e3.bl_count[s3];n3 !== 0; )
                u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
          }
        }(e2, t2), Z(s2, u2, e2.bl_count);
      }
      function X(e2, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
        for (a2 === 0 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0;n2 <= r2; n2++)
          i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : i2 !== 0 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
      }
      function V(e2, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
        for (a2 === 0 && (h2 = 138, u2 = 3), n2 = 0;n2 <= r2; n2++)
          if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
            if (o2 < u2)
              for (;L(e2, i2, e2.bl_tree), --o2 != 0; )
                ;
            else
              i2 !== 0 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
      }
      n(T);
      var q = false;
      function J(e2, t2, r2, n2) {
        P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
          M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
        }(e2, t2, r2, true);
      }
      r._tr_init = function(e2) {
        q || (function() {
          var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
          for (n2 = r2 = 0;n2 < a - 1; n2++)
            for (I[n2] = r2, e3 = 0;e3 < 1 << w[n2]; e3++)
              A[r2++] = n2;
          for (A[r2 - 1] = n2, n2 = i2 = 0;n2 < 16; n2++)
            for (T[n2] = i2, e3 = 0;e3 < 1 << k[n2]; e3++)
              E[i2++] = n2;
          for (i2 >>= 7;n2 < f; n2++)
            for (T[n2] = i2 << 7, e3 = 0;e3 < 1 << k[n2] - 7; e3++)
              E[256 + i2++] = n2;
          for (t2 = 0;t2 <= g; t2++)
            s2[t2] = 0;
          for (e3 = 0;e3 <= 143; )
            z[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (;e3 <= 255; )
            z[2 * e3 + 1] = 9, e3++, s2[9]++;
          for (;e3 <= 279; )
            z[2 * e3 + 1] = 7, e3++, s2[7]++;
          for (;e3 <= 287; )
            z[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (Z(z, l + 1, s2), e3 = 0;e3 < f; e3++)
            C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
          O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R2 = new D(new Array(0), x, 0, c, p);
        }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R2), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
      }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
        var i2, s2, a2 = 0;
        0 < e2.level ? (e2.strm.data_type === 2 && (e2.strm.data_type = function(e3) {
          var t3, r3 = 4093624447;
          for (t3 = 0;t3 <= 31; t3++, r3 >>>= 1)
            if (1 & r3 && e3.dyn_ltree[2 * t3] !== 0)
              return o;
          if (e3.dyn_ltree[18] !== 0 || e3.dyn_ltree[20] !== 0 || e3.dyn_ltree[26] !== 0)
            return h;
          for (t3 = 32;t3 < u; t3++)
            if (e3.dyn_ltree[2 * t3] !== 0)
              return h;
          return o;
        }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
          var t3;
          for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1;3 <= t3 && e3.bl_tree[2 * S[t3] + 1] === 0; t3--)
            ;
          return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
        }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && t2 !== -1 ? J(e2, t2, r2, n2) : e2.strategy === 4 || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
          var i3;
          for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0;i3 < n3; i3++)
            P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
          V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
        }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
      }, r._tr_tally = function(e2, t2, r2) {
        return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, t2 === 0 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
      }, r._tr_align = function(e2) {
        P(e2, 2, 3), L(e2, m, z), function(e3) {
          e3.bi_valid === 16 ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
        }(e2);
      };
    }, { "../utils/common": 41 }], 53: [function(e, t, r) {
      t.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, t, r) {
      (function(e2) {
        (function(r2, n) {
          if (!r2.setImmediate) {
            var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
            e3 = e3 && e3.setTimeout ? e3 : r2, i = {}.toString.call(r2.process) === "[object process]" ? function(e4) {
              process$1.nextTick(function() {
                c(e4);
              });
            } : function() {
              if (r2.postMessage && !r2.importScripts) {
                var e4 = true, t3 = r2.onmessage;
                return r2.onmessage = function() {
                  e4 = false;
                }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
              }
            }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
              r2.postMessage(a + e4, "*");
            }) : r2.MessageChannel ? ((t2 = new MessageChannel).port1.onmessage = function(e4) {
              c(e4.data);
            }, function(e4) {
              t2.port2.postMessage(e4);
            }) : l && ("onreadystatechange" in l.createElement("script")) ? (s = l.documentElement, function(e4) {
              var t3 = l.createElement("script");
              t3.onreadystatechange = function() {
                c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
              }, s.appendChild(t3);
            }) : function(e4) {
              setTimeout(c, 0, e4);
            }, e3.setImmediate = function(e4) {
              typeof e4 != "function" && (e4 = new Function("" + e4));
              for (var t3 = new Array(arguments.length - 1), r3 = 0;r3 < t3.length; r3++)
                t3[r3] = arguments[r3 + 1];
              var n2 = { callback: e4, args: t3 };
              return h[o] = n2, i(o), o++;
            }, e3.clearImmediate = f;
          }
          function f(e4) {
            delete h[e4];
          }
          function c(e4) {
            if (u)
              setTimeout(c, 0, e4);
            else {
              var t3 = h[e4];
              if (t3) {
                u = true;
                try {
                  (function(e5) {
                    var { callback: t4, args: r3 } = e5;
                    switch (r3.length) {
                      case 0:
                        t4();
                        break;
                      case 1:
                        t4(r3[0]);
                        break;
                      case 2:
                        t4(r3[0], r3[1]);
                        break;
                      case 3:
                        t4(r3[0], r3[1], r3[2]);
                        break;
                      default:
                        t4.apply(n, r3);
                    }
                  })(t3);
                } finally {
                  f(e4), u = false;
                }
              }
            }
          }
          function d(e4) {
            e4.source === r2 && typeof e4.data == "string" && e4.data.indexOf(a) === 0 && c(+e4.data.slice(a.length));
          }
        })(typeof self == "undefined" ? e2 === undefined ? this : e2 : self);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
var jszip_minExports = jszip_min.exports;
var JSZip = /* @__PURE__ */ getDefaultExportFromCjs$1(jszip_minExports);
var xml$2 = { exports: {} };
var XML_CHARACTER_MAP = {
  "&": "&amp;",
  '"': "&quot;",
  "'": "&apos;",
  "<": "&lt;",
  ">": "&gt;"
};
function escapeForXML$1(string3) {
  return string3 && string3.replace ? string3.replace(/([&"<>'])/g, function(str, item) {
    return XML_CHARACTER_MAP[item];
  }) : string3;
}
var escapeForXML_1 = escapeForXML$1;
var escapeForXML = escapeForXML_1;
var Stream = streamBrowserify.Stream;
var DEFAULT_INDENT = "    ";
function xml(input, options2) {
  if (typeof options2 !== "object") {
    options2 = {
      indent: options2
    };
  }
  var stream = options2.stream ? new Stream : null, output = "", interrupted = false, indent2 = !options2.indent ? "" : options2.indent === true ? DEFAULT_INDENT : options2.indent, instant = true;
  function delay(func) {
    if (!instant) {
      func();
    } else {
      process$1.nextTick(func);
    }
  }
  function append(interrupt, out) {
    if (out !== undefined) {
      output += out;
    }
    if (interrupt && !interrupted) {
      stream = stream || new Stream;
      interrupted = true;
    }
    if (interrupt && interrupted) {
      var data = output;
      delay(function() {
        stream.emit("data", data);
      });
      output = "";
    }
  }
  function add(value, last) {
    format(append, resolve(value, indent2, indent2 ? 1 : 0), last);
  }
  function end() {
    if (stream) {
      var data = output;
      delay(function() {
        stream.emit("data", data);
        stream.emit("end");
        stream.readable = false;
        stream.emit("close");
      });
    }
  }
  function addXmlDeclaration(declaration) {
    var encoding = declaration.encoding || "UTF-8", attr = { version: "1.0", encoding };
    if (declaration.standalone) {
      attr.standalone = declaration.standalone;
    }
    add({ "?xml": { _attr: attr } });
    output = output.replace("/>", "?>");
  }
  delay(function() {
    instant = false;
  });
  if (options2.declaration) {
    addXmlDeclaration(options2.declaration);
  }
  if (input && input.forEach) {
    input.forEach(function(value, i) {
      var last;
      if (i + 1 === input.length)
        last = end;
      add(value, last);
    });
  } else {
    add(input, end);
  }
  if (stream) {
    stream.readable = true;
    return stream;
  }
  return output;
}
function element() {
  var input = Array.prototype.slice.call(arguments), self2 = {
    _elem: resolve(input)
  };
  self2.push = function(input2) {
    if (!this.append) {
      throw new Error("not assigned to a parent!");
    }
    var that = this;
    var indent2 = this._elem.indent;
    format(this.append, resolve(input2, indent2, this._elem.icount + (indent2 ? 1 : 0)), function() {
      that.append(true);
    });
  };
  self2.close = function(input2) {
    if (input2 !== undefined) {
      this.push(input2);
    }
    if (this.end) {
      this.end();
    }
  };
  return self2;
}
function create_indent(character, count) {
  return new Array(count || 0).join(character || "");
}
function resolve(data, indent2, indent_count) {
  indent_count = indent_count || 0;
  var indent_spaces = create_indent(indent2, indent_count);
  var name;
  var values2 = data;
  var interrupt = false;
  if (typeof data === "object") {
    var keys = Object.keys(data);
    name = keys[0];
    values2 = data[name];
    if (values2 && values2._elem) {
      values2._elem.name = name;
      values2._elem.icount = indent_count;
      values2._elem.indent = indent2;
      values2._elem.indents = indent_spaces;
      values2._elem.interrupt = values2;
      return values2._elem;
    }
  }
  var attributes = [], content3 = [];
  var isStringContent;
  function get_attributes(obj) {
    var keys2 = Object.keys(obj);
    keys2.forEach(function(key) {
      attributes.push(attribute(key, obj[key]));
    });
  }
  switch (typeof values2) {
    case "object":
      if (values2 === null)
        break;
      if (values2._attr) {
        get_attributes(values2._attr);
      }
      if (values2._cdata) {
        content3.push(("<![CDATA[" + values2._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>");
      }
      if (values2.forEach) {
        isStringContent = false;
        content3.push("");
        values2.forEach(function(value) {
          if (typeof value == "object") {
            var _name = Object.keys(value)[0];
            if (_name == "_attr") {
              get_attributes(value._attr);
            } else {
              content3.push(resolve(value, indent2, indent_count + 1));
            }
          } else {
            content3.pop();
            isStringContent = true;
            content3.push(escapeForXML(value));
          }
        });
        if (!isStringContent) {
          content3.push("");
        }
      }
      break;
    default:
      content3.push(escapeForXML(values2));
  }
  return {
    name,
    interrupt,
    attributes,
    content: content3,
    icount: indent_count,
    indents: indent_spaces,
    indent: indent2
  };
}
function format(append, elem, end) {
  if (typeof elem != "object") {
    return append(false, elem);
  }
  var len = elem.interrupt ? 1 : elem.content.length;
  function proceed() {
    while (elem.content.length) {
      var value = elem.content.shift();
      if (value === undefined)
        continue;
      if (interrupt(value))
        return;
      format(append, value);
    }
    append(false, (len > 1 ? elem.indents : "") + (elem.name ? "</" + elem.name + ">" : "") + (elem.indent && !end ? `
` : ""));
    if (end) {
      end();
    }
  }
  function interrupt(value) {
    if (value.interrupt) {
      value.interrupt.append = append;
      value.interrupt.end = proceed;
      value.interrupt = false;
      append(true);
      return true;
    }
    return false;
  }
  append(false, elem.indents + (elem.name ? "<" + elem.name : "") + (elem.attributes.length ? " " + elem.attributes.join(" ") : "") + (len ? elem.name ? ">" : "" : elem.name ? "/>" : "") + (elem.indent && len > 1 ? `
` : ""));
  if (!len) {
    return append(false, elem.indent ? `
` : "");
  }
  if (!interrupt(elem)) {
    proceed();
  }
}
function attribute(key, value) {
  return key + '="' + escapeForXML(value) + '"';
}
xml$2.exports = xml;
xml$2.exports.element = xml$2.exports.Element = element;
var xmlExports = xml$2.exports;
var xml$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(xmlExports);
var obfuscatedStartOffset = 0;
var obfuscatedEndOffset = 32;
var guidSize = 32;
var obfuscate = (buf, fontKey) => {
  const guid = fontKey.replace(/-/g, "");
  if (guid.length !== guidSize) {
    throw new Error(`Error: Cannot extract GUID from font filename: ${fontKey}`);
  }
  const hexStrings = guid.replace(/(..)/g, "$1 ").trim().split(" ");
  const hexNumbers = hexStrings.map((hexString) => parseInt(hexString, 16));
  hexNumbers.reverse();
  const bytesToObfuscate = buf.slice(obfuscatedStartOffset, obfuscatedEndOffset);
  const obfuscatedBytes = bytesToObfuscate.map((byte, i) => byte ^ hexNumbers[i % hexNumbers.length]);
  const out = Buffer.concat([buf.slice(0, obfuscatedStartOffset), obfuscatedBytes, buf.slice(obfuscatedEndOffset)]);
  return out;
};

class Formatter {
  format(input, context = { stack: [] }) {
    const output = input.prepForXml(context);
    if (output) {
      return output;
    } else {
      throw Error("XMLComponent did not format correctly");
    }
  }
}

class ImageReplacer {
  replace(xmlData, mediaData, offset) {
    let currentXmlData = xmlData;
    mediaData.forEach((image2, i) => {
      currentXmlData = currentXmlData.replace(new RegExp(`{${image2.fileName}}`, "g"), (offset + i).toString());
    });
    return currentXmlData;
  }
  getMediaData(xmlData, media) {
    return media.Array.filter((image2) => xmlData.search(`{${image2.fileName}}`) > 0);
  }
}

class NumberingReplacer {
  replace(xmlData, concreteNumberings) {
    let currentXmlData = xmlData;
    for (const concreteNumbering of concreteNumberings) {
      currentXmlData = currentXmlData.replace(new RegExp(`{${concreteNumbering.reference}-${concreteNumbering.instance}}`, "g"), concreteNumbering.numId.toString());
    }
    return currentXmlData;
  }
}

class Compiler {
  constructor() {
    __publicField(this, "formatter");
    __publicField(this, "imageReplacer");
    __publicField(this, "numberingReplacer");
    this.formatter = new Formatter;
    this.imageReplacer = new ImageReplacer;
    this.numberingReplacer = new NumberingReplacer;
  }
  compile(file, prettifyXml) {
    const zip = new JSZip;
    const xmlifiedFileMapping = this.xmlifyFile(file, prettifyXml);
    const map3 = new Map(Object.entries(xmlifiedFileMapping));
    for (const [, obj] of map3) {
      if (Array.isArray(obj)) {
        for (const subFile of obj) {
          zip.file(subFile.path, subFile.data);
        }
      } else {
        zip.file(obj.path, obj.data);
      }
    }
    for (const data of file.Media.Array) {
      if (data.type !== "svg") {
        zip.file(`word/media/${data.fileName}`, data.data);
      } else {
        zip.file(`word/media/${data.fileName}`, data.data);
        zip.file(`word/media/${data.fallback.fileName}`, data.fallback.data);
      }
    }
    for (const { data: buffer2, name, fontKey } of file.FontTable.fontOptionsWithKey) {
      const [nameWithoutExtension] = name.split(".");
      zip.file(`word/fonts/${nameWithoutExtension}.odttf`, obfuscate(buffer2, fontKey));
    }
    return zip;
  }
  xmlifyFile(file, prettify) {
    const documentRelationshipCount = file.Document.Relationships.RelationshipCount + 1;
    const documentXmlData = xml$1(this.formatter.format(file.Document.View, {
      viewWrapper: file.Document,
      file,
      stack: []
    }), {
      indent: prettify,
      declaration: {
        standalone: "yes",
        encoding: "UTF-8"
      }
    });
    const documentMediaDatas = this.imageReplacer.getMediaData(documentXmlData, file.Media);
    return {
      Relationships: {
        data: (() => {
          documentMediaDatas.forEach((mediaData, i) => {
            file.Document.Relationships.createRelationship(documentRelationshipCount + i, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", `media/${mediaData.fileName}`);
          });
          return xml$1(this.formatter.format(file.Document.Relationships, {
            viewWrapper: file.Document,
            file,
            stack: []
          }), {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          });
        })(),
        path: "word/_rels/document.xml.rels"
      },
      Document: {
        data: (() => {
          const xmlData = this.imageReplacer.replace(documentXmlData, documentMediaDatas, documentRelationshipCount);
          const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
          return referenedXmlData;
        })(),
        path: "word/document.xml"
      },
      Styles: {
        data: (() => {
          const xmlStyles = xml$1(this.formatter.format(file.Styles, {
            viewWrapper: file.Document,
            file,
            stack: []
          }), {
            indent: prettify,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          });
          const referencedXmlStyles = this.numberingReplacer.replace(xmlStyles, file.Numbering.ConcreteNumbering);
          return referencedXmlStyles;
        })(),
        path: "word/styles.xml"
      },
      Properties: {
        data: xml$1(this.formatter.format(file.CoreProperties, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            standalone: "yes",
            encoding: "UTF-8"
          }
        }),
        path: "docProps/core.xml"
      },
      Numbering: {
        data: xml$1(this.formatter.format(file.Numbering, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            standalone: "yes",
            encoding: "UTF-8"
          }
        }),
        path: "word/numbering.xml"
      },
      FileRelationships: {
        data: xml$1(this.formatter.format(file.FileRelationships, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            encoding: "UTF-8"
          }
        }),
        path: "_rels/.rels"
      },
      HeaderRelationships: file.Headers.map((headerWrapper, index2) => {
        const xmlData = xml$1(this.formatter.format(headerWrapper.View, {
          viewWrapper: headerWrapper,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            encoding: "UTF-8"
          }
        });
        const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
        mediaDatas.forEach((mediaData, i) => {
          headerWrapper.Relationships.createRelationship(i, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", `media/${mediaData.fileName}`);
        });
        return {
          data: xml$1(this.formatter.format(headerWrapper.Relationships, {
            viewWrapper: headerWrapper,
            file,
            stack: []
          }), {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }),
          path: `word/_rels/header${index2 + 1}.xml.rels`
        };
      }),
      FooterRelationships: file.Footers.map((footerWrapper, index2) => {
        const xmlData = xml$1(this.formatter.format(footerWrapper.View, {
          viewWrapper: footerWrapper,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            encoding: "UTF-8"
          }
        });
        const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);
        mediaDatas.forEach((mediaData, i) => {
          footerWrapper.Relationships.createRelationship(i, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", `media/${mediaData.fileName}`);
        });
        return {
          data: xml$1(this.formatter.format(footerWrapper.Relationships, {
            viewWrapper: footerWrapper,
            file,
            stack: []
          }), {
            indent: prettify,
            declaration: {
              encoding: "UTF-8"
            }
          }),
          path: `word/_rels/footer${index2 + 1}.xml.rels`
        };
      }),
      Headers: file.Headers.map((headerWrapper, index2) => {
        const tempXmlData = xml$1(this.formatter.format(headerWrapper.View, {
          viewWrapper: headerWrapper,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            encoding: "UTF-8"
          }
        });
        const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
        const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
        const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
        return {
          data: referenedXmlData,
          path: `word/header${index2 + 1}.xml`
        };
      }),
      Footers: file.Footers.map((footerWrapper, index2) => {
        const tempXmlData = xml$1(this.formatter.format(footerWrapper.View, {
          viewWrapper: footerWrapper,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            encoding: "UTF-8"
          }
        });
        const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);
        const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);
        const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);
        return {
          data: referenedXmlData,
          path: `word/footer${index2 + 1}.xml`
        };
      }),
      ContentTypes: {
        data: xml$1(this.formatter.format(file.ContentTypes, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            encoding: "UTF-8"
          }
        }),
        path: "[Content_Types].xml"
      },
      CustomProperties: {
        data: xml$1(this.formatter.format(file.CustomProperties, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            standalone: "yes",
            encoding: "UTF-8"
          }
        }),
        path: "docProps/custom.xml"
      },
      AppProperties: {
        data: xml$1(this.formatter.format(file.AppProperties, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            standalone: "yes",
            encoding: "UTF-8"
          }
        }),
        path: "docProps/app.xml"
      },
      FootNotes: {
        data: xml$1(this.formatter.format(file.FootNotes.View, {
          viewWrapper: file.FootNotes,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            encoding: "UTF-8"
          }
        }),
        path: "word/footnotes.xml"
      },
      FootNotesRelationships: {
        data: xml$1(this.formatter.format(file.FootNotes.Relationships, {
          viewWrapper: file.FootNotes,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            encoding: "UTF-8"
          }
        }),
        path: "word/_rels/footnotes.xml.rels"
      },
      Settings: {
        data: xml$1(this.formatter.format(file.Settings, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            standalone: "yes",
            encoding: "UTF-8"
          }
        }),
        path: "word/settings.xml"
      },
      Comments: {
        data: xml$1(this.formatter.format(file.Comments, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            standalone: "yes",
            encoding: "UTF-8"
          }
        }),
        path: "word/comments.xml"
      },
      FontTable: {
        data: xml$1(this.formatter.format(file.FontTable.View, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            standalone: "yes",
            encoding: "UTF-8"
          }
        }),
        path: "word/fontTable.xml"
      },
      FontTableRelationships: {
        data: (() => xml$1(this.formatter.format(file.FontTable.Relationships, {
          viewWrapper: file.Document,
          file,
          stack: []
        }), {
          indent: prettify,
          declaration: {
            encoding: "UTF-8"
          }
        }))(),
        path: "word/_rels/fontTable.xml.rels"
      }
    };
  }
}
var PrettifyType = {
  NONE: "",
  WITH_2_BLANKS: "  ",
  WITH_4_BLANKS: "    ",
  WITH_TAB: "\t"
};
var convertPrettifyType = (prettify) => prettify === true ? PrettifyType.WITH_2_BLANKS : prettify === false ? undefined : prettify;

class Packer {
  static toString(file, prettify) {
    return __async(this, null, function* () {
      const zip = this.compiler.compile(file, convertPrettifyType(prettify));
      const zipData = yield zip.generateAsync({
        type: "string",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
      return zipData;
    });
  }
  static toBuffer(file, prettify) {
    return __async(this, null, function* () {
      const zip = this.compiler.compile(file, convertPrettifyType(prettify));
      const zipData = yield zip.generateAsync({
        type: "nodebuffer",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
      return zipData;
    });
  }
  static toBase64String(file, prettify) {
    return __async(this, null, function* () {
      const zip = this.compiler.compile(file, convertPrettifyType(prettify));
      const zipData = yield zip.generateAsync({
        type: "base64",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
      return zipData;
    });
  }
  static toBlob(file, prettify) {
    return __async(this, null, function* () {
      const zip = this.compiler.compile(file, convertPrettifyType(prettify));
      const zipData = yield zip.generateAsync({
        type: "blob",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
      return zipData;
    });
  }
  static toStream(file, prettify) {
    const stream = new streamBrowserify.Stream;
    const zip = this.compiler.compile(file, convertPrettifyType(prettify));
    zip.generateAsync({
      type: "nodebuffer",
      mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      compression: "DEFLATE"
    }).then((z) => {
      stream.emit("data", z);
      stream.emit("end");
    });
    return stream;
  }
}
__publicField(Packer, "compiler", new Compiler);
var formatter$1 = new Formatter;
var formatter = new Formatter;
var imageReplacer = new ImageReplacer;

// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/lib/index.js
var import_is_buffer2 = __toESM(require_is_buffer(), 1);
var import_extend2 = __toESM(require_extend(), 1);

// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/node_modules/vfile/lib/index.js
var import_is_buffer = __toESM(require_is_buffer(), 1);

// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/node_modules/vfile/node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition2(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position2(value.position);
  }
  if ("start" in value || "end" in value) {
    return position2(value);
  }
  if ("line" in value || "column" in value) {
    return point3(value);
  }
  return "";
}
function point3(point4) {
  return index2(point4 && point4.line) + ":" + index2(point4 && point4.column);
}
function position2(pos) {
  return point3(pos && pos.start) + "-" + point3(pos && pos.end);
}
function index2(value) {
  return value && typeof value === "number" ? value : 1;
}
// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/node_modules/vfile/node_modules/vfile-message/lib/index.js
class VFileMessage2 extends Error {
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position3 = {
      start: { line: null, column: null },
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = undefined;
    }
    if (typeof origin === "string") {
      const index3 = origin.indexOf(":");
      if (index3 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index3);
        parts[1] = origin.slice(index3 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position3 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position3 = place;
      } else if ("line" in place || "column" in place) {
        position3.start = place;
      }
    }
    this.name = stringifyPosition2(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position3.start.line;
    this.column = position3.start.column;
    this.position = position3;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
}
VFileMessage2.prototype.file = "";
VFileMessage2.prototype.name = "";
VFileMessage2.prototype.reason = "";
VFileMessage2.prototype.message = "";
VFileMessage2.prototype.stack = "";
VFileMessage2.prototype.fatal = null;
VFileMessage2.prototype.column = null;
VFileMessage2.prototype.line = null;
VFileMessage2.prototype.source = null;
VFileMessage2.prototype.ruleId = null;
VFileMessage2.prototype.position = null;
// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/node_modules/vfile/lib/minpath.js
import { default as default4 } from "path";

// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/node_modules/vfile/lib/minproc.js
import { default as default5 } from "process";

// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/node_modules/vfile/lib/minurl.js
import { fileURLToPath as fileURLToPath2 } from "url";

// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/node_modules/vfile/lib/minurl.shared.js
function isUrl2(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && fileUrlOrPath.href && fileUrlOrPath.origin;
}
// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/node_modules/vfile/lib/index.js
var order2 = ["history", "path", "basename", "stem", "extname", "dirname"];

class VFile2 {
  constructor(value) {
    let options2;
    if (!value) {
      options2 = {};
    } else if (typeof value === "string" || buffer2(value)) {
      options2 = { value };
    } else if (isUrl2(value)) {
      options2 = { path: value };
    } else {
      options2 = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = default5.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index3 = -1;
    while (++index3 < order2.length) {
      const prop2 = order2[index3];
      if (prop2 in options2 && options2[prop2] !== undefined && options2[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options2[prop2]] : options2[prop2];
      }
    }
    let prop;
    for (prop in options2) {
      if (!order2.includes(prop)) {
        this[prop] = options2[prop];
      }
    }
  }
  get path() {
    return this.history[this.history.length - 1];
  }
  set path(path2) {
    if (isUrl2(path2)) {
      path2 = fileURLToPath2(path2);
    }
    assertNonEmpty2(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  get dirname() {
    return typeof this.path === "string" ? default4.dirname(this.path) : undefined;
  }
  set dirname(dirname) {
    assertPath2(this.basename, "dirname");
    this.path = default4.join(dirname || "", this.basename);
  }
  get basename() {
    return typeof this.path === "string" ? default4.basename(this.path) : undefined;
  }
  set basename(basename) {
    assertNonEmpty2(basename, "basename");
    assertPart2(basename, "basename");
    this.path = default4.join(this.dirname || "", basename);
  }
  get extname() {
    return typeof this.path === "string" ? default4.extname(this.path) : undefined;
  }
  set extname(extname) {
    assertPart2(extname, "extname");
    assertPath2(this.dirname, "extname");
    if (extname) {
      if (extname.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = default4.join(this.dirname, this.stem + (extname || ""));
  }
  get stem() {
    return typeof this.path === "string" ? default4.basename(this.path, this.extname) : undefined;
  }
  set stem(stem) {
    assertNonEmpty2(stem, "stem");
    assertPart2(stem, "stem");
    this.path = default4.join(this.dirname || "", stem + (this.extname || ""));
  }
  toString(encoding) {
    return (this.value || "").toString(encoding || undefined);
  }
  message(reason, place, origin) {
    const message = new VFileMessage2(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
}
function assertPart2(part, name) {
  if (part && part.includes(default4.sep)) {
    throw new Error("`" + name + "` cannot be a path: did not expect `" + default4.sep + "`");
  }
}
function assertNonEmpty2(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function buffer2(value) {
  return import_is_buffer.default(value);
}
// node_modules/@unified-latex/unified-latex-util-parse/node_modules/unified/lib/index.js
var unified2 = base().freeze();
var own4 = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data;
  processor.Parser = undefined;
  processor.Compiler = undefined;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse2;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process3;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index3 = -1;
    while (++index3 < attachers.length) {
      destination.use(...attachers[index3]);
    }
    destination.data(import_extend2.default(true, {}, namespace));
    return destination;
  }
  function data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen2("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own4.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen2("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options2] = attachers[freezeIndex];
      if (options2[0] === false) {
        continue;
      }
      if (options2[0] === true) {
        options2[0] = undefined;
      }
      const transformer = attacher.call(processor, ...options2);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value, ...options2) {
    let settings;
    assertUnfrozen2("use", frozen);
    if (value === null || value === undefined) {} else if (typeof value === "function") {
      addPlugin(value, ...options2);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options3] = value2;
          addPlugin(plugin, ...options3);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index3 = -1;
      if (plugins === null || plugins === undefined) {} else if (Array.isArray(plugins)) {
        while (++index3 < plugins.length) {
          const thing = plugins[index3];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index3 = -1;
      let entry;
      while (++index3 < attachers.length) {
        if (attachers[index3][0] === plugin) {
          entry = attachers[index3];
          break;
        }
      }
      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value2)) {
          value2 = import_extend2.default(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse2(doc) {
    processor.freeze();
    const file = vfile2(doc);
    const Parser = processor.Parser;
    assertParser2("parse", Parser);
    if (newable(Parser, "parse")) {
      return new Parser(String(file), file).parse();
    }
    return Parser(String(file), file);
  }
  function stringify(node2, doc) {
    processor.freeze();
    const file = vfile2(doc);
    const Compiler2 = processor.Compiler;
    assertCompiler2("stringify", Compiler2);
    assertNode2(node2);
    if (newable(Compiler2, "compile")) {
      return new Compiler2(node2, file).compile();
    }
    return Compiler2(node2, file);
  }
  function run(node2, doc, callback) {
    assertNode2(node2);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = undefined;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve2, reject) {
      transformers.run(node2, vfile2(doc), done);
      function done(error, tree, file) {
        tree = tree || node2;
        if (error) {
          reject(error);
        } else if (resolve2) {
          resolve2(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node2, file) {
    let result;
    let complete;
    processor.run(node2, file, done);
    assertDone2("runSync", "run", complete);
    return result;
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }
  function process3(doc, callback) {
    processor.freeze();
    assertParser2("process", processor.Parser);
    assertCompiler2("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve2, reject) {
      const file = vfile2(doc);
      processor.run(processor.parse(file), file, (error, tree, file2) => {
        if (error || !tree || !file2) {
          done(error);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === undefined || result === null) {} else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error, file2);
        }
      });
      function done(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve2) {
          resolve2(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser2("processSync", processor.Parser);
    assertCompiler2("processSync", processor.Compiler);
    const file = vfile2(doc);
    processor.process(file, done);
    assertDone2("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value, name) {
  return typeof value === "function" && value.prototype && (keys(value.prototype) || (name in value.prototype));
}
function keys(value) {
  let key;
  for (key in value) {
    if (own4.call(value, key)) {
      return true;
    }
  }
  return false;
}
function assertParser2(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler2(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen2(name, frozen) {
  if (frozen) {
    throw new Error("Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
  }
}
function assertNode2(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone2(name, asyncName, complete) {
  if (!complete) {
    throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
  }
}
function vfile2(value) {
  return looksLikeAVFile2(value) ? value : new VFile2(value);
}
function looksLikeAVFile2(value) {
  return Boolean(value && typeof value === "object" && "message" in value && "messages" in value);
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || import_is_buffer2.default(value);
}
// node_modules/@unified-latex/unified-latex-ctan/package/amsart/index.js
var macros = {
  author: {
    signature: "o m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  address: {
    signature: "o m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  curraddr: {
    signature: "o m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  email: {
    signature: "o m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  title: {
    signature: "o m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  urladdr: {
    signature: "o m",
    renderInfo: { breakAround: true, inParMode: true }
  }
};
var environments = {};

// node_modules/@unified-latex/unified-latex-ctan/package/cleveref/index.js
var macros2 = {
  cref: { signature: "s m" },
  Cref: { signature: "s m" },
  crefrange: { signature: "s m m" },
  Crefrange: { signature: "s m m" },
  cpageref: { signature: "s m" },
  Cpageref: { signature: "s m" },
  ref: { signature: "m" },
  pageref: { signature: "m" },
  namecref: { signature: "m" },
  nameCref: { signature: "m" },
  lcnamecref: { signature: "m" },
  namecrefs: { signature: "m" },
  nameCrefs: { signature: "m" },
  lcnamecrefs: { signature: "m" },
  labelcref: { signature: "m" },
  labelcpageref: { signature: "m" },
  crefalias: { signature: "m m" },
  crefname: { signature: "m m m" },
  crefdefaultlabelformat: { signature: "m" },
  crefrangeconjunction: { signature: "m" }
};
var environments2 = {};

// node_modules/@unified-latex/unified-latex-builder/index.js
var BRACES_MAP = {
  "*": { openMark: "", closeMark: "" },
  "{": { openMark: "{", closeMark: "}" },
  "[": { openMark: "[", closeMark: "]" },
  "(": { openMark: "(", closeMark: ")" },
  "<": { openMark: "<", closeMark: ">" }
};
var CLOSE_BRACES = new Set(Object.values(BRACES_MAP).map((x) => x.closeMark).filter((x) => x));
function bracesToOpenAndCloseMarks(braces) {
  const ret = [];
  for (const char of braces.split("")) {
    if (CLOSE_BRACES.has(char)) {
      continue;
    }
    const braces2 = BRACES_MAP[char];
    if (braces2 == null) {
      throw new Error(`Unknown open/close mark type "${char}"`);
    }
    ret.push(braces2);
  }
  return ret;
}
function arg(args2, special) {
  if (args2 == null) {
    return { type: "argument", content: [], openMark: "", closeMark: "" };
  }
  if (typeof args2 === "string") {
    args2 = s(args2);
  }
  if (!Array.isArray(args2) && args2.type === "argument") {
    return args2;
  }
  let openMark = (special == null ? undefined : special.openMark) ?? "{";
  let closeMark = (special == null ? undefined : special.closeMark) ?? "}";
  if (special == null ? undefined : special.braces) {
    const braces = bracesToOpenAndCloseMarks(special.braces);
    if (braces[0]) {
      openMark = braces[0].openMark;
      closeMark = braces[0].closeMark;
    }
  }
  if (!Array.isArray(args2)) {
    args2 = [args2];
  }
  return { type: "argument", content: args2, openMark, closeMark };
}
function s(value) {
  if (typeof value === "string") {
    return { type: "string", content: value };
  }
  return value;
}

// node_modules/@unified-latex/unified-latex-util-print-raw/index.js
var linebreak = Symbol("linebreak");
var ESCAPE = "\\";
function _printRaw(node2) {
  if (typeof node2 === "string") {
    return [node2];
  }
  if (Array.isArray(node2)) {
    return [].concat(...node2.map((n) => _printRaw(n)));
  }
  let argsString, escape;
  switch (node2.type) {
    case "root":
      return _printRaw(node2.content);
    case "argument":
      return [node2.openMark, ..._printRaw(node2.content), node2.closeMark];
    case "comment":
      let suffix = node2.suffixParbreak ? "" : linebreak;
      let leadingWhitespace = "";
      if (node2.sameline && node2.leadingWhitespace) {
        leadingWhitespace = " ";
      }
      if (node2.sameline) {
        return [
          leadingWhitespace,
          "%",
          ..._printRaw(node2.content),
          suffix
        ];
      }
      return [linebreak, "%", ..._printRaw(node2.content), suffix];
    case "environment":
    case "mathenv":
    case "verbatim":
      let env = _printRaw(node2.env);
      let envStart = [ESCAPE + "begin{", ...env, "}"];
      let envEnd = [ESCAPE + "end{", ...env, "}"];
      argsString = node2.args == null ? [] : _printRaw(node2.args);
      return [
        ...envStart,
        ...argsString,
        ..._printRaw(node2.content),
        ...envEnd
      ];
    case "displaymath":
      return [ESCAPE + "[", ..._printRaw(node2.content), ESCAPE + "]"];
    case "group":
      return ["{", ..._printRaw(node2.content), "}"];
    case "inlinemath":
      return ["$", ..._printRaw(node2.content), "$"];
    case "macro":
      argsString = node2.args == null ? [] : _printRaw(node2.args);
      escape = node2.escapeToken == null ? ESCAPE : node2.escapeToken;
      return [escape, ..._printRaw(node2.content), ...argsString];
    case "parbreak":
      return [linebreak, linebreak];
    case "string":
      return [node2.content];
    case "verb":
      return [
        ESCAPE,
        node2.env,
        node2.escape,
        ..._printRaw(node2.content),
        node2.escape
      ];
    case "whitespace":
      return [" "];
    default:
      console.warn("Cannot find render for node ", node2, `(of type ${typeof node2})`);
      return ["" + node2];
  }
}
function printRaw(node2, options2) {
  const asArray = options2 != null ? options2.asArray : false;
  const printedTokens = _printRaw(node2);
  if (asArray) {
    return printedTokens;
  }
  return printedTokens.map((x) => x === linebreak ? `
` : x).join("");
}

// node_modules/@unified-latex/unified-latex-util-match/index.js
function createMacroMatcher(macros3) {
  const macrosHash = Array.isArray(macros3) ? macros3.length > 0 ? typeof macros3[0] === "string" ? Object.fromEntries(macros3.map((macro2) => {
    if (typeof macro2 !== "string") {
      throw new Error("Wrong branch of map function");
    }
    return [macro2, {}];
  })) : Object.fromEntries(macros3.map((macro2) => {
    if (typeof macro2 === "string") {
      throw new Error("Wrong branch of map function");
    }
    if (macro2.escapeToken != null) {
      return [
        macro2.content,
        { escapeToken: macro2.escapeToken }
      ];
    }
    return [macro2.content, {}];
  })) : {} : macros3;
  return function matchAgainstMacros(node2) {
    if (node2 == null || node2.type !== "macro") {
      return false;
    }
    const spec = macrosHash[node2.content];
    if (!spec) {
      return false;
    }
    if (typeof spec === "object" && "escapeToken" in spec) {
      return spec.escapeToken == null || spec.escapeToken === node2.escapeToken;
    }
    return true;
  };
}
function createEnvironmentMatcher(macros3) {
  const environmentsHash = Array.isArray(macros3) ? Object.fromEntries(macros3.map((str) => {
    return [str, {}];
  })) : macros3;
  return function matchAgainstEnvironments(node2) {
    if (!match.anyEnvironment(node2)) {
      return false;
    }
    const envName = printRaw(node2.env);
    const spec = environmentsHash[envName];
    if (!spec) {
      return false;
    }
    return true;
  };
}
var match = {
  macro(node2, macroName) {
    if (node2 == null) {
      return false;
    }
    return node2.type === "macro" && (macroName == null || node2.content === macroName);
  },
  anyMacro(node2) {
    return match.macro(node2);
  },
  environment(node2, envName) {
    if (node2 == null) {
      return false;
    }
    return (node2.type === "environment" || node2.type === "mathenv") && (envName == null || printRaw(node2.env) === envName);
  },
  anyEnvironment(node2) {
    return match.environment(node2);
  },
  comment(node2) {
    if (node2 == null) {
      return false;
    }
    return node2.type === "comment";
  },
  parbreak(node2) {
    if (node2 == null) {
      return false;
    }
    return node2.type === "parbreak";
  },
  whitespace(node2) {
    if (node2 == null) {
      return false;
    }
    return node2.type === "whitespace";
  },
  whitespaceLike(node2) {
    if (node2 == null) {
      return false;
    }
    return node2.type === "whitespace" || node2.type === "whitespace" && node2.leadingWhitespace === true;
  },
  string(node2, value) {
    if (node2 == null) {
      return false;
    }
    return node2.type === "string" && (value == null || node2.content === value);
  },
  anyString(node2) {
    return match.string(node2);
  },
  group(node2) {
    if (node2 == null) {
      return false;
    }
    return node2.type === "group";
  },
  argument(node2) {
    if (node2 == null) {
      return false;
    }
    return node2.type === "argument";
  },
  blankArgument(node2) {
    if (!match.argument(node2)) {
      return false;
    }
    return node2.openMark === "" && node2.closeMark === "" && node2.content.length === 0;
  },
  math(node2) {
    if (node2 == null) {
      return false;
    }
    return node2.type === "displaymath" || node2.type === "inlinemath";
  },
  createMacroMatcher,
  createEnvironmentMatcher
};

// node_modules/@unified-latex/unified-latex-util-visit/index.js
function listMathChildren(node2) {
  const NULL_RETURN = { enter: [], leave: [] };
  if (Array.isArray(node2)) {
    return NULL_RETURN;
  }
  if (match.math(node2)) {
    return { enter: ["content"], leave: [] };
  }
  const renderInfo = node2._renderInfo || {};
  if (renderInfo.inMathMode == null) {
    return NULL_RETURN;
  }
  if (match.macro(node2)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["args"], leave: [] };
    } else if (renderInfo.inMathMode === false) {
      return { enter: [], leave: ["args"] };
    }
  }
  if (match.environment(node2)) {
    if (renderInfo.inMathMode === true) {
      return { enter: ["content"], leave: [] };
    } else {
      return { enter: [], leave: ["content"] };
    }
  }
  return NULL_RETURN;
}
var CONTINUE4 = Symbol("continue");
var SKIP4 = Symbol("skip");
var EXIT4 = Symbol("exit");
var DEFAULT_CONTEXT = {
  inMathMode: false,
  hasMathModeAncestor: false
};
function visit3(tree, visitor, options2) {
  const {
    startingContext = DEFAULT_CONTEXT,
    test = () => true,
    includeArrays = false
  } = options2 || {};
  let enter;
  let leave;
  if (typeof visitor === "function") {
    enter = visitor;
  } else if (visitor && typeof visitor === "object") {
    enter = visitor.enter;
    leave = visitor.leave;
  }
  walk(tree, {
    key: undefined,
    index: undefined,
    parents: [],
    containingArray: undefined,
    context: { ...startingContext }
  });
  function walk(node2, { key, index: index3, parents, context, containingArray }) {
    const nodePassesTest = includeArrays ? test(node2, { key, index: index3, parents, context, containingArray }) : !Array.isArray(node2) && test(node2, { key, index: index3, parents, context, containingArray });
    const result = enter && nodePassesTest ? toResult4(enter(node2, {
      key,
      index: index3,
      parents,
      context,
      containingArray
    })) : [CONTINUE4];
    if (result[0] === EXIT4) {
      return result;
    }
    if (result[0] === SKIP4) {
      return leave && nodePassesTest ? toResult4(leave(node2, {
        key,
        index: index3,
        parents,
        context,
        containingArray
      })) : result;
    }
    if (Array.isArray(node2)) {
      for (let index22 = 0;index22 > -1 && index22 < node2.length; index22++) {
        const item = node2[index22];
        const result2 = walk(item, {
          key,
          index: index22,
          parents,
          context,
          containingArray: node2
        });
        if (result2[0] === EXIT4) {
          return result2;
        }
        if (typeof result2[1] === "number") {
          index22 = result2[1] - 1;
        }
      }
    } else {
      let childProps = ["content", "args"];
      switch (node2.type) {
        case "macro":
          childProps = ["args"];
          break;
        case "comment":
        case "string":
        case "verb":
        case "verbatim":
          childProps = [];
          break;
      }
      const mathModeProps = listMathChildren(node2);
      for (const key2 of childProps) {
        const value = node2[key2];
        const grandparents = [node2].concat(parents);
        if (value == null) {
          continue;
        }
        const newContext = { ...context };
        if (mathModeProps.enter.includes(key2)) {
          newContext.inMathMode = true;
          newContext.hasMathModeAncestor = true;
        } else if (mathModeProps.leave.includes(key2)) {
          newContext.inMathMode = false;
        }
        const result2 = walk(value, {
          key: key2,
          index: undefined,
          parents: grandparents,
          context: newContext,
          containingArray: undefined
        });
        if (result2[0] === EXIT4) {
          return result2;
        }
      }
    }
    return leave && nodePassesTest ? toResult4(leave(node2, {
      key,
      index: index3,
      parents,
      context,
      containingArray
    })) : result;
  }
}
function toResult4(value) {
  if (value == null) {
    return [CONTINUE4];
  }
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE4, value];
  }
  return [value];
}

// node_modules/@unified-latex/unified-latex-util-render-info/index.js
function updateRenderInfo(node2, renderInfo) {
  if (renderInfo != null) {
    node2._renderInfo = { ...node2._renderInfo || {}, ...renderInfo };
  }
  return node2;
}

// node_modules/@unified-latex/unified-latex-util-trim/index.js
function trim(nodes) {
  if (!Array.isArray(nodes)) {
    console.warn("Trying to trim a non-array ast", nodes);
    return nodes;
  }
  const { trimmedStart } = trimStart(nodes);
  const { trimmedEnd } = trimEnd(nodes);
  return { trimmedStart, trimmedEnd };
}
function trimStart(nodes) {
  const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
  nodes.splice(0, start);
  for (const leadingToken of nodes) {
    if (!match.comment(leadingToken)) {
      break;
    }
    if (leadingToken.leadingWhitespace || leadingToken.sameline) {
      leadingToken.leadingWhitespace = false;
    }
    if (start > 0 && leadingToken.sameline) {
      leadingToken.sameline = false;
    }
  }
  return { trimmedStart: start };
}
function trimEnd(nodes) {
  const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
  nodes.splice(nodes.length - end, end);
  for (let i = nodes.length - 1;i >= 0; i--) {
    const trailingToken = nodes[i];
    if (!match.comment(trailingToken)) {
      break;
    }
    delete trailingToken.suffixParbreak;
    if (match.comment(trailingToken) && trailingToken.leadingWhitespace && !trailingToken.sameline) {
      trailingToken.leadingWhitespace = false;
    }
  }
  return { trimmedEnd: end };
}
function amountOfLeadingAndTrailingWhitespace(ast) {
  let start = 0;
  let end = 0;
  for (const node2 of ast) {
    if (match.whitespace(node2) || match.parbreak(node2)) {
      start++;
    } else {
      break;
    }
  }
  if (start === ast.length) {
    return { start, end: 0 };
  }
  for (let i = ast.length - 1;i >= 0; i--) {
    const node2 = ast[i];
    if (match.whitespace(node2) || match.parbreak(node2)) {
      end++;
    } else {
      break;
    }
  }
  return { start, end };
}
var unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents2() {
  return (tree) => {
    visit3(tree, (node2) => {
      if (!(match.math(node2) || match.anyEnvironment(node2))) {
        return;
      }
      let firstNode = node2.content[0];
      if (match.comment(firstNode) && firstNode.sameline) {
        firstNode.suffixParbreak = false;
        trimEnd(node2.content);
        const { trimmedStart } = trimStart(node2.content.slice(1));
        node2.content.splice(1, trimmedStart);
      } else {
        trim(node2.content);
      }
    });
  };
};
var unifiedLatexTrimRoot = function unifiedLatexTrimRoot2() {
  return (tree) => {
    trim(tree.content);
  };
};

// node_modules/@unified-latex/unified-latex-util-split/index.js
function splitOnCondition(nodes, splitFunc = () => false, options2) {
  if (!Array.isArray(nodes)) {
    throw new Error(`Can only split an Array, not ${nodes}`);
  }
  const { onlySplitOnFirstOccurrence = false } = options2 || {};
  const splitIndices = [];
  for (let i = 0;i < nodes.length; i++) {
    if (splitFunc(nodes[i])) {
      splitIndices.push(i);
      if (onlySplitOnFirstOccurrence) {
        break;
      }
    }
  }
  if (splitIndices.length === 0) {
    return { segments: [nodes], separators: [] };
  }
  let separators = splitIndices.map((i) => nodes[i]);
  let segments = splitIndices.map((splitEnd, i) => {
    const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
    return nodes.slice(splitStart, splitEnd);
  });
  segments.push(nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length));
  return { segments, separators };
}
function splitOnMacro(ast, macroName) {
  if (typeof macroName === "string") {
    macroName = [macroName];
  }
  if (!Array.isArray(macroName)) {
    throw new Error("Type coercion failed");
  }
  const isSeparator = match.createMacroMatcher(macroName);
  const { segments, separators } = splitOnCondition(ast, isSeparator);
  return { segments, macros: separators };
}

// node_modules/@unified-latex/unified-latex-util-replace/index.js
function lastSignificantNodeIndex(nodes, parbreaksAreInsignificant) {
  for (let i = nodes.length - 1;i >= 0; i--) {
    const node2 = nodes[i];
    if (match.whitespace(node2) || match.comment(node2) || parbreaksAreInsignificant && match.parbreak(node2)) {
      continue;
    }
    return i;
  }
  return;
}

// node_modules/@unified-latex/unified-latex-ctan/enumerate-wQeKG6-C.js
function cleanEnumerateBody(ast, itemName = "item") {
  let { segments, macros: macros3 } = splitOnMacro(ast, itemName);
  for (let i = 0;i < segments.length; i++) {
    const segment = segments[i];
    if (i === 0) {
      trimEnd(segment);
    } else {
      trim(segment);
    }
    if (segment.length > 0 && i > 0) {
      segment.unshift({ type: "whitespace" });
    }
  }
  let insertParbreakBefore = /* @__PURE__ */ new WeakSet;
  let body = macros3.flatMap((node2, i) => {
    var _a;
    const segment = segments[i + 1];
    const trailingComments = popTrailingComments(segment);
    node2.args = node2.args || [];
    node2.args.push(arg(segment, { openMark: "", closeMark: "" }));
    updateRenderInfo(node2, { inParMode: true });
    if (i > 0 || ((_a = segments[0]) == null ? undefined : _a.length) > 0) {
      insertParbreakBefore.add(node2);
    }
    return [node2, ...trailingComments];
  });
  body = body.flatMap((node2) => insertParbreakBefore.has(node2) ? [{ type: "parbreak" }, node2] : node2);
  body.unshift(...segments[0]);
  for (let i = 0;i < body.length - 1; i++) {
    const node2 = body[i];
    const nextNode = body[i + 1];
    if (!match.parbreak(nextNode)) {
      continue;
    }
    if (match.comment(node2)) {
      node2.suffixParbreak = true;
    }
    if (match.macro(node2) && node2.args && node2.args[node2.args.length - 1].closeMark === "") {
      const args = node2.args[node2.args.length - 1].content;
      const lastArg = args[args.length - 1];
      if (match.comment(lastArg)) {
        lastArg.suffixParbreak = true;
      }
    }
  }
  return body;
}
function popTrailingComments(nodes) {
  let lastNodeIndex = lastSignificantNodeIndex(nodes, true);
  if (lastNodeIndex === nodes.length - 1 || lastNodeIndex == null && nodes.length === 0) {
    return [];
  }
  if (lastNodeIndex == null) {
    lastNodeIndex = -1;
  }
  return nodes.splice(lastNodeIndex + 1);
}

// node_modules/@unified-latex/unified-latex-ctan/provides-B-HiB8uu.js
var macros3 = {
  answerline: { signature: "o" },
  fillin: { signature: "o o" },
  fullwidth: { signature: "m" },
  fillwidthlines: { signature: "m" },
  fillwidthdottedlines: { signature: "m" },
  fillwidthgrid: { signature: "m" },
  makeemptybox: { signature: "m" },
  CorrectChoiceEmphasis: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  SolutionEmphasis: { signature: "m", renderInfo: { breakAround: true } },
  uplevel: { signature: "m", renderInfo: { breakAround: true } },
  checkboxchar: { signature: "m", renderInfo: { breakAround: true } },
  checkedchar: { signature: "m", renderInfo: { breakAround: true } },
  pointname: { signature: "m", renderInfo: { breakAround: true } },
  marginpointname: { signature: "m", renderInfo: { breakAround: true } },
  extrawidth: { signature: "m", renderInfo: { breakAround: true } },
  pointformat: { signature: "m", renderInfo: { breakAround: true } },
  bonuspointformat: { signature: "m", renderInfo: { breakAround: true } },
  totalformat: { signature: "m", renderInfo: { breakAround: true } },
  qformat: { signature: "m", renderInfo: { breakAround: true } },
  titledquestion: { signature: "m o", renderInfo: { breakAround: true } },
  pointpoints: { signature: "m m", renderInfo: { breakAround: true } },
  bonuspointpoints: { signature: "m m", renderInfo: { breakAround: true } }
};
var environments3 = {
  choices: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
  },
  checkboxes: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
  },
  oneparchoices: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
  },
  oneparcheckboxes: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "choice")
  },
  parts: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "part")
  },
  subparts: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "subpart")
  },
  subsubparts: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "subsubpart")
  },
  questions: {
    signature: "o",
    processContent: (nodes) => cleanEnumerateBody(nodes, "question")
  }
};

// node_modules/@unified-latex/unified-latex-ctan/package/geometry/index.js
var macros4 = {
  geometry: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  }
};
var environments4 = {};

// node_modules/@unified-latex/unified-latex-ctan/package/hyperref/index.js
var macros5 = {
  hypersetup: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  href: { signature: "o m m" },
  url: { signature: "m" },
  nolinkurl: { signature: "m" },
  hyperbaseurl: { signature: "m" },
  hyperimage: { signature: "m m" },
  hyperdef: { signature: "m m m" },
  hyperref: { signature: "o m" },
  hyperlink: { signature: "m m" },
  hypertarget: { signature: "m m" },
  autoref: { signature: "s m" },
  pageref: { signature: "s m" },
  autopageref: { signature: "s m" },
  pdfstringdef: { signature: "m m" },
  pdfbookmark: { signature: "o m m" },
  currentpdfbookmark: { signature: "m m" },
  subpdfbookmark: { signature: "m m" },
  belowpdfbookmark: { signature: "m m" },
  texorpdfstring: { signature: "m m" },
  thispdfpagelabel: { signature: "m" },
  hypercalcbp: { signature: "m" }
};
var environments5 = {};

// node_modules/@unified-latex/unified-latex-ctan/provides-BUHzyq9A.js
var macros6 = {
  "\\": { signature: "!s !o", renderInfo: { breakAfter: true } },
  _: { signature: "m", escapeToken: "" },
  "^": { signature: "m", escapeToken: "" },
  newcommand: {
    signature: "s +m o +o +m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", "name", "numArgs", "default", "body"]
    }
  },
  renewcommand: {
    signature: "s +m o +o +m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", "name", "numArgs", "default", "body"]
    }
  },
  providecommand: {
    signature: "s +m o +o +m",
    renderInfo: { breakAround: true }
  },
  newcounter: {
    signature: "m o",
    renderInfo: { breakAround: true }
  },
  usecounter: {
    signature: "m"
  },
  setcounter: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  addtocounter: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  stepcounter: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  refstepcounter: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  newlength: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  addtolength: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  settodepth: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  settoheight: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  settowidth: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  stretch: { signature: "m" },
  hspace: { signature: "s m" },
  vspace: { signature: "s m", renderInfo: { breakAround: true } },
  vfill: { renderInfo: { breakAround: true } },
  indent: { renderInfo: { breakAround: true } },
  phantom: { signature: "m" },
  vphantom: { signature: "m" },
  hphantom: { signature: "m" },
  noindent: { renderInfo: { breakAround: true } },
  smallskip: { renderInfo: { breakAround: true } },
  medskip: { renderInfo: { breakAround: true } },
  bigskip: { renderInfo: { breakAround: true } },
  smallbreak: { renderInfo: { breakAround: true } },
  medbreak: { renderInfo: { breakAround: true } },
  bigbreak: { renderInfo: { breakAround: true } },
  newline: { renderInfo: { breakAround: true } },
  linebreak: { signature: "o", renderInfo: { breakAround: true } },
  nolinebreak: { signature: "o", renderInfo: { breakAround: true } },
  clearpage: { renderInfo: { breakAround: true } },
  cleardoublepage: { renderInfo: { breakAround: true } },
  newpage: { renderInfo: { breakAround: true } },
  enlargethispage: { signature: "s", renderInfo: { breakAround: true } },
  pagebreak: { signature: "o", renderInfo: { breakAround: true } },
  nopagebreak: { signature: "o", renderInfo: { breakAround: true } },
  newsavebox: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  sbox: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  savebox: {
    signature: "m o o m",
    renderInfo: { breakAround: true }
  },
  mbox: { signature: "m" },
  makebox: { signature: "d() o o m", renderInfo: { breakAround: true } },
  fbox: { signature: "m" },
  framebox: { signature: "o o m", renderInfo: { breakAround: true } },
  frame: { signature: "m", renderInfo: { breakAround: true } },
  parbox: { signature: "o o o m m", renderInfo: { breakAround: true } },
  raisebox: { signature: "m o o m" },
  marginpar: { signature: "o m", renderInfo: { breakAround: true } },
  colorbox: { signature: "o m m", renderInfo: { breakAround: true } },
  fcolorbox: { signature: "o m m", renderInfo: { breakAround: true } },
  rotatebox: { signature: "o m m" },
  scalebox: { signature: "m o m" },
  reflectbox: { signature: "m" },
  resizebox: { signature: "s m m m" },
  newenvironment: {
    signature: "s m o o m m",
    renderInfo: { breakAround: true }
  },
  renewenvironment: {
    signature: "s m o o m m",
    renderInfo: { breakAround: true }
  },
  newtheorem: {
    signature: "s m o m o",
    renderInfo: { breakAround: true }
  },
  newfont: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  alph: { signature: "m" },
  Alph: { signature: "m" },
  arabic: { signature: "m" },
  roman: { signature: "m" },
  Roman: { signature: "m" },
  fnsymbol: { signature: "m" },
  documentclass: {
    signature: "o m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  usepackage: {
    signature: "o m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  item: {
    signature: "o",
    renderInfo: { hangingIndent: true, namedArguments: ["label"] }
  },
  value: { signature: "m" },
  centering: { renderInfo: { breakAround: true } },
  input: { signature: "m", renderInfo: { breakAround: true } },
  include: { signature: "m", renderInfo: { breakAround: true } },
  includeonly: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  discretionary: { signature: "m m m" },
  hyphenation: { signature: "m" },
  footnote: { signature: "o m", renderInfo: { inParMode: true } },
  footnotemark: { signature: "o" },
  footnotetext: { signature: "o m", renderInfo: { inParMode: true } },
  caption: {
    signature: "o m",
    renderInfo: { inParMode: true, breakAround: true }
  },
  sqrt: { signature: "o m", renderInfo: { inMathMode: true } },
  frac: { signature: "m m", renderInfo: { inMathMode: true } },
  stackrel: { signature: "m m" },
  ensuremath: { signature: "m", renderInfo: { inMathMode: true } },
  abstract: {
    signature: "m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  maketitle: { renderInfo: { breakAround: true } },
  doublespacing: { renderInfo: { breakAround: true } },
  singlespacing: { renderInfo: { breakAround: true } },
  date: { signature: "o m", renderInfo: { breakAround: true } },
  thanks: {
    signature: "m",
    renderInfo: { breakAround: true, inParMode: true }
  },
  pagenumbering: { signature: "m", renderInfo: { breakAround: true } },
  pagestyle: { signature: "m", renderInfo: { breakAround: true } },
  thispagestyle: { signature: "m", renderInfo: { breakAround: true } },
  definecolor: { signature: "m m m", renderInfo: { breakAround: true } },
  pagecolor: { signature: "o m", renderInfo: { breakAround: true } },
  nopagecolor: { renderInfo: { breakAround: true } },
  multicolumn: { signature: "m m m" },
  includegraphics: {
    signature: "s o o m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  rule: { signature: "o m m" },
  part: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  chapter: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  section: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  subsection: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  subsubsection: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  paragraph: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  subparagraph: {
    signature: "s o m",
    renderInfo: {
      breakAround: true,
      inParMode: true,
      namedArguments: ["starred", "tocTitle", "title"]
    }
  },
  appendix: { renderInfo: { breakAround: true, inParMode: true } },
  frontmatter: { renderInfo: { breakAround: true, inParMode: true } },
  mainmatter: { renderInfo: { breakAround: true, inParMode: true } },
  backmatter: { renderInfo: { breakAround: true, inParMode: true } },
  bibitem: { signature: "o m", renderInfo: { hangingIndent: true } },
  cite: { signature: "o m" },
  textrm: { signature: "m", renderInfo: { inParMode: true } },
  textit: { signature: "m", renderInfo: { inParMode: true } },
  textmd: { signature: "m", renderInfo: { inParMode: true } },
  textbf: { signature: "m", renderInfo: { inParMode: true } },
  textup: { signature: "m", renderInfo: { inParMode: true } },
  textsl: { signature: "m", renderInfo: { inParMode: true } },
  textsf: { signature: "m", renderInfo: { inParMode: true } },
  textsc: { signature: "m", renderInfo: { inParMode: true } },
  texttt: { signature: "m", renderInfo: { inParMode: true } },
  underline: { signature: "m", renderInfo: { inParMode: true } },
  emph: { signature: "m", renderInfo: { inParMode: true } },
  textnormal: { signature: "m", renderInfo: { inParMode: true } },
  uppercase: { signature: "m", renderInfo: { inParMode: true } },
  mathbf: { signature: "m" },
  mathsf: { signature: "m" },
  mathtt: { signature: "m" },
  mathit: { signature: "m" },
  mathnormal: { signature: "m" },
  mathcal: { signature: "m" },
  mathrm: { signature: "m" },
  setlength: { signature: "m m", renderInfo: { breakAround: true } },
  ref: { signature: "s m" },
  label: { signature: "o m" },
  printbibliography: { renderInfo: { breakAround: true } },
  addtocontents: { signature: "m m", renderInfo: { breakAround: true } },
  addcontentsline: { signature: "m m m", renderInfo: { breakAround: true } },
  contentsline: { signature: "m m m", renderInfo: { breakAround: true } },
  bibliography: { signature: "m", renderInfo: { breakAround: true } },
  bibliographystyle: { signature: "m", renderInfo: { breakAround: true } }
};
var environments6 = {
  document: {
    processContent: (nodes) => {
      trim(nodes);
      return nodes;
    }
  },
  array: { signature: "o m", renderInfo: { alignContent: true } },
  description: { signature: "o", processContent: cleanEnumerateBody },
  enumerate: {
    signature: "o",
    processContent: cleanEnumerateBody,
    renderInfo: { pgfkeysArgs: true }
  },
  itemize: { signature: "o", processContent: cleanEnumerateBody },
  trivlist: { signature: "o", processContent: cleanEnumerateBody },
  list: { signature: "m m", processContent: cleanEnumerateBody },
  figure: { signature: "o" },
  "figure*": { signature: "o" },
  filecontents: { signature: "o m" },
  "filecontents*": { signature: "o m" },
  minipage: { signature: "o o o m" },
  picture: { signature: "r() d()" },
  tabbing: { renderInfo: { alignContent: true } },
  table: { signature: "o" },
  tabular: { signature: "o m", renderInfo: { alignContent: true } },
  "tabular*": { signature: "m o m", renderInfo: { alignContent: true } },
  thebibliography: {
    signature: "m",
    processContent: (nodes) => cleanEnumerateBody(nodes, "bibitem")
  },
  math: { renderInfo: { inMathMode: true } }
};

// node_modules/@unified-latex/unified-latex-util-pegjs/index.js
var _LatexPegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { document: peg$parsedocument, math: peg$parsemath };
    var peg$startRuleFunction = peg$parsedocument;
    var peg$c0 = "%";
    var peg$c1 = ".";
    var peg$c2 = "verb*";
    var peg$c3 = "verb";
    var peg$c4 = "[";
    var peg$c5 = "]";
    var peg$c6 = "lstinline";
    var peg$c7 = "mintinline";
    var peg$c8 = "mint";
    var peg$c9 = "minted";
    var peg$c10 = "verbatim*";
    var peg$c11 = "verbatim";
    var peg$c12 = "filecontents*";
    var peg$c13 = "filecontents";
    var peg$c14 = "comment";
    var peg$c15 = "lstlisting";
    var peg$c16 = "(";
    var peg$c17 = ")";
    var peg$c18 = "begin";
    var peg$c19 = "end";
    var peg$c20 = "equation*";
    var peg$c21 = "equation";
    var peg$c22 = "align*";
    var peg$c23 = "align";
    var peg$c24 = "alignat*";
    var peg$c25 = "alignat";
    var peg$c26 = "gather*";
    var peg$c27 = "gather";
    var peg$c28 = "multline*";
    var peg$c29 = "multline";
    var peg$c30 = "flalign*";
    var peg$c31 = "flalign";
    var peg$c32 = "split";
    var peg$c33 = "math";
    var peg$c34 = "displaymath";
    var peg$c35 = "\\";
    var peg$c36 = "{";
    var peg$c37 = "}";
    var peg$c38 = "$";
    var peg$c39 = "&";
    var peg$c40 = "\r";
    var peg$c41 = `
`;
    var peg$c42 = `\r
`;
    var peg$c43 = "#";
    var peg$c44 = "^";
    var peg$c45 = "_";
    var peg$c46 = "\x00";
    var peg$r0 = /^[^ \t\n\r]/;
    var peg$r1 = /^[ \t]/;
    var peg$r2 = /^[a-zA-Z]/;
    var peg$r3 = /^[0-9]/;
    var peg$r4 = /^[.,;:\-*\/()!?=+<>[\]`'"~]/;
    var peg$e0 = peg$otherExpectation("document");
    var peg$e1 = peg$otherExpectation("math");
    var peg$e2 = peg$otherExpectation("token");
    var peg$e3 = peg$anyExpectation();
    var peg$e4 = peg$otherExpectation("parbreak");
    var peg$e5 = peg$otherExpectation("math token");
    var peg$e6 = peg$otherExpectation("nonchar token");
    var peg$e7 = peg$literalExpectation("%", false);
    var peg$e8 = peg$otherExpectation("whitespace");
    var peg$e9 = peg$otherExpectation("number");
    var peg$e10 = peg$literalExpectation(".", false);
    var peg$e11 = peg$otherExpectation("special macro");
    var peg$e12 = peg$literalExpectation("verb*", false);
    var peg$e13 = peg$literalExpectation("verb", false);
    var peg$e14 = peg$literalExpectation("[", false);
    var peg$e15 = peg$literalExpectation("]", false);
    var peg$e16 = peg$classExpectation([" ", "\t", `
`, "\r"], true, false);
    var peg$e17 = peg$otherExpectation("verbatim listings");
    var peg$e18 = peg$literalExpectation("lstinline", false);
    var peg$e19 = peg$otherExpectation("verbatim minted");
    var peg$e20 = peg$literalExpectation("mintinline", false);
    var peg$e21 = peg$literalExpectation("mint", false);
    var peg$e22 = peg$otherExpectation("verbatim minted environment");
    var peg$e23 = peg$literalExpectation("minted", false);
    var peg$e24 = peg$otherExpectation("verbatim environment");
    var peg$e25 = peg$literalExpectation("verbatim*", false);
    var peg$e26 = peg$literalExpectation("verbatim", false);
    var peg$e27 = peg$literalExpectation("filecontents*", false);
    var peg$e28 = peg$literalExpectation("filecontents", false);
    var peg$e29 = peg$literalExpectation("comment", false);
    var peg$e30 = peg$literalExpectation("lstlisting", false);
    var peg$e31 = peg$otherExpectation("macro");
    var peg$e32 = peg$otherExpectation("group");
    var peg$e33 = peg$otherExpectation("environment");
    var peg$e34 = peg$otherExpectation("math environment");
    var peg$e36 = peg$literalExpectation("(", false);
    var peg$e37 = peg$literalExpectation(")", false);
    var peg$e38 = peg$literalExpectation("begin", false);
    var peg$e39 = peg$literalExpectation("end", false);
    var peg$e40 = peg$literalExpectation("equation*", false);
    var peg$e41 = peg$literalExpectation("equation", false);
    var peg$e42 = peg$literalExpectation("align*", false);
    var peg$e43 = peg$literalExpectation("align", false);
    var peg$e44 = peg$literalExpectation("alignat*", false);
    var peg$e45 = peg$literalExpectation("alignat", false);
    var peg$e46 = peg$literalExpectation("gather*", false);
    var peg$e47 = peg$literalExpectation("gather", false);
    var peg$e48 = peg$literalExpectation("multline*", false);
    var peg$e49 = peg$literalExpectation("multline", false);
    var peg$e50 = peg$literalExpectation("flalign*", false);
    var peg$e51 = peg$literalExpectation("flalign", false);
    var peg$e52 = peg$literalExpectation("split", false);
    var peg$e53 = peg$literalExpectation("math", false);
    var peg$e54 = peg$literalExpectation("displaymath", false);
    var peg$e55 = peg$otherExpectation("escape");
    var peg$e56 = peg$literalExpectation("\\", false);
    var peg$e57 = peg$literalExpectation("{", false);
    var peg$e58 = peg$literalExpectation("}", false);
    var peg$e59 = peg$literalExpectation("$", false);
    var peg$e60 = peg$literalExpectation("&", false);
    var peg$e61 = peg$otherExpectation("newline");
    var peg$e62 = peg$literalExpectation("\r", false);
    var peg$e63 = peg$literalExpectation(`
`, false);
    var peg$e64 = peg$literalExpectation(`\r
`, false);
    var peg$e65 = peg$literalExpectation("#", false);
    var peg$e66 = peg$literalExpectation("^", false);
    var peg$e67 = peg$literalExpectation("_", false);
    var peg$e68 = peg$literalExpectation("\x00", false);
    var peg$e69 = peg$classExpectation([" ", "\t"], false, false);
    var peg$e70 = peg$otherExpectation("letter");
    var peg$e71 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
    var peg$e72 = peg$otherExpectation("digit");
    var peg$e73 = peg$classExpectation([["0", "9"]], false, false);
    var peg$e74 = peg$otherExpectation("punctuation");
    var peg$e75 = peg$classExpectation([".", ",", ";", ":", "-", "*", "/", "(", ")", "!", "?", "=", "+", "<", ">", "[", "]", "`", "'", '"', "~"], false, false);
    var peg$e76 = peg$otherExpectation("full comment");
    var peg$e77 = peg$otherExpectation("comment");
    var peg$f0 = function(content3) {
      return createNode("root", { content: content3.flatMap((x) => x) });
    };
    var peg$f1 = function(t) {
      return t;
    };
    var peg$f2 = function(eq) {
      return createNode("inlinemath", { content: eq.flatMap((x) => x) });
    };
    var peg$f3 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f4 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f5 = function() {
      return createNode("parbreak");
    };
    var peg$f6 = function(x) {
      return x;
    };
    var peg$f7 = function(x) {
      return x;
    };
    var peg$f8 = function() {
      return createNode("macro", { content: "^", escapeToken: "" });
    };
    var peg$f9 = function() {
      return createNode("macro", { content: "_", escapeToken: "" });
    };
    var peg$f10 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f11 = function() {
      return createNode("whitespace");
    };
    var peg$f12 = function(a, b) {
      return a.join("") + "." + b.join("");
    };
    var peg$f13 = function(b) {
      return "." + b.join("");
    };
    var peg$f14 = function(a) {
      return a.join("") + ".";
    };
    var peg$f15 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f16 = function(env, e, end) {
      return end == e;
    };
    var peg$f17 = function(env, e, x) {
      return x;
    };
    var peg$f18 = function(env, e, x, end) {
      return end == e;
    };
    var peg$f19 = function(env, e, x) {
      return createNode("verb", {
        env,
        escape: e,
        content: x.join("")
      });
    };
    var peg$f20 = function(x) {
      return x;
    };
    var peg$f21 = function(x) {
      return createNode("displaymath", { content: x.flatMap((x2) => x2) });
    };
    var peg$f22 = function(x) {
      return x;
    };
    var peg$f23 = function(x) {
      return createNode("inlinemath", { content: x.flatMap((x2) => x2) });
    };
    var peg$f24 = function(x) {
      return x;
    };
    var peg$f25 = function(x) {
      return createNode("displaymath", { content: x.flatMap((x2) => x2) });
    };
    var peg$f26 = function(end) {
      return end.type === "string" && end.content === "]";
    };
    var peg$f27 = function(x) {
      return x;
    };
    var peg$f28 = function(o) {
      return [
        createNode("string", { content: "[" }),
        ...o,
        createNode("string", { content: "]" })
      ];
    };
    var peg$f29 = function(x) {
      return x;
    };
    var peg$f30 = function(v) {
      return createNode("group", {
        content: createNode("string", { content: v.join("") })
      });
    };
    var peg$f31 = function(d, end) {
      return end == d;
    };
    var peg$f32 = function(d, x) {
      return x;
    };
    var peg$f33 = function(d, v, end) {
      return end == d;
    };
    var peg$f34 = function(d, v) {
      return [
        createNode("string", { content: d }),
        createNode("string", { content: v.join("") }),
        createNode("string", { content: d })
      ];
    };
    var peg$f35 = function(macro, option, verbatim) {
      return [
        createNode("macro", { content: macro }),
        ...option || [],
        ...[].concat(verbatim)
      ];
    };
    var peg$f36 = function(macro, option, language, verbatim) {
      return [
        createNode("macro", { content: macro }),
        ...option || [],
        language,
        ...[].concat(verbatim)
      ];
    };
    var peg$f37 = function(env, option, language, end_env) {
      return compare_env({ content: [env] }, end_env);
    };
    var peg$f38 = function(env, option, language, body) {
      const content3 = [
        ...option || [],
        language,
        { type: "string", content: body }
      ];
      return createNode("environment", {
        env,
        content: content3
      });
    };
    var peg$f39 = function(env, end_env) {
      return compare_env({ content: [env] }, end_env);
    };
    var peg$f40 = function(env, x) {
      return x;
    };
    var peg$f41 = function(env, body) {
      return createNode("verbatim", {
        env,
        content: body
      });
    };
    var peg$f42 = function(n) {
      return n.join("");
    };
    var peg$f43 = function(n) {
      return n;
    };
    var peg$f44 = function(m) {
      return createNode("macro", { content: m });
    };
    var peg$f45 = function(c) {
      return c;
    };
    var peg$f46 = function(x) {
      return createNode("group", { content: x.flatMap((x2) => x2) });
    };
    var peg$f47 = function(g) {
      return text5().slice(1, -1);
    };
    var peg$f48 = function(env, env_comment, end_env) {
      return compare_env(env, end_env);
    };
    var peg$f49 = function(env, env_comment, x) {
      return x;
    };
    var peg$f50 = function(env, env_comment, body) {
      body = body.flatMap((x) => x);
      return createNode("environment", {
        env,
        content: env_comment ? [env_comment, ...body] : body
      });
    };
    var peg$f51 = function(env, env_comment, end_env) {
      return compare_env({ content: [env] }, end_env);
    };
    var peg$f52 = function(env, env_comment, x) {
      return x;
    };
    var peg$f53 = function(env, env_comment, body) {
      body = body.flatMap((x) => x);
      return createNode("mathenv", {
        env,
        content: env_comment ? [env_comment, ...body] : body
      });
    };
    var peg$f56 = function(e) {
      return createNode("string", { content: e });
    };
    var peg$f57 = function() {
      return createNode("string", { content: "\\" });
    };
    var peg$f58 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f59 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f60 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f61 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f62 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f63 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f64 = function(s2) {
      return createNode("string", { content: s2 });
    };
    var peg$f65 = function() {
      return " ";
    };
    var peg$f66 = function(p) {
      return createNode("string", { content: p });
    };
    var peg$f67 = function(leading_sp, comment) {
      return createNode("comment", {
        ...comment,
        sameline: false,
        leadingWhitespace: leading_sp.length > 0
      });
    };
    var peg$f68 = function(spaces, x) {
      return createNode("comment", {
        ...x,
        sameline: true,
        leadingWhitespace: spaces.length > 0
      });
    };
    var peg$f69 = function(c) {
      return c;
    };
    var peg$f70 = function(c) {
      return { content: c.join(""), suffixParbreak: true };
    };
    var peg$f71 = function(c) {
      return c;
    };
    var peg$f72 = function(c) {
      return { content: c.join("") };
    };
    var peg$f73 = function() {
      var loc = location();
      return loc.start.column === 1;
    };
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$resultsCache = {};
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function text5() {
      return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function peg$literalExpectation(text22, ignoreCase) {
      return { type: "literal", text: text22, ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts, inverted, ignoreCase };
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$otherExpectation(description) {
      return { type: "other", description };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parsedocument() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 0;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsetoken();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsetoken();
      }
      peg$savedPos = s0;
      s1 = peg$f0(s1);
      s0 = s1;
      peg$silentFails--;
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e0);
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsemath() {
      var s0, s1;
      var key = peg$currPos * 52 + 1;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = [];
      s1 = peg$parsemath_token();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsemath_token();
      }
      peg$silentFails--;
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e1);
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsetoken() {
      var s0, s1, s2, s3, s4, s5;
      var key = peg$currPos * 52 + 2;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$parsespecial_macro();
      if (s0 === peg$FAILED) {
        s0 = peg$parsemacro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsefull_comment();
          if (s0 === peg$FAILED) {
            s0 = peg$parsegroup();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsemath_shift();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parsemath_shift();
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = undefined;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsemath_token();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s3 = peg$f1(s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$currPos;
                    s4 = peg$currPos;
                    peg$silentFails++;
                    s5 = peg$parsemath_shift();
                    peg$silentFails--;
                    if (s5 === peg$FAILED) {
                      s4 = undefined;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsemath_token();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s3 = peg$f1(s5);
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  }
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsemath_shift();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f2(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parsealignment_tab();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseparbreak();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsemacro_parameter();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseignore();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsenumber();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsewhitespace();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsepunctuation();
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              s1 = peg$currPos;
                              s2 = [];
                              s3 = peg$currPos;
                              s4 = peg$currPos;
                              peg$silentFails++;
                              s5 = peg$parsenonchar_token();
                              peg$silentFails--;
                              if (s5 === peg$FAILED) {
                                s4 = undefined;
                              } else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                              }
                              if (s4 !== peg$FAILED) {
                                if (input.length > peg$currPos) {
                                  s5 = input.charAt(peg$currPos);
                                  peg$currPos++;
                                } else {
                                  s5 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e3);
                                  }
                                }
                                if (s5 !== peg$FAILED) {
                                  s4 = [s4, s5];
                                  s3 = s4;
                                } else {
                                  peg$currPos = s3;
                                  s3 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                              }
                              if (s3 !== peg$FAILED) {
                                while (s3 !== peg$FAILED) {
                                  s2.push(s3);
                                  s3 = peg$currPos;
                                  s4 = peg$currPos;
                                  peg$silentFails++;
                                  s5 = peg$parsenonchar_token();
                                  peg$silentFails--;
                                  if (s5 === peg$FAILED) {
                                    s4 = undefined;
                                  } else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                  }
                                  if (s4 !== peg$FAILED) {
                                    if (input.length > peg$currPos) {
                                      s5 = input.charAt(peg$currPos);
                                      peg$currPos++;
                                    } else {
                                      s5 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e3);
                                      }
                                    }
                                    if (s5 !== peg$FAILED) {
                                      s4 = [s4, s5];
                                      s3 = s4;
                                    } else {
                                      peg$currPos = s3;
                                      s3 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                  }
                                }
                              } else {
                                s2 = peg$FAILED;
                              }
                              if (s2 !== peg$FAILED) {
                                s1 = input.substring(s1, peg$currPos);
                              } else {
                                s1 = s2;
                              }
                              if (s1 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$f3(s1);
                              }
                              s0 = s1;
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsebegin_group();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseend_group();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parsemath_shift();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      if (input.length > peg$currPos) {
                                        s1 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e3);
                                        }
                                      }
                                      if (s1 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$f4(s1);
                                      }
                                      s0 = s1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseparbreak() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      var key = peg$currPos * 52 + 3;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parsesp();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsesp();
      }
      s3 = peg$parsenl();
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$currPos;
        s6 = [];
        s7 = peg$parsesp();
        while (s7 !== peg$FAILED) {
          s6.push(s7);
          s7 = peg$parsesp();
        }
        s7 = peg$parsenl();
        if (s7 !== peg$FAILED) {
          s6 = [s6, s7];
          s5 = s6;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parsesp();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsesp();
            }
            s7 = peg$parsenl();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsesp();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parsesp();
          }
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parsecomment_start();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = undefined;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            s2 = [s2, s3, s4, s5, s6];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = [];
        s3 = peg$parsesp();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsesp();
        }
        s3 = peg$parsenl();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = [];
          s7 = peg$parsesp();
          while (s7 !== peg$FAILED) {
            s6.push(s7);
            s7 = peg$parsesp();
          }
          s7 = peg$parsenl();
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$parsesp();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parsesp();
              }
              s7 = peg$parsenl();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f5();
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsemath_token() {
      var s0, s1, s2, s3, s4;
      var key = peg$currPos * 52 + 4;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$parsespecial_macro();
      if (s0 === peg$FAILED) {
        s0 = peg$parsemacro();
        if (s0 === peg$FAILED) {
          s0 = peg$parsefull_comment();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsewhitespace();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewhitespace();
            }
            s2 = peg$parsegroup();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsewhitespace();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsewhitespace();
              }
              peg$savedPos = s0;
              s0 = peg$f6(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsewhitespace();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsewhitespace();
              }
              s2 = peg$parsealignment_tab();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsewhitespace();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsewhitespace();
                }
                peg$savedPos = s0;
                s0 = peg$f7(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parsemacro_parameter();
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = [];
                  s2 = peg$parsewhitespace();
                  while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    s2 = peg$parsewhitespace();
                  }
                  s2 = peg$parsesuperscript();
                  if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$parsewhitespace();
                    while (s4 !== peg$FAILED) {
                      s3.push(s4);
                      s4 = peg$parsewhitespace();
                    }
                    peg$savedPos = s0;
                    s0 = peg$f8();
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$parsewhitespace();
                    while (s2 !== peg$FAILED) {
                      s1.push(s2);
                      s2 = peg$parsewhitespace();
                    }
                    s2 = peg$parsesubscript();
                    if (s2 !== peg$FAILED) {
                      s3 = [];
                      s4 = peg$parsewhitespace();
                      while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        s4 = peg$parsewhitespace();
                      }
                      peg$savedPos = s0;
                      s0 = peg$f9();
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseignore();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsewhitespace();
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          if (input.length > peg$currPos) {
                            s1 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e3);
                            }
                          }
                          if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$f10(s1);
                          }
                          s0 = s1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e5);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsenonchar_token() {
      var s0;
      var key = peg$currPos * 52 + 5;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$parseescape();
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 37) {
          s0 = peg$c0;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parsebegin_group();
          if (s0 === peg$FAILED) {
            s0 = peg$parseend_group();
            if (s0 === peg$FAILED) {
              s0 = peg$parsemath_shift();
              if (s0 === peg$FAILED) {
                s0 = peg$parsealignment_tab();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsenl();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsemacro_parameter();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseignore();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsesp();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsepunctuation();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseEOF();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e6);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsewhitespace() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      var key = peg$currPos * 52 + 6;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parsenl();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsesp();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsesp();
        }
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = [];
        s3 = peg$parsesp();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsesp();
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsenl();
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsecomment_start();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = undefined;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parsesp();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsesp();
              }
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$parsenl();
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = undefined;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s2 = [s2, s3, s4, s5, s6];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = [];
          s2 = peg$parsesp();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsesp();
            }
          } else {
            s1 = peg$FAILED;
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f11();
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e8);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsenumber() {
      var s0, s1, s2, s3, s4, s5;
      var key = peg$currPos * 52 + 7;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parsenum();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsenum();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c1;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsenum();
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsenum();
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f12(s2, s4);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsenum();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsenum();
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f13(s3);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s2 = [];
          s3 = peg$parsenum();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsenum();
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c1;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e10);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s1;
              s1 = peg$f14(s2);
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f15(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e9);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsespecial_macro() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      var key = peg$currPos * 52 + 8;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseescape();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5) === peg$c2) {
          s2 = peg$c2;
          peg$currPos += 5;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c3) {
            s2 = peg$c3;
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e13);
            }
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            if (input.length > peg$currPos) {
              s8 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s8 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s9 = peg$f16(s2, s3, s8);
              if (s9) {
                s9 = undefined;
              } else {
                s9 = peg$FAILED;
              }
              if (s9 !== peg$FAILED) {
                s8 = [s8, s9];
                s7 = s8;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = undefined;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s5 = peg$f17(s2, s3, s7);
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s8 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s9 = peg$f16(s2, s3, s8);
                if (s9) {
                  s9 = undefined;
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 === peg$FAILED) {
                s6 = undefined;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s5 = peg$f17(s2, s3, s7);
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            s5 = peg$currPos;
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s6 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s7 = peg$f18(s2, s3, s4, s6);
              if (s7) {
                s7 = undefined;
              } else {
                s7 = peg$FAILED;
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f19(s2, s3, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseverbatim_listings();
        if (s0 === peg$FAILED) {
          s0 = peg$parseverbatim_minted();
          if (s0 === peg$FAILED) {
            s0 = peg$parseverbatim_minted_environment();
            if (s0 === peg$FAILED) {
              s0 = peg$parseverbatim_environment();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsebegin_display_math();
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  s5 = peg$parseend_display_math();
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = undefined;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsemath_token();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s3 = peg$f20(s5);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$currPos;
                    s4 = peg$currPos;
                    peg$silentFails++;
                    s5 = peg$parseend_display_math();
                    peg$silentFails--;
                    if (s5 === peg$FAILED) {
                      s4 = undefined;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsemath_token();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s3 = peg$f20(s5);
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  }
                  s3 = peg$parseend_display_math();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f21(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsebegin_inline_math();
                  if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$currPos;
                    peg$silentFails++;
                    s5 = peg$parseend_inline_math();
                    peg$silentFails--;
                    if (s5 === peg$FAILED) {
                      s4 = undefined;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsemath_token();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s3 = peg$f22(s5);
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$currPos;
                      s4 = peg$currPos;
                      peg$silentFails++;
                      s5 = peg$parseend_inline_math();
                      peg$silentFails--;
                      if (s5 === peg$FAILED) {
                        s4 = undefined;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsemath_token();
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s3 = peg$f22(s5);
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    }
                    s3 = peg$parseend_inline_math();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f23(s2);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsemath_shift();
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parsemath_shift();
                      if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$currPos;
                        s5 = peg$currPos;
                        peg$silentFails++;
                        s6 = peg$currPos;
                        s7 = peg$parsemath_shift();
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parsemath_shift();
                          if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                        peg$silentFails--;
                        if (s6 === peg$FAILED) {
                          s5 = undefined;
                        } else {
                          peg$currPos = s5;
                          s5 = peg$FAILED;
                        }
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parsemath_token();
                          if (s6 !== peg$FAILED) {
                            peg$savedPos = s4;
                            s4 = peg$f24(s6);
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                        while (s4 !== peg$FAILED) {
                          s3.push(s4);
                          s4 = peg$currPos;
                          s5 = peg$currPos;
                          peg$silentFails++;
                          s6 = peg$currPos;
                          s7 = peg$parsemath_shift();
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parsemath_shift();
                            if (s8 !== peg$FAILED) {
                              s7 = [s7, s8];
                              s6 = s7;
                            } else {
                              peg$currPos = s6;
                              s6 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                          peg$silentFails--;
                          if (s6 === peg$FAILED) {
                            s5 = undefined;
                          } else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                          }
                          if (s5 !== peg$FAILED) {
                            s6 = peg$parsemath_token();
                            if (s6 !== peg$FAILED) {
                              peg$savedPos = s4;
                              s4 = peg$f24(s6);
                            } else {
                              peg$currPos = s4;
                              s4 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                        }
                        s4 = peg$parsemath_shift();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsemath_shift();
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f25(s3);
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsemath_environment();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseenvironment();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e11);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsesquare_bracket_argument() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      var key = peg$currPos * 52 + 9;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c4;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e14);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$currPos;
        s6 = peg$parsetoken();
        if (s6 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s7 = peg$f26(s6);
          if (s7) {
            s7 = undefined;
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = undefined;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsetoken();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s3 = peg$f27(s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$currPos;
          s6 = peg$parsetoken();
          if (s6 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s7 = peg$f26(s6);
            if (s7) {
              s7 = undefined;
            } else {
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = undefined;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetoken();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s3 = peg$f27(s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (input.charCodeAt(peg$currPos) === 93) {
          s3 = peg$c5;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f28(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseverbatim_group() {
      var s0, s1, s2, s3, s4, s5;
      var key = peg$currPos * 52 + 10;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$parsebegin_group();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseend_group();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = undefined;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s3 = peg$f29(s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = undefined;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s3 = peg$f29(s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        s3 = peg$parseend_group();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f30(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseverbatim_delimited_by_char() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      var key = peg$currPos * 52 + 11;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (peg$r0.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e16);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$currPos;
        if (input.length > peg$currPos) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s6 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s7 = peg$f31(s1, s6);
          if (s7) {
            s7 = undefined;
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = undefined;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s3 = peg$f32(s1, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$currPos;
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s6 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s7 = peg$f31(s1, s6);
            if (s7) {
              s7 = undefined;
            } else {
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = undefined;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s3 = peg$f32(s1, s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        s3 = peg$currPos;
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e3);
          }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s5 = peg$f33(s1, s2, s4);
          if (s5) {
            s5 = undefined;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f34(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseverbatim_listings() {
      var s0, s1, s2, s3, s4;
      var key = peg$currPos * 52 + 12;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseescape();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 9) === peg$c6) {
          s2 = peg$c6;
          peg$currPos += 9;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesquare_bracket_argument();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = peg$parseverbatim_group();
          if (s4 === peg$FAILED) {
            s4 = peg$parseverbatim_delimited_by_char();
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f35(s2, s3, s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e17);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseverbatim_minted() {
      var s0, s1, s2, s3, s4, s5;
      var key = peg$currPos * 52 + 13;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseescape();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 10) === peg$c7) {
          s2 = peg$c7;
          peg$currPos += 10;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c8) {
            s2 = peg$c8;
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesquare_bracket_argument();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = peg$parsegroup();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseverbatim_group();
            if (s5 === peg$FAILED) {
              s5 = peg$parseverbatim_delimited_by_char();
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f36(s2, s3, s4, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e19);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseverbatim_minted_environment() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
      var key = peg$currPos * 52 + 14;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsebegin_env();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebegin_group();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c9) {
            s3 = peg$c9;
            peg$currPos += 6;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseend_group();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsesquare_bracket_argument();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              s6 = peg$parsegroup();
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                s8 = [];
                s9 = peg$currPos;
                s10 = peg$currPos;
                peg$silentFails++;
                s11 = peg$currPos;
                s12 = peg$parseend_env();
                if (s12 !== peg$FAILED) {
                  s13 = peg$parsegroup();
                  if (s13 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s14 = peg$f37(s3, s5, s6, s13);
                    if (s14) {
                      s14 = undefined;
                    } else {
                      s14 = peg$FAILED;
                    }
                    if (s14 !== peg$FAILED) {
                      s12 = [s12, s13, s14];
                      s11 = s12;
                    } else {
                      peg$currPos = s11;
                      s11 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s11;
                    s11 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s11;
                  s11 = peg$FAILED;
                }
                peg$silentFails--;
                if (s11 === peg$FAILED) {
                  s10 = undefined;
                } else {
                  peg$currPos = s10;
                  s10 = peg$FAILED;
                }
                if (s10 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s11 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s11 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s11 !== peg$FAILED) {
                    s10 = [s10, s11];
                    s9 = s10;
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                while (s9 !== peg$FAILED) {
                  s8.push(s9);
                  s9 = peg$currPos;
                  s10 = peg$currPos;
                  peg$silentFails++;
                  s11 = peg$currPos;
                  s12 = peg$parseend_env();
                  if (s12 !== peg$FAILED) {
                    s13 = peg$parsegroup();
                    if (s13 !== peg$FAILED) {
                      peg$savedPos = peg$currPos;
                      s14 = peg$f37(s3, s5, s6, s13);
                      if (s14) {
                        s14 = undefined;
                      } else {
                        s14 = peg$FAILED;
                      }
                      if (s14 !== peg$FAILED) {
                        s12 = [s12, s13, s14];
                        s11 = s12;
                      } else {
                        peg$currPos = s11;
                        s11 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s11;
                      s11 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s11;
                    s11 = peg$FAILED;
                  }
                  peg$silentFails--;
                  if (s11 === peg$FAILED) {
                    s10 = undefined;
                  } else {
                    peg$currPos = s10;
                    s10 = peg$FAILED;
                  }
                  if (s10 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s11 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s11 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                      }
                    }
                    if (s11 !== peg$FAILED) {
                      s10 = [s10, s11];
                      s9 = s10;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                }
                s7 = input.substring(s7, peg$currPos);
                s8 = peg$parseend_env();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsebegin_group();
                  if (s9 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c9) {
                      s10 = peg$c9;
                      peg$currPos += 6;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e23);
                      }
                    }
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parseend_group();
                      if (s11 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f38(s3, s5, s6, s7);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e22);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseverbatim_environment() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
      var key = peg$currPos * 52 + 15;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsebegin_env();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebegin_group();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseverbatim_env_name();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseend_group();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = [];
              s7 = peg$currPos;
              s8 = peg$currPos;
              peg$silentFails++;
              s9 = peg$currPos;
              s10 = peg$parseend_env();
              if (s10 !== peg$FAILED) {
                s11 = peg$parsegroup();
                if (s11 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s12 = peg$f39(s3, s11);
                  if (s12) {
                    s12 = undefined;
                  } else {
                    s12 = peg$FAILED;
                  }
                  if (s12 !== peg$FAILED) {
                    s10 = [s10, s11, s12];
                    s9 = s10;
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
              } else {
                peg$currPos = s9;
                s9 = peg$FAILED;
              }
              peg$silentFails--;
              if (s9 === peg$FAILED) {
                s8 = undefined;
              } else {
                peg$currPos = s8;
                s8 = peg$FAILED;
              }
              if (s8 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s9 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
                if (s9 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s7 = peg$f40(s3, s9);
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$currPos;
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$currPos;
                s10 = peg$parseend_env();
                if (s10 !== peg$FAILED) {
                  s11 = peg$parsegroup();
                  if (s11 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s12 = peg$f39(s3, s11);
                    if (s12) {
                      s12 = undefined;
                    } else {
                      s12 = peg$FAILED;
                    }
                    if (s12 !== peg$FAILED) {
                      s10 = [s10, s11, s12];
                      s9 = s10;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = undefined;
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s9 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e3);
                    }
                  }
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s7;
                    s7 = peg$f40(s3, s9);
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              }
              s5 = input.substring(s5, peg$currPos);
              s6 = peg$parseend_env();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsebegin_group();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseverbatim_env_name();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseend_group();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f41(s3, s5);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e24);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseverbatim_env_name() {
      var s0;
      var key = peg$currPos * 52 + 16;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      if (input.substr(peg$currPos, 9) === peg$c10) {
        s0 = peg$c10;
        peg$currPos += 9;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e25);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 8) === peg$c11) {
          s0 = peg$c11;
          peg$currPos += 8;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 13) === peg$c12) {
            s0 = peg$c12;
            peg$currPos += 13;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 12) === peg$c13) {
              s0 = peg$c13;
              peg$currPos += 12;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e28);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 7) === peg$c14) {
                s0 = peg$c14;
                peg$currPos += 7;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e29);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c15) {
                  s0 = peg$c15;
                  peg$currPos += 10;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e30);
                  }
                }
              }
            }
          }
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsemacro() {
      var s0, s1, s2, s3, s4;
      var key = peg$currPos * 52 + 17;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseescape();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsechar();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsechar();
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s1;
          s1 = peg$f42(s3);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$parseescape();
        if (s2 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f43(s3);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f44(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e31);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsegroup() {
      var s0, s1, s2, s3, s4, s5;
      var key = peg$currPos * 52 + 18;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsebegin_group();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseend_group();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = undefined;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsetoken();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s3 = peg$f45(s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseend_group();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = undefined;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsetoken();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s3 = peg$f45(s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        s3 = peg$parseend_group();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f46(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e32);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsegroup_contents_as_string() {
      var s0, s1;
      var key = peg$currPos * 52 + 19;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$parsegroup();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f47();
      }
      s0 = s1;
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseenvironment() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
      var key = peg$currPos * 52 + 20;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsebegin_env();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsegroup_contents_as_string();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesameline_comment();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$currPos;
          s8 = peg$parseend_env();
          if (s8 !== peg$FAILED) {
            s9 = peg$parsegroup_contents_as_string();
            if (s9 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s10 = peg$f48(s2, s3, s9);
              if (s10) {
                s10 = undefined;
              } else {
                s10 = peg$FAILED;
              }
              if (s10 !== peg$FAILED) {
                s8 = [s8, s9, s10];
                s7 = s8;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
          } else {
            peg$currPos = s7;
            s7 = peg$FAILED;
          }
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = undefined;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$parsetoken();
            if (s7 !== peg$FAILED) {
              peg$savedPos = s5;
              s5 = peg$f49(s2, s3, s7);
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$currPos;
            s8 = peg$parseend_env();
            if (s8 !== peg$FAILED) {
              s9 = peg$parsegroup_contents_as_string();
              if (s9 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s10 = peg$f48(s2, s3, s9);
                if (s10) {
                  s10 = undefined;
                } else {
                  s10 = peg$FAILED;
                }
                if (s10 !== peg$FAILED) {
                  s8 = [s8, s9, s10];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = undefined;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetoken();
              if (s7 !== peg$FAILED) {
                peg$savedPos = s5;
                s5 = peg$f49(s2, s3, s7);
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          s5 = peg$parseend_env();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsegroup_contents_as_string();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f50(s2, s3, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e33);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsemath_environment() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
      var key = peg$currPos * 52 + 21;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsebegin_env();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebegin_group();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemath_env_name();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseend_group();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsesameline_comment();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              s6 = [];
              s7 = peg$currPos;
              s8 = peg$currPos;
              peg$silentFails++;
              s9 = peg$currPos;
              s10 = peg$parseend_env();
              if (s10 !== peg$FAILED) {
                s11 = peg$parsegroup();
                if (s11 !== peg$FAILED) {
                  peg$savedPos = peg$currPos;
                  s12 = peg$f51(s3, s5, s11);
                  if (s12) {
                    s12 = undefined;
                  } else {
                    s12 = peg$FAILED;
                  }
                  if (s12 !== peg$FAILED) {
                    s10 = [s10, s11, s12];
                    s9 = s10;
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
              } else {
                peg$currPos = s9;
                s9 = peg$FAILED;
              }
              peg$silentFails--;
              if (s9 === peg$FAILED) {
                s8 = undefined;
              } else {
                peg$currPos = s8;
                s8 = peg$FAILED;
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$parsemath_token();
                if (s9 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s7 = peg$f52(s3, s5, s9);
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$currPos;
                s8 = peg$currPos;
                peg$silentFails++;
                s9 = peg$currPos;
                s10 = peg$parseend_env();
                if (s10 !== peg$FAILED) {
                  s11 = peg$parsegroup();
                  if (s11 !== peg$FAILED) {
                    peg$savedPos = peg$currPos;
                    s12 = peg$f51(s3, s5, s11);
                    if (s12) {
                      s12 = undefined;
                    } else {
                      s12 = peg$FAILED;
                    }
                    if (s12 !== peg$FAILED) {
                      s10 = [s10, s11, s12];
                      s9 = s10;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = undefined;
                } else {
                  peg$currPos = s8;
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsemath_token();
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s7;
                    s7 = peg$f52(s3, s5, s9);
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              }
              s7 = peg$parseend_env();
              if (s7 !== peg$FAILED) {
                s8 = peg$parsebegin_group();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsemath_env_name();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parseend_group();
                    if (s10 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f53(s3, s5, s6);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e34);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsebegin_display_math() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 23;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$parseescape();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 91) {
          s2 = peg$c4;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseend_display_math() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 24;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$parseescape();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 93) {
          s2 = peg$c5;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e15);
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsebegin_inline_math() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 25;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$parseescape();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s2 = peg$c16;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e36);
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseend_inline_math() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 26;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$parseescape();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 41) {
          s2 = peg$c17;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsebegin_env() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 27;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$parseescape();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 5) === peg$c18) {
          s2 = peg$c18;
          peg$currPos += 5;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e38);
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseend_env() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 28;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$parseescape();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c19) {
          s2 = peg$c19;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e39);
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsemath_env_name() {
      var s0, s1;
      var key = peg$currPos * 52 + 29;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c20) {
        s1 = peg$c20;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e40);
        }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 8) === peg$c21) {
          s1 = peg$c21;
          peg$currPos += 8;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e41);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c22) {
            s1 = peg$c22;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e42);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c23) {
              s1 = peg$c23;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e43);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 8) === peg$c24) {
                s1 = peg$c24;
                peg$currPos += 8;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e44);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c25) {
                  s1 = peg$c25;
                  peg$currPos += 7;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e45);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c26) {
                    s1 = peg$c26;
                    peg$currPos += 7;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e46);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c27) {
                      s1 = peg$c27;
                      peg$currPos += 6;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e47);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 9) === peg$c28) {
                        s1 = peg$c28;
                        peg$currPos += 9;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e48);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 8) === peg$c29) {
                          s1 = peg$c29;
                          peg$currPos += 8;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e49);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c30) {
                            s1 = peg$c30;
                            peg$currPos += 8;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e50);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 7) === peg$c31) {
                              s1 = peg$c31;
                              peg$currPos += 7;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e51);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 5) === peg$c32) {
                                s1 = peg$c32;
                                peg$currPos += 5;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e52);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 4) === peg$c33) {
                                  s1 = peg$c33;
                                  peg$currPos += 4;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e53);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 11) === peg$c34) {
                                    s1 = peg$c34;
                                    peg$currPos += 11;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e54);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f56(s1);
      }
      s0 = s1;
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseescape() {
      var s0, s1;
      var key = peg$currPos * 52 + 30;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e56);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f57();
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e55);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsebegin_group() {
      var s0, s1;
      var key = peg$currPos * 52 + 31;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c36;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e57);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f58(s1);
      }
      s0 = s1;
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseend_group() {
      var s0, s1;
      var key = peg$currPos * 52 + 32;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 125) {
        s1 = peg$c37;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e58);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f59(s1);
      }
      s0 = s1;
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsemath_shift() {
      var s0, s1;
      var key = peg$currPos * 52 + 33;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 36) {
        s1 = peg$c38;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e59);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f60(s1);
      }
      s0 = s1;
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsealignment_tab() {
      var s0, s1;
      var key = peg$currPos * 52 + 34;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        s1 = peg$c39;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e60);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f61(s1);
      }
      s0 = s1;
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsenl() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 35;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 13) {
        s2 = peg$c40;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e62);
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = undefined;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 10) {
          s2 = peg$c41;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e63);
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c40;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e62);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c42) {
            s0 = peg$c42;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e64);
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e61);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsemacro_parameter() {
      var s0, s1;
      var key = peg$currPos * 52 + 36;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c43;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e65);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f62(s1);
      }
      s0 = s1;
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsesuperscript() {
      var s0, s1;
      var key = peg$currPos * 52 + 37;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 94) {
        s1 = peg$c44;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e66);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f63(s1);
      }
      s0 = s1;
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsesubscript() {
      var s0, s1;
      var key = peg$currPos * 52 + 38;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 95) {
        s1 = peg$c45;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e67);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f64(s1);
      }
      s0 = s1;
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseignore() {
      var s0;
      var key = peg$currPos * 52 + 39;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      if (input.charCodeAt(peg$currPos) === 0) {
        s0 = peg$c46;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e68);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsesp() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 40;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$r1.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e69);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e69);
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f65();
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e8);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsechar() {
      var s0;
      var key = peg$currPos * 52 + 41;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      if (peg$r2.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e71);
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e70);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsenum() {
      var s0;
      var key = peg$currPos * 52 + 42;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      if (peg$r3.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e73);
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e72);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsepunctuation() {
      var s0, s1;
      var key = peg$currPos * 52 + 43;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      if (peg$r4.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e75);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f66(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e74);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsecomment_start() {
      var s0;
      var key = peg$currPos * 52 + 44;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      if (input.charCodeAt(peg$currPos) === 37) {
        s0 = peg$c0;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e7);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsefull_comment() {
      var s0;
      var key = peg$currPos * 52 + 45;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$parseownline_comment();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesameline_comment();
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e76);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseownline_comment() {
      var s0, s1, s2, s3;
      var key = peg$currPos * 52 + 46;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parsesp();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsesp();
      }
      s3 = peg$parsenl();
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      s2 = peg$parseleading_sp();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecomment();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f67(s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsesameline_comment() {
      var s0, s1, s2;
      var key = peg$currPos * 52 + 47;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsesp();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsesp();
      }
      s2 = peg$parsecomment();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f68(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsecomment() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      var key = peg$currPos * 52 + 48;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsecomment_start();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parsenl();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = undefined;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e3);
            }
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s3 = peg$f69(s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parsenl();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = undefined;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s3 = peg$f69(s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseparbreak();
        peg$silentFails--;
        if (s4 !== peg$FAILED) {
          peg$currPos = s3;
          s3 = undefined;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f70(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsecomment_start();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parsenl();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = undefined;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e3);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s3 = peg$f71(s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parsenl();
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = undefined;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s3 = peg$f71(s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          s3 = peg$currPos;
          s4 = peg$parsenl();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsesp();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsesp();
            }
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsecomment_start();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = undefined;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$parsenl();
            if (s3 === peg$FAILED) {
              s3 = peg$parseEOF();
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f72(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e77);
        }
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseleading_sp() {
      var s0, s1, s2, s3, s4;
      var key = peg$currPos * 52 + 49;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parsestart_of_line();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsesp();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsesp();
        }
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parsestart_of_line() {
      var s0;
      var key = peg$currPos * 52 + 50;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      peg$savedPos = peg$currPos;
      s0 = peg$f73();
      if (s0) {
        s0 = undefined;
      } else {
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function peg$parseEOF() {
      var s0, s1;
      var key = peg$currPos * 52 + 51;
      var cached = peg$resultsCache[key];
      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }
      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = undefined;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };
      return s0;
    }
    function toString2(e) {
      if (typeof e === "string") {
        return e;
      }
      if (typeof e.content === "string") {
        return e.content;
      }
      if (e && e.type === "whitespace") {
        return " ";
      }
      return e;
    }
    function compare_env(g1, g2) {
      const g1Name = typeof g1 === "string" ? g1 : g1.content.map(toString2).join("");
      const g2Name = typeof g2 === "string" ? g2 : g2.content.map(toString2).join("");
      return g1Name === g2Name;
    }
    function createNode(type, extra = {}) {
      return { type, ...extra, position: location() };
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _AlignEnvironmentPegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { body: peg$parsebody };
    var peg$startRuleFunction = peg$parsebody;
    var peg$e0 = peg$anyExpectation();
    var peg$f0 = function() {
      return [];
    };
    var peg$f1 = function(x) {
      return { cells: [], colSeps: [], ...x };
    };
    var peg$f2 = function(rowItems, rowSep, trailingComment) {
      return { ...rowItems, rowSep, trailingComment };
    };
    var peg$f3 = function(rowItems, trailingComment) {
      return { ...rowItems, rowSep: null, trailingComment };
    };
    var peg$f4 = function(x) {
      return x;
    };
    var peg$f5 = function(x) {
      return {
        cells: [],
        colSeps: [],
        rowSep: null,
        trailingComment: x
      };
    };
    var peg$f6 = function(x) {
      return x;
    };
    var peg$f7 = function(colSep, cell) {
      return { colSep, cell };
    };
    var peg$f8 = function(colSep) {
      return { colSep };
    };
    var peg$f9 = function(a, b) {
      return processRow(a, b);
    };
    var peg$f10 = function(b) {
      return processRow(null, b);
    };
    var peg$f11 = function(tok) {
      return options2.isSameLineComment(tok);
    };
    var peg$f12 = function(tok) {
      return tok;
    };
    var peg$f13 = function(tok) {
      return options2.isOwnLineComment(tok);
    };
    var peg$f14 = function(tok) {
      return tok;
    };
    var peg$f15 = function(tok) {
      return options2.isWhitespace(tok);
    };
    var peg$f16 = function(tok) {
      return tok;
    };
    var peg$f17 = function(tok) {
      return options2.isRowSep(tok);
    };
    var peg$f18 = function(tok) {
      return tok;
    };
    var peg$f19 = function(tok) {
      return options2.isColSep(tok);
    };
    var peg$f20 = function(tok) {
      return tok;
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parsebody() {
      var s0, s1;
      s0 = [];
      s1 = peg$parsecomment_only_line();
      if (s1 === peg$FAILED) {
        s1 = peg$parserow_with_end();
        if (s1 === peg$FAILED) {
          s1 = peg$parserow_without_end();
        }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsecomment_only_line();
          if (s1 === peg$FAILED) {
            s1 = peg$parserow_with_end();
            if (s1 === peg$FAILED) {
              s1 = peg$parserow_without_end();
            }
          }
        }
      } else {
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseEOL();
        if (s1 !== peg$FAILED) {
          s1 = peg$f0();
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parserow_with_end() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parserow_items();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s2 = peg$f1(s2);
      s1 = s2;
      s2 = peg$parserow_sep();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetrailing_comment();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s0 = peg$f2(s1, s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parserow_without_end() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parserow_items();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsetrailing_comment();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        s0 = peg$f3(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsetrailing_comment() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace();
      }
      s2 = peg$parsesame_line_comment();
      if (s2 !== peg$FAILED) {
        s0 = peg$f4(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecomment_only_line() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace();
      }
      s2 = peg$parseown_line_comment();
      if (s2 !== peg$FAILED) {
        s0 = peg$f5(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsetoken() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parserow_sep();
      if (s2 === peg$FAILED) {
        s2 = peg$parsecol_sep();
        if (s2 === peg$FAILED) {
          s2 = peg$parsetrailing_comment();
          if (s2 === peg$FAILED) {
            s2 = peg$parseown_line_comment();
          }
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = undefined;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f6(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecell() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsetoken();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsetoken();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      return s0;
    }
    function peg$parseseparated_cell() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsecol_sep();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecell();
        if (s2 !== peg$FAILED) {
          s0 = peg$f7(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsecol_sep();
        if (s1 !== peg$FAILED) {
          s1 = peg$f8(s1);
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parserow_items() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parsecell();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseseparated_cell();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseseparated_cell();
        }
        s0 = peg$f9(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseseparated_cell();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseseparated_cell();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s1 = peg$f10(s1);
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parsesame_line_comment() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f11(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f12(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseown_line_comment() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f13(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f14(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsewhitespace() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f15(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f16(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parserow_sep() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f17(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f18(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecol_sep() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f19(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f20(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseEOL() {
      var s0, s1;
      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = undefined;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function processRow(leadCell, otherCells) {
      const cells = [leadCell || []];
      const seps = [];
      for (const x of otherCells) {
        cells.push(x.cell || []);
        seps.push(x.colSep);
      }
      return { cells, colSeps: seps };
    }
    if (!options2.isWhitespace) {
      try {
        Object.assign(options2, createMatchers(["\\", "hline", "cr"], ["&"]));
      } catch (e) {
        console.warn("Error when initializing parser", e);
      }
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _ArgSpecPegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { args_spec_list: peg$parseargs_spec_list };
    var peg$startRuleFunction = peg$parseargs_spec_list;
    var peg$c1 = "v";
    var peg$c2 = "b";
    var peg$c3 = "!";
    var peg$c4 = "D";
    var peg$c5 = "d";
    var peg$c6 = "s";
    var peg$c7 = "O";
    var peg$c8 = "o";
    var peg$c9 = "e";
    var peg$c10 = "E";
    var peg$c11 = "t";
    var peg$c12 = "R";
    var peg$c13 = "r";
    var peg$c14 = "u";
    var peg$c15 = "m";
    var peg$c16 = "{";
    var peg$c17 = "}";
    var peg$c18 = " ";
    var peg$c19 = `
`;
    var peg$c20 = "\r";
    var peg$c21 = "\\";
    var peg$r0 = /^[{ ]/;
    var peg$r1 = /^[a-zA-Z]/;
    var peg$r2 = /^[{}]/;
    var peg$e0 = peg$literalExpectation("+", false);
    var peg$e1 = peg$literalExpectation("v", false);
    var peg$e2 = peg$anyExpectation();
    var peg$e3 = peg$literalExpectation("b", false);
    var peg$e4 = peg$literalExpectation("!", false);
    var peg$e5 = peg$literalExpectation("D", false);
    var peg$e6 = peg$literalExpectation("d", false);
    var peg$e7 = peg$literalExpectation("s", false);
    var peg$e8 = peg$literalExpectation("O", false);
    var peg$e9 = peg$literalExpectation("o", false);
    var peg$e10 = peg$literalExpectation("e", false);
    var peg$e11 = peg$literalExpectation("E", false);
    var peg$e12 = peg$literalExpectation("t", false);
    var peg$e13 = peg$literalExpectation("R", false);
    var peg$e14 = peg$literalExpectation("r", false);
    var peg$e15 = peg$literalExpectation("u", false);
    var peg$e16 = peg$classExpectation(["{", " "], false, false);
    var peg$e17 = peg$literalExpectation("m", false);
    var peg$e18 = peg$literalExpectation("{", false);
    var peg$e19 = peg$literalExpectation("}", false);
    var peg$e20 = peg$literalExpectation(" ", false);
    var peg$e21 = peg$literalExpectation(`
`, false);
    var peg$e22 = peg$literalExpectation("\r", false);
    var peg$e23 = peg$literalExpectation("\\", false);
    var peg$e24 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
    var peg$e25 = peg$classExpectation(["{", "}"], false, false);
    var peg$f0 = function(x) {
      return x;
    };
    var peg$f1 = function(spec) {
      return spec;
    };
    var peg$f2 = function(spec) {
      return spec;
    };
    var peg$f3 = function(openBrace) {
      return createNode("verbatim", { openBrace, closeBrace: openBrace });
    };
    var peg$f4 = function() {
      return createNode("body");
    };
    var peg$f5 = function(leading_bang, spec) {
      return leading_bang ? { ...spec, noLeadingWhitespace: true } : spec;
    };
    var peg$f6 = function(braceSpec, defaultArg) {
      return createNode("optional", { ...braceSpec, defaultArg });
    };
    var peg$f7 = function(braceSpec) {
      return createNode("optional", braceSpec);
    };
    var peg$f8 = function() {
      return createNode("optionalStar");
    };
    var peg$f9 = function(g) {
      return createNode("optional", { defaultArg: g });
    };
    var peg$f10 = function() {
      return createNode("optional");
    };
    var peg$f11 = function(args) {
      return createNode("embellishment", {
        embellishmentTokens: args
      });
    };
    var peg$f12 = function(args, g) {
      return createNode("embellishment", {
        embellishmentTokens: args,
        defaultArg: g
      });
    };
    var peg$f13 = function(tok) {
      return createNode("optionalToken", { token: tok });
    };
    var peg$f14 = function(braceSpec, defaultArg) {
      return createNode("mandatory", { ...braceSpec, defaultArg });
    };
    var peg$f15 = function(braceSpec) {
      return createNode("mandatory", braceSpec);
    };
    var peg$f16 = function(stopTokens) {
      return createNode("until", { stopTokens });
    };
    var peg$f17 = function(x) {
      return [x];
    };
    var peg$f18 = function(g) {
      return g.content;
    };
    var peg$f19 = function() {
      return createNode("mandatory");
    };
    var peg$f20 = function(openBrace, closeBrace) {
      return { openBrace, closeBrace };
    };
    var peg$f21 = function(g) {
      return g.content.map(groupToStr).join("");
    };
    var peg$f22 = function(t) {
      return [t];
    };
    var peg$f23 = function(args) {
      return args.filter((a) => !a.match(/^\s*$/));
    };
    var peg$f24 = function(content3) {
      return { type: "group", content: content3 };
    };
    var peg$f25 = function() {
      return "";
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$literalExpectation(text22, ignoreCase) {
      return { type: "literal", text: text22, ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts, inverted, ignoreCase };
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parseargs_spec_list() {
      var s0, s1, s2, s4;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      peg$parsewhitespace();
      s4 = peg$parsearg_spec();
      if (s4 !== peg$FAILED) {
        s2 = peg$f0(s4);
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        peg$parsewhitespace();
        s4 = peg$parsearg_spec();
        if (s4 !== peg$FAILED) {
          s2 = peg$f0(s4);
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      s2 = peg$parsewhitespace();
      s0 = peg$f1(s1);
      return s0;
    }
    function peg$parsearg_spec() {
      var s0, s2;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        peg$currPos++;
      } else {
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      s2 = peg$parseoptional();
      if (s2 === peg$FAILED) {
        s2 = peg$parsemandatory();
        if (s2 === peg$FAILED) {
          s2 = peg$parseverbatim();
          if (s2 === peg$FAILED) {
            s2 = peg$parserequired();
            if (s2 === peg$FAILED) {
              s2 = peg$parsebody();
              if (s2 === peg$FAILED) {
                s2 = peg$parseuntil();
              }
            }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        s0 = peg$f2(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseverbatim() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 118) {
        s1 = peg$c1;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f3(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsebody() {
      var s0, s1;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 98) {
        s1 = peg$c2;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f4();
      }
      s0 = s1;
      return s0;
    }
    function peg$parseoptional() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 33) {
        s1 = peg$c3;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      s2 = peg$parseoptional_star();
      if (s2 === peg$FAILED) {
        s2 = peg$parseoptional_standard();
        if (s2 === peg$FAILED) {
          s2 = peg$parseoptional_delimited();
          if (s2 === peg$FAILED) {
            s2 = peg$parseoptional_embellishment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseoptional_token();
            }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        s0 = peg$f5(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseoptional_delimited() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 68) {
        s1 = peg$c4;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e5);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebrace_spec();
        s3 = peg$parsearg();
        if (s3 !== peg$FAILED) {
          s0 = peg$f6(s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 100) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsebrace_spec();
          s0 = peg$f7(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    function peg$parseoptional_star() {
      var s0, s1;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 115) {
        s1 = peg$c6;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e7);
        }
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f8();
      }
      s0 = s1;
      return s0;
    }
    function peg$parseoptional_standard() {
      var s0, s1, s3;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 79) {
        s1 = peg$c7;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e8);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$parsewhitespace();
        s3 = peg$parsearg();
        if (s3 !== peg$FAILED) {
          s0 = peg$f9(s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 111) {
          s1 = peg$c8;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        if (s1 !== peg$FAILED) {
          s1 = peg$f10();
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parseoptional_embellishment() {
      var s0, s1, s3, s5;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 101) {
        s1 = peg$c9;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e10);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$parsewhitespace();
        s3 = peg$parseargs();
        if (s3 !== peg$FAILED) {
          s0 = peg$f11(s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 69) {
          s1 = peg$c10;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$parsewhitespace();
          s3 = peg$parseargs();
          if (s3 !== peg$FAILED) {
            peg$parsewhitespace();
            s5 = peg$parseargs();
            if (s5 !== peg$FAILED) {
              s0 = peg$f12(s3, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    function peg$parseoptional_token() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 116) {
        s1 = peg$c11;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e12);
        }
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f13(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parserequired() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 82) {
        s1 = peg$c12;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e13);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebrace_spec();
        s3 = peg$parsearg();
        if (s3 !== peg$FAILED) {
          s0 = peg$f14(s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 114) {
          s1 = peg$c13;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsebrace_spec();
          s0 = peg$f15(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    function peg$parseuntil() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 117) {
        s1 = peg$c14;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e15);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseuntil_stop_token();
        if (s2 !== peg$FAILED) {
          s0 = peg$f16(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseuntil_stop_token() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (peg$r0.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e16);
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = undefined;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f17(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsebraced_group();
        if (s1 !== peg$FAILED) {
          s1 = peg$f18(s1);
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parsemandatory() {
      var s0, s1;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 109) {
        s1 = peg$c15;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e17);
        }
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f19();
      }
      s0 = s1;
      return s0;
    }
    function peg$parsebrace_spec() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parsewhitespace_token();
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = undefined;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsemacro();
        if (s4 === peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s1 = input.substring(s1, peg$currPos);
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = peg$parsewhitespace_token();
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = undefined;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parsemacro();
        if (s5 === peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s2 = input.substring(s2, peg$currPos);
      s0 = peg$f20(s1, s2);
      return s0;
    }
    function peg$parsearg() {
      var s0, s1;
      s0 = peg$parsetoken();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsebraced_group();
        if (s1 !== peg$FAILED) {
          s1 = peg$f21(s1);
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parseargs() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parsetoken();
      if (s1 !== peg$FAILED) {
        s1 = peg$f22(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsearg();
          if (s3 === peg$FAILED) {
            s3 = peg$parsewhitespace_token();
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsearg();
            if (s3 === peg$FAILED) {
              s3 = peg$parsewhitespace_token();
            }
          }
          if (input.charCodeAt(peg$currPos) === 125) {
            s3 = peg$c17;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          if (s3 !== peg$FAILED) {
            s0 = peg$f23(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    function peg$parsebraced_group() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c16;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e18);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 125) {
          s6 = peg$c17;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = undefined;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parsebraced_group();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = undefined;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$parsetoken();
            if (s7 === peg$FAILED) {
              s7 = peg$parsewhitespace_token();
            }
            if (s7 !== peg$FAILED) {
              s5 = [s5, s6, s7];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = input.substring(s3, peg$currPos);
        } else {
          s3 = s4;
        }
        if (s3 === peg$FAILED) {
          s3 = peg$parsebraced_group();
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 125) {
            s6 = peg$c17;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e19);
            }
          }
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = undefined;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parsebraced_group();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = undefined;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetoken();
              if (s7 === peg$FAILED) {
                s7 = peg$parsewhitespace_token();
              }
              if (s7 !== peg$FAILED) {
                s5 = [s5, s6, s7];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s3 = input.substring(s3, peg$currPos);
          } else {
            s3 = s4;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$parsebraced_group();
          }
        }
        if (input.charCodeAt(peg$currPos) === 125) {
          s3 = peg$c17;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        if (s3 !== peg$FAILED) {
          s0 = peg$f24(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsewhitespace() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace_token();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace_token();
      }
      s1 = peg$f25();
      s0 = s1;
      return s0;
    }
    function peg$parsewhitespace_token() {
      var s0;
      if (input.charCodeAt(peg$currPos) === 32) {
        s0 = peg$c18;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e20);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 10) {
          s0 = peg$c19;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c20;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
        }
      }
      return s0;
    }
    function peg$parsemacro() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s2 = peg$c21;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e23);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e24);
              }
            }
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c21;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e23);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e24);
            }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = undefined;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
      }
      return s0;
    }
    function peg$parsetoken() {
      var s0, s1, s2, s3;
      s0 = peg$parsemacro();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = undefined;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parsewhitespace_token();
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = undefined;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s3 !== peg$FAILED) {
              s0 = s3;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    const DEFAULT_OPTIONS = {
      optional: { openBrace: "[", closeBrace: "]" },
      mandatory: { openBrace: "{", closeBrace: "}" }
    };
    function createNode(type, options22) {
      const computedOptions = DEFAULT_OPTIONS[type] || {};
      return { type, ...computedOptions, ...options22 };
    }
    function groupToStr(node2) {
      if (typeof node2 !== "object" || !node2) {
        return node2;
      }
      if (node2.type === "group") {
        return `{${node2.content.map(groupToStr).join("")}}`;
      }
      return node2;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _PgfkeysPegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { body: peg$parsebody };
    var peg$startRuleFunction = peg$parsebody;
    var peg$e0 = peg$anyExpectation();
    var peg$f0 = function() {
      return [];
    };
    var peg$f1 = function(rowItems, trailingComment) {
      return {
        itemParts: [],
        ...rowItems,
        trailingComment,
        trailingComma: true
      };
    };
    var peg$f2 = function(rowItems, trailingComment) {
      return { ...rowItems, trailingComment };
    };
    var peg$f3 = function(a, b) {
      return processItem(a, b);
    };
    var peg$f4 = function(b) {
      return processItem(null, b);
    };
    var peg$f5 = function(cell) {
      return { cell };
    };
    var peg$f6 = function() {
      return {};
    };
    var peg$f7 = function(part) {
      return part;
    };
    var peg$f8 = function(x) {
      return x;
    };
    var peg$f9 = function(space, x) {
      return {
        trailingComment: x,
        leadingParbreak: space.parbreak > 0
      };
    };
    var peg$f10 = function(list3) {
      return {
        whitespace: list3.filter((x) => options2.isWhitespace(x)).length,
        parbreak: list3.filter((x) => options2.isParbreak(x)).length
      };
    };
    var peg$f11 = function() {
      return !options2.allowParenGroups;
    };
    var peg$f12 = function(tok) {
      return options2.isSameLineComment(tok);
    };
    var peg$f13 = function(tok) {
      return tok;
    };
    var peg$f14 = function(tok) {
      return options2.isOwnLineComment(tok);
    };
    var peg$f15 = function(tok) {
      return tok;
    };
    var peg$f16 = function(tok) {
      return options2.isWhitespace(tok);
    };
    var peg$f17 = function(tok) {
      return tok;
    };
    var peg$f18 = function(tok) {
      return options2.isParbreak(tok);
    };
    var peg$f19 = function(tok) {
      return tok;
    };
    var peg$f20 = function(tok) {
      return options2.isComma(tok);
    };
    var peg$f21 = function(tok) {
      return tok;
    };
    var peg$f22 = function(tok) {
      return options2.isEquals(tok);
    };
    var peg$f23 = function(tok) {
      return tok;
    };
    var peg$f24 = function(tok) {
      return options2.isChar(tok, "(");
    };
    var peg$f25 = function(tok) {
      return tok;
    };
    var peg$f26 = function(tok) {
      return options2.isChar(tok, ")");
    };
    var peg$f27 = function(tok) {
      return tok;
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parsebody() {
      var s0, s1, s2;
      s0 = [];
      s1 = peg$parsecomment_only_line();
      if (s1 === peg$FAILED) {
        s1 = peg$parseitem_with_end();
        if (s1 === peg$FAILED) {
          s1 = peg$parseitem_without_end();
        }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsecomment_only_line();
          if (s1 === peg$FAILED) {
            s1 = peg$parseitem_with_end();
            if (s1 === peg$FAILED) {
              s1 = peg$parseitem_without_end();
            }
          }
        }
      } else {
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsewhitespace();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsewhitespace();
        }
        s2 = peg$parseEOL();
        if (s2 !== peg$FAILED) {
          s0 = peg$f0();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    function peg$parseitem_with_end() {
      var s0, s2, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      peg$parsewhitespace_or_parbreaks();
      s2 = peg$parserow_items();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      peg$parsewhitespace_or_parbreaks();
      s4 = peg$parseitem_sep();
      if (s4 !== peg$FAILED) {
        s5 = [];
        s6 = peg$parsewhitespace();
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          s6 = peg$parsewhitespace();
        }
        s6 = peg$parsetrailing_comment();
        if (s6 === peg$FAILED) {
          s6 = null;
        }
        s7 = [];
        s8 = peg$parsewhitespace();
        while (s8 !== peg$FAILED) {
          s7.push(s8);
          s8 = peg$parsewhitespace();
        }
        s0 = peg$f1(s2, s6);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseitem_without_end() {
      var s0, s2, s3;
      s0 = peg$currPos;
      peg$parsewhitespace_or_parbreaks();
      s2 = peg$parserow_items();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsetrailing_comment();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s0 = peg$f2(s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parserow_items() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parseitem_part();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseseparated_part();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseseparated_part();
        }
        s0 = peg$f3(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseseparated_part();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseseparated_part();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s1 = peg$f4(s1);
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parseseparated_part() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseparbreak();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseparbreak();
      }
      s2 = peg$parseequals();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseparbreak();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseparbreak();
        }
        s4 = peg$parseitem_part();
        if (s4 !== peg$FAILED) {
          s0 = peg$f5(s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseparbreak();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseparbreak();
        }
        s2 = peg$parseequals();
        if (s2 !== peg$FAILED) {
          s0 = peg$f6();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      return s0;
    }
    function peg$parseitem_part() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace();
      }
      s2 = peg$currPos;
      s3 = [];
      s4 = peg$parsenon_whitespace_non_parbreak_token();
      if (s4 === peg$FAILED) {
        s4 = peg$currPos;
        s5 = peg$parsewhitespace();
        if (s5 === peg$FAILED) {
          s5 = peg$parseparbreak();
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$currPos;
          s8 = [];
          s9 = peg$parsewhitespace();
          if (s9 === peg$FAILED) {
            s9 = peg$parseparbreak();
          }
          while (s9 !== peg$FAILED) {
            s8.push(s9);
            s9 = peg$parsewhitespace();
            if (s9 === peg$FAILED) {
              s9 = peg$parseparbreak();
            }
          }
          s9 = peg$parsenon_whitespace_non_parbreak_token();
          if (s9 !== peg$FAILED) {
            s8 = [s8, s9];
            s7 = s8;
          } else {
            peg$currPos = s7;
            s7 = peg$FAILED;
          }
          peg$silentFails--;
          if (s7 !== peg$FAILED) {
            peg$currPos = s6;
            s6 = undefined;
          } else {
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      }
      if (s4 !== peg$FAILED) {
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsenon_whitespace_non_parbreak_token();
          if (s4 === peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parsewhitespace();
            if (s5 === peg$FAILED) {
              s5 = peg$parseparbreak();
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              peg$silentFails++;
              s7 = peg$currPos;
              s8 = [];
              s9 = peg$parsewhitespace();
              if (s9 === peg$FAILED) {
                s9 = peg$parseparbreak();
              }
              while (s9 !== peg$FAILED) {
                s8.push(s9);
                s9 = peg$parsewhitespace();
                if (s9 === peg$FAILED) {
                  s9 = peg$parseparbreak();
                }
              }
              s9 = peg$parsenon_whitespace_non_parbreak_token();
              if (s9 !== peg$FAILED) {
                s8 = [s8, s9];
                s7 = s8;
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              peg$silentFails--;
              if (s7 !== peg$FAILED) {
                peg$currPos = s6;
                s6 = undefined;
              } else {
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = input.substring(s2, peg$currPos);
      } else {
        s2 = s3;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsewhitespace();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsewhitespace();
        }
        s0 = peg$f7(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsetrailing_comment() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace();
      }
      s2 = peg$parsesame_line_comment();
      if (s2 !== peg$FAILED) {
        s0 = peg$f8(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecomment_only_line() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsewhitespace_or_parbreaks();
      s2 = peg$parseown_line_comment();
      if (s2 !== peg$FAILED) {
        s0 = peg$f9(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsetoken() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsenon_token();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      return s0;
    }
    function peg$parsenon_whitespace_non_parbreak_token() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsewhitespace();
      if (s3 === peg$FAILED) {
        s3 = peg$parseparbreak();
      }
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseparen_block();
        if (s3 === peg$FAILED) {
          s3 = peg$parsetoken();
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      return s0;
    }
    function peg$parsenon_token() {
      var s0;
      s0 = peg$parseitem_sep();
      if (s0 === peg$FAILED) {
        s0 = peg$parseequals();
        if (s0 === peg$FAILED) {
          s0 = peg$parsetrailing_comment();
          if (s0 === peg$FAILED) {
            s0 = peg$parseown_line_comment();
          }
        }
      }
      return s0;
    }
    function peg$parsewhitespace_or_parbreaks() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace();
      if (s2 === peg$FAILED) {
        s2 = peg$parseparbreak();
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace();
        if (s2 === peg$FAILED) {
          s2 = peg$parseparbreak();
        }
      }
      s1 = peg$f10(s1);
      s0 = s1;
      return s0;
    }
    function peg$parseparen_block() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      s0 = peg$currPos;
      s1 = peg$f11();
      if (s1) {
        s1 = peg$FAILED;
      } else {
        s1 = undefined;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = peg$parseopen_paren();
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$currPos;
          s7 = peg$currPos;
          peg$silentFails++;
          s8 = peg$parseclose_paren();
          peg$silentFails--;
          if (s8 === peg$FAILED) {
            s7 = undefined;
          } else {
            peg$currPos = s7;
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s8 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s8 !== peg$FAILED) {
              s7 = [s7, s8];
              s6 = s7;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$currPos;
            s7 = peg$currPos;
            peg$silentFails++;
            s8 = peg$parseclose_paren();
            peg$silentFails--;
            if (s8 === peg$FAILED) {
              s7 = undefined;
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          }
          s6 = peg$parseclose_paren();
          if (s6 !== peg$FAILED) {
            s4 = [s4, s5, s6];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = input.substring(s2, peg$currPos);
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsesame_line_comment() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f12(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f13(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseown_line_comment() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f14(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f15(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsewhitespace() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f16(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f17(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseparbreak() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f18(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f19(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseitem_sep() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f20(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f21(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseequals() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f22(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f23(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseopen_paren() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f24(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f25(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseclose_paren() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f26(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f27(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseEOL() {
      var s0, s1;
      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = undefined;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function processItem(leadCell, otherCells) {
      const cells = [leadCell || []];
      for (const x of otherCells) {
        cells.push(x.cell || []);
      }
      return { itemParts: cells };
    }
    if (!options2.isWhitespace) {
      try {
        Object.assign(options2, {
          isChar: (node2, char) => node2.type === "string" && node2.content === char,
          isComma(node2) {
            return node2.type === "string" && node2.content === ",";
          },
          isEquals(node2) {
            return node2.type === "string" && node2.content === "=";
          },
          isParbreak(node2) {
            return node2.type === "parbreak";
          },
          isWhitespace(node2) {
            return node2.type === "whitespace";
          },
          isSameLineComment: (node2) => node2.type === "comment" && node2.sameline,
          isOwnLineComment: (node2) => node2.type === "comment" && !node2.sameline,
          isComment: (node2) => node2.type === "comment",
          allowParenGroups: true
        });
      } catch (e) {
        console.warn("Error when initializing parser", e);
      }
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _MacroSubstitutionPegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { body: peg$parsebody };
    var peg$startRuleFunction = peg$parsebody;
    var peg$e0 = peg$anyExpectation();
    var peg$f0 = function(e) {
      return [].concat(...e).filter((n) => !!n);
    };
    var peg$f1 = function() {
      return [];
    };
    var peg$f2 = function(tok) {
      return options2.isHash(tok);
    };
    var peg$f3 = function(tok) {
      return tok;
    };
    var peg$f4 = function(tok) {
      return options2.isNumber(tok);
    };
    var peg$f5 = function(tok) {
      return tok;
    };
    var peg$f6 = function() {
      return { type: "string", content: "#" };
    };
    var peg$f7 = function(num) {
      const split = options2.splitNumber(num);
      return [{ type: "hash_number", number: split.number }, split.rest];
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parsebody() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsedouble_hash();
      if (s2 === peg$FAILED) {
        s2 = peg$parsehash_number();
        if (s2 === peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsedouble_hash();
          if (s2 === peg$FAILED) {
            s2 = peg$parsehash_number();
            if (s2 === peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f0(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseEOL();
        if (s1 !== peg$FAILED) {
          s1 = peg$f1();
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parsehash() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f2(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f3(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsenumber() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f4(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f5(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsedouble_hash() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsehash();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsehash();
        if (s2 !== peg$FAILED) {
          s0 = peg$f6();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsehash_number() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsehash();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          s0 = peg$f7(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseEOL() {
      var s0, s1;
      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = undefined;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    if (!options2.isHash) {
      try {
        Object.assign(options2, {
          isHash: (node2) => node2.type === "string" && node2.content === "#",
          isNumber: (node2) => node2.type === "string" && 0 < +node2.content.charAt(0),
          splitNumber: (node2) => {
            const number = +node2.content.charAt(0);
            if (node2.content.length > 1) {
              return {
                number,
                rest: {
                  type: "string",
                  content: node2.content.slice(1)
                }
              };
            }
            return { number };
          }
        });
      } catch (e) {
        console.warn("Error when initializing parser", e);
      }
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _LigaturesPegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { body: peg$parsebody };
    var peg$startRuleFunction = peg$parsebody;
    var peg$e0 = peg$anyExpectation();
    var peg$f0 = function(e) {
      return [].concat(...e).filter((n) => !!n);
    };
    var peg$f1 = function() {
      return [];
    };
    var peg$f2 = function(toks) {
      return options2.isRecognized(toks);
    };
    var peg$f3 = function(toks) {
      return options2.isRecognized(toks);
    };
    var peg$f4 = function(tok1, tok2) {
      const split = options2.split(tok2);
      return options2.isRecognized([tok1, split[0]]);
    };
    var peg$f5 = function(tok1, tok2) {
      const split = options2.split(tok2);
      return [options2.isRecognized([tok1, split[0]]), split[1]];
    };
    var peg$f6 = function(tok1, tok2) {
      return options2.isRecognized([tok1, tok2]);
    };
    var peg$f7 = function(tok1, tok2) {
      return options2.isRecognized([tok1, tok2]);
    };
    var peg$f8 = function(toks) {
      return options2.isRecognized(toks);
    };
    var peg$f9 = function(toks) {
      return options2.isRecognized(toks);
    };
    var peg$f10 = function(tok) {
      return options2.isRecognized([tok]);
    };
    var peg$f11 = function(tok) {
      return options2.isRecognized([tok]);
    };
    var peg$f12 = function(tok) {
      return options2.isMacro(tok);
    };
    var peg$f13 = function(tok) {
      return tok;
    };
    var peg$f14 = function(tok) {
      return options2.isWhitespace(tok);
    };
    var peg$f15 = function(tok) {
      return tok;
    };
    var peg$f16 = function(tok) {
      return options2.isSplitable(tok);
    };
    var peg$f17 = function(tok) {
      return tok;
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parsebody() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsetriple_ligature();
      if (s2 === peg$FAILED) {
        s2 = peg$parsedouble_ligature();
        if (s2 === peg$FAILED) {
          s2 = peg$parsemono_ligature();
          if (s2 === peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsetriple_ligature();
          if (s2 === peg$FAILED) {
            s2 = peg$parsedouble_ligature();
            if (s2 === peg$FAILED) {
              s2 = peg$parsemono_ligature();
              if (s2 === peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
              }
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f0(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseEOL();
        if (s1 !== peg$FAILED) {
          s1 = peg$f1();
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parsetriple_ligature() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f2(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f3(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsedouble_ligature() {
      var s0;
      s0 = peg$parsedouble_macro_ligature();
      if (s0 === peg$FAILED) {
        s0 = peg$parsedouble_macro_ligature_extracted();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_char_ligature();
        }
      }
      return s0;
    }
    function peg$parsedouble_macro_ligature_extracted() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$parsemacro();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewhitespace();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewhitespace();
        }
        s3 = peg$parsesplitable();
        if (s3 !== peg$FAILED) {
          s4 = peg$f4(s1, s3);
          if (s4) {
            s4 = undefined;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s0 = peg$f5(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsedouble_macro_ligature() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$parsemacro();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewhitespace();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewhitespace();
        }
        if (input.length > peg$currPos) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$f6(s1, s3);
          if (s4) {
            s4 = undefined;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s0 = peg$f7(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsedouble_char_ligature() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f8(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f9(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsemono_ligature() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f10(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f11(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsemacro() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f12(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f13(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsewhitespace() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f14(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f15(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsesplitable() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f16(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f17(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseEOL() {
      var s0, s1;
      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = undefined;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    if (!options2.isWhitespace) {
      try {
        Object.assign(options2, {
          isMacro: (node2) => node2.type === "macro",
          isWhitespace: (node2) => node2.type === "whitespace",
          isRecognized: (nodes) => {
            if (nodes.length == 2 && nodes[0].content === "^" && nodes[1].content === "o") {
              return { type: "string", content: "" };
            }
            return null;
          },
          isSplitable: (node2) => node2.type === "string" && node2.content.length > 1,
          split: (node2) => [
            { type: "string", content: node2.content.charAt(0) },
            { type: "string", content: node2.content.slice(1) }
          ]
        });
      } catch (e) {
        console.warn("Error when initializing parser", e);
      }
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _XColorPegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { start: peg$parsestart };
    var peg$startRuleFunction = peg$parsestart;
    var peg$c0 = ";";
    var peg$c1 = ",";
    var peg$c2 = ":";
    var peg$c3 = "/";
    var peg$c4 = ">";
    var peg$c5 = "!";
    var peg$c6 = ".";
    var peg$c7 = "!![";
    var peg$c8 = "]";
    var peg$c9 = "!!";
    var peg$c10 = "+";
    var peg$c11 = "-";
    var peg$r0 = /^[a-zA-Z0-9]/;
    var peg$r1 = /^[0-9]/;
    var peg$r2 = /^[ \t\n\r]/;
    var peg$r3 = /^[0-9a-fA-F]/;
    var peg$e0 = peg$anyExpectation();
    var peg$e1 = peg$literalExpectation(";", false);
    var peg$e2 = peg$literalExpectation(",", false);
    var peg$e3 = peg$otherExpectation("model list");
    var peg$e4 = peg$literalExpectation(":", false);
    var peg$e5 = peg$literalExpectation("/", false);
    var peg$e6 = peg$otherExpectation("model");
    var peg$e7 = peg$otherExpectation("color spec list");
    var peg$e8 = peg$otherExpectation("color spec");
    var peg$e9 = peg$otherExpectation("color");
    var peg$e10 = peg$otherExpectation("function expression");
    var peg$e11 = peg$literalExpectation(">", false);
    var peg$e12 = peg$otherExpectation("function");
    var peg$e13 = peg$otherExpectation("extended expression");
    var peg$e14 = peg$otherExpectation("core model");
    var peg$e15 = peg$otherExpectation("expr");
    var peg$e16 = peg$literalExpectation("!", false);
    var peg$e17 = peg$otherExpectation("mix expr");
    var peg$e18 = peg$otherExpectation("name");
    var peg$e19 = peg$literalExpectation(".", false);
    var peg$e20 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
    var peg$e21 = peg$otherExpectation("postfix");
    var peg$e22 = peg$literalExpectation("!![", false);
    var peg$e23 = peg$literalExpectation("]", false);
    var peg$e24 = peg$literalExpectation("!!", false);
    var peg$e25 = peg$otherExpectation("prefix");
    var peg$e26 = peg$otherExpectation("plus");
    var peg$e27 = peg$literalExpectation("+", false);
    var peg$e28 = peg$otherExpectation("minus");
    var peg$e29 = peg$literalExpectation("-", false);
    var peg$e30 = peg$otherExpectation("num");
    var peg$e31 = peg$classExpectation([["0", "9"]], false, false);
    var peg$e32 = peg$otherExpectation("positive float");
    var peg$e33 = peg$otherExpectation("divisor");
    var peg$e34 = peg$otherExpectation("int");
    var peg$e36 = peg$classExpectation([" ", "\t", `
`, "\r"], false, false);
    var peg$e37 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
    var peg$f0 = function(m) {
      return m;
    };
    var peg$f1 = function(m) {
      return m;
    };
    var peg$f2 = function(m) {
      return m;
    };
    var peg$f3 = function(m) {
      return m;
    };
    var peg$f4 = function(m) {
      return m;
    };
    var peg$f5 = function(a) {
      return { type: "invalid_spec", content: a };
    };
    var peg$f6 = function(f, c) {
      return c;
    };
    var peg$f7 = function(f, r) {
      return { type: "color_set", content: [f].concat(r) };
    };
    var peg$f8 = function(n, s2) {
      return { type: "color_set_item", name: n, spec_list: s2 };
    };
    var peg$f9 = function(c, m) {
      return { type: "model_list", contents: m, core_model: c };
    };
    var peg$f10 = function(m) {
      return { type: "model_list", contents: m, core_model: null };
    };
    var peg$f11 = function(m, a) {
      return a;
    };
    var peg$f12 = function(m, r) {
      return [m].concat(r);
    };
    var peg$f13 = function(s2, a) {
      return a;
    };
    var peg$f14 = function(s2, r) {
      return { type: "spec_list", content: [s2].concat(r) };
    };
    var peg$f15 = function(c) {
      return { type: "hex_spec", content: [c] };
    };
    var peg$f16 = function(c, d) {
      return d;
    };
    var peg$f17 = function(c, d) {
      return d;
    };
    var peg$f18 = function(c, r) {
      return { type: "num_spec", content: r ? [c].concat(r) : [c] };
    };
    var peg$f19 = function(c, fs) {
      return { type: "color", color: c, functions: fs };
    };
    var peg$f20 = function(f, n) {
      return n;
    };
    var peg$f21 = function(f, args) {
      return { type: "function", name: f, args };
    };
    var peg$f22 = function(core, d, e, es) {
      return {
        type: "extended_expr",
        core_model: core,
        div: d,
        expressions: [e].concat(es)
      };
    };
    var peg$f23 = function(core, e, es) {
      return {
        type: "extended_expr",
        core_model: core,
        div: null,
        expressions: [e].concat(es)
      };
    };
    var peg$f24 = function(e, d) {
      return { type: "weighted_expr", color: e, weight: d };
    };
    var peg$f25 = function(e) {
      return e;
    };
    var peg$f26 = function(p, n, e, po) {
      return {
        type: "expr",
        prefix: p,
        name: n,
        mix_expr: e,
        postfix: po
      };
    };
    var peg$f27 = function(p, n) {
      return { type: "complete_mix", mix_percent: p, name: n };
    };
    var peg$f28 = function(p) {
      return { type: "partial_mix", mix_percent: p };
    };
    var peg$f29 = function(c, p) {
      return c.concat(p || []);
    };
    var peg$f30 = function(n) {
      return { type: "postfix", num: n };
    };
    var peg$f31 = function(p) {
      return { type: "postfix", plusses: p };
    };
    var peg$f32 = function(n) {
      return parseInt(n, 10);
    };
    var peg$f33 = function(n) {
      return parseFloat(n);
    };
    var peg$f34 = function(n) {
      return n;
    };
    var peg$f35 = function(n) {
      return -n;
    };
    var peg$f36 = function(m, n) {
      return m ? -n : n;
    };
    var peg$f37 = function(h) {
      return h.toUpperCase();
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$literalExpectation(text22, ignoreCase) {
      return { type: "literal", text: text22, ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts, inverted, ignoreCase };
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$otherExpectation(description) {
      return { type: "other", description };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parsestart() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parsespec();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEOL();
        if (s2 !== peg$FAILED) {
          s0 = peg$f0(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsespec_list();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEOL();
          if (s2 !== peg$FAILED) {
            s0 = peg$f1(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecolor();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseEOL();
            if (s2 !== peg$FAILED) {
              s0 = peg$f2(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsemodel_list();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseEOL();
              if (s2 !== peg$FAILED) {
                s0 = peg$f3(s1);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsecolor_set_spec();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseEOL();
                if (s2 !== peg$FAILED) {
                  s0 = peg$f4(s1);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = [];
                if (input.length > peg$currPos) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  if (input.length > peg$currPos) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e0);
                    }
                  }
                }
                s1 = input.substring(s1, peg$currPos);
                s1 = peg$f5(s1);
                s0 = s1;
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parsecolor_set_spec() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$parsecolor_set_item();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 59) {
          s4 = peg$c0;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsecolor_set_item();
          if (s5 !== peg$FAILED) {
            s3 = peg$f6(s1, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s4 = peg$c0;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecolor_set_item();
            if (s5 !== peg$FAILED) {
              s3 = peg$f6(s1, s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        s0 = peg$f7(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecolor_set_item() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parsename();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsespec_list();
          if (s3 !== peg$FAILED) {
            s0 = peg$f8(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsemodel_list() {
      var s0, s1, s2, s3;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsecore_model();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c2;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemodel_list_tail();
          if (s3 !== peg$FAILED) {
            s0 = peg$f9(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsemodel_list_tail();
        if (s1 !== peg$FAILED) {
          s1 = peg$f10(s1);
        }
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      return s0;
    }
    function peg$parsemodel_list_tail() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$parsemodel();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
          s4 = peg$c3;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsemodel();
          if (s5 !== peg$FAILED) {
            s3 = peg$f11(s1, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s4 = peg$c3;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsemodel();
            if (s5 !== peg$FAILED) {
              s3 = peg$f11(s1, s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        s0 = peg$f12(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsemodel() {
      var s0;
      peg$silentFails++;
      s0 = peg$parsecore_model();
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e6);
        }
      }
      return s0;
    }
    function peg$parsespec_list() {
      var s0, s1, s2, s3, s4, s5;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsespec();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
          s4 = peg$c3;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsespec();
          if (s5 !== peg$FAILED) {
            s3 = peg$f13(s1, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s4 = peg$c3;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsespec();
            if (s5 !== peg$FAILED) {
              s3 = peg$f13(s1, s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        s0 = peg$f14(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e7);
        }
      }
      return s0;
    }
    function peg$parsespec() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$parsehex();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsehex();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsehex();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsehex();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsehex();
              if (s7 !== peg$FAILED) {
                s8 = peg$parsehex();
                if (s8 !== peg$FAILED) {
                  s3 = [s3, s4, s5, s6, s7, s8];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f15(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedec();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c1;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsedec();
            if (s5 !== peg$FAILED) {
              s3 = peg$f16(s1, s5);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c1;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsedec();
                if (s5 !== peg$FAILED) {
                  s3 = peg$f16(s1, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsesp();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsedec();
              if (s5 !== peg$FAILED) {
                s3 = peg$f17(s1, s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsesp();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsedec();
                  if (s5 !== peg$FAILED) {
                    s3 = peg$f17(s1, s5);
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            } else {
              s2 = peg$FAILED;
            }
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s0 = peg$f18(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e8);
        }
      }
      return s0;
    }
    function peg$parsecolor() {
      var s0, s1, s2, s3;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsecolor_expr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsefunc_expr();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsefunc_expr();
        }
        s0 = peg$f19(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e9);
        }
      }
      return s0;
    }
    function peg$parsecolor_expr() {
      var s0;
      s0 = peg$parseext_expr();
      if (s0 === peg$FAILED) {
        s0 = peg$parseexpr();
        if (s0 === peg$FAILED) {
          s0 = peg$parsename();
        }
      }
      return s0;
    }
    function peg$parsefunc_expr() {
      var s0, s1, s2, s3, s4, s5, s6;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 62) {
        s1 = peg$c4;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e11);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsefunction();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c1;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseint();
            if (s6 !== peg$FAILED) {
              s4 = peg$f20(s2, s6);
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c1;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseint();
              if (s6 !== peg$FAILED) {
                s4 = peg$f20(s2, s6);
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          s0 = peg$f21(s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e10);
        }
      }
      return s0;
    }
    function peg$parsefunction() {
      var s0;
      peg$silentFails++;
      s0 = peg$parsename();
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e12);
        }
      }
      return s0;
    }
    function peg$parseext_expr() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsecore_model();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsediv();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c2;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseweighted_expr();
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parseadditional_weighted_expr();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parseadditional_weighted_expr();
                }
                s0 = peg$f22(s1, s3, s5, s6);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsecore_model();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c2;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseweighted_expr();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseadditional_weighted_expr();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseadditional_weighted_expr();
              }
              s0 = peg$f23(s1, s3, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e13);
        }
      }
      return s0;
    }
    function peg$parseweighted_expr() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parseexpr();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c1;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedec();
          if (s3 !== peg$FAILED) {
            s0 = peg$f24(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseadditional_weighted_expr() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        s1 = peg$c0;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseweighted_expr();
        if (s2 !== peg$FAILED) {
          s0 = peg$f25(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecore_model() {
      var s0;
      peg$silentFails++;
      s0 = peg$parsename();
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e14);
        }
      }
      return s0;
    }
    function peg$parseexpr() {
      var s0, s1, s2, s3, s4;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseprefix();
      s2 = peg$parsename();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsemix_expr();
        s4 = peg$parsepostfix();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        s0 = peg$f26(s1, s2, s3, s4);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e15);
        }
      }
      return s0;
    }
    function peg$parsecomplete_mix() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 33) {
        s1 = peg$c5;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e16);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepct();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 33) {
            s3 = peg$c5;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e16);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsename();
            if (s4 !== peg$FAILED) {
              s0 = peg$f27(s2, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsepartial_mix() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 33) {
        s1 = peg$c5;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e16);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepct();
        if (s2 !== peg$FAILED) {
          s0 = peg$f28(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsemix_expr() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsecomplete_mix();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsecomplete_mix();
      }
      s2 = peg$parsepartial_mix();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s0 = peg$f29(s1, s2);
      peg$silentFails--;
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e17);
      }
      return s0;
    }
    function peg$parsename() {
      var s0, s1, s2;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 46) {
        s0 = peg$c6;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e19);
        }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e18);
        }
      }
      return s0;
    }
    function peg$parsepostfix() {
      var s0, s1, s2, s3, s4;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c7) {
        s1 = peg$c7;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e22);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenum();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c8;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
          if (s3 !== peg$FAILED) {
            s0 = peg$f30(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c9) {
          s1 = peg$c9;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];
          s4 = peg$parseplus();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseplus();
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos);
          } else {
            s2 = s3;
          }
          if (s2 !== peg$FAILED) {
            s0 = peg$f31(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e21);
        }
      }
      return s0;
    }
    function peg$parseprefix() {
      var s0;
      peg$silentFails++;
      s0 = peg$parseminus();
      if (s0 === peg$FAILED) {
        s0 = null;
      }
      peg$silentFails--;
      if (peg$silentFails === 0) {
        peg$fail(peg$e25);
      }
      return s0;
    }
    function peg$parseplus() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (input.charCodeAt(peg$currPos) === 43) {
        s2 = peg$c10;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e27);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (input.charCodeAt(peg$currPos) === 43) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e26);
        }
      }
      return s0;
    }
    function peg$parseminus() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c11;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e29);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (input.charCodeAt(peg$currPos) === 45) {
            s2 = peg$c11;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e28);
        }
      }
      return s0;
    }
    function peg$parsenum() {
      var s0, s1, s2, s3;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      if (peg$r1.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e31);
        }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f32(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e30);
        }
      }
      return s0;
    }
    function peg$parsepct() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$currPos;
      s4 = [];
      if (peg$r1.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e31);
        }
      }
      if (s5 !== peg$FAILED) {
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
        }
      } else {
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        s3 = input.substring(s3, peg$currPos);
      } else {
        s3 = s4;
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$currPos;
        s5 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s6 = peg$c6;
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        if (s6 !== peg$FAILED) {
          s7 = peg$currPos;
          s8 = [];
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s9 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s9 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          while (s9 !== peg$FAILED) {
            s8.push(s9);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s9 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s9 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e31);
              }
            }
          }
          s7 = input.substring(s7, peg$currPos);
          s6 = [s6, s7];
          s5 = s6;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        s4 = input.substring(s4, peg$currPos);
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c6;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e19);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          s5 = [];
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s6 !== peg$FAILED) {
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e31);
                }
              }
            }
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s4 = input.substring(s4, peg$currPos);
          } else {
            s4 = s5;
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s2;
        }
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f33(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e32);
        }
      }
      return s0;
    }
    function peg$parsediv() {
      var s0;
      peg$silentFails++;
      s0 = peg$parsepct();
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e33);
        }
      }
      return s0;
    }
    function peg$parsedec() {
      var s0, s1, s2;
      s0 = peg$parsepct();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c10;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e27);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsepct();
          if (s2 !== peg$FAILED) {
            s0 = peg$f34(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c11;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsepct();
            if (s2 !== peg$FAILED) {
              s0 = peg$f35(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
      return s0;
    }
    function peg$parseint() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseminus();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      s2 = peg$parsenum();
      if (s2 !== peg$FAILED) {
        s0 = peg$f36(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e34);
        }
      }
      return s0;
    }
    function peg$parsesp() {
      var s0, s1;
      s0 = [];
      if (peg$r2.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e36);
        }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
        }
      } else {
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsehex() {
      var s0, s1;
      s0 = peg$currPos;
      if (peg$r3.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e37);
        }
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f37(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parseEOL() {
      var s0, s1;
      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = undefined;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _TabularPegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { body: peg$parsebody };
    var peg$startRuleFunction = peg$parsebody;
    var peg$e0 = peg$otherExpectation("decl_start");
    var peg$e1 = peg$otherExpectation("decl_end");
    var peg$e2 = peg$otherExpectation("vert");
    var peg$e3 = peg$anyExpectation();
    var peg$e4 = peg$otherExpectation("l");
    var peg$e5 = peg$otherExpectation("r");
    var peg$e6 = peg$otherExpectation("c");
    var peg$e7 = peg$otherExpectation("p");
    var peg$e8 = peg$otherExpectation("m");
    var peg$e9 = peg$otherExpectation("b");
    var peg$e10 = peg$otherExpectation("w");
    var peg$e11 = peg$otherExpectation("W");
    var peg$e12 = peg$otherExpectation("X");
    var peg$e13 = peg$otherExpectation("!");
    var peg$e14 = peg$otherExpectation("@");
    var peg$e15 = peg$otherExpectation("<");
    var peg$e16 = peg$otherExpectation(">");
    var peg$e17 = peg$otherExpectation("group");
    var peg$e18 = peg$otherExpectation("whitespace");
    var peg$f0 = function(c) {
      return c;
    };
    var peg$f1 = function(cols) {
      return cols;
    };
    var peg$f2 = function() {
      return [];
    };
    var peg$f3 = function(divs1, start, a, end, divs2) {
      return {
        type: "column",
        pre_dividers: divs1,
        post_dividers: divs2,
        before_start_code: start,
        before_end_code: end,
        alignment: a
      };
    };
    var peg$f4 = function() {
      return {
        type: "vert_divider"
      };
    };
    var peg$f5 = function(b, g) {
      return {
        type: "bang_divider",
        content: g[0].content
      };
    };
    var peg$f6 = function(g) {
      return {
        type: "at_divider",
        content: g[0].content
      };
    };
    var peg$f7 = function(div) {
      return div;
    };
    var peg$f8 = function(g) {
      return { type: "decl_code", code: g[0].content };
    };
    var peg$f9 = function(g) {
      return { type: "decl_code", code: g[0].content };
    };
    var peg$f10 = function() {
      return { type: "alignment", alignment: "left" };
    };
    var peg$f11 = function() {
      return { type: "alignment", alignment: "center" };
    };
    var peg$f12 = function() {
      return { type: "alignment", alignment: "right" };
    };
    var peg$f13 = function() {
      return { type: "alignment", alignment: "X" };
    };
    var peg$f14 = function() {
      return "top";
    };
    var peg$f15 = function() {
      return "default";
    };
    var peg$f16 = function() {
      return "bottom";
    };
    var peg$f17 = function(a, g) {
      return {
        type: "alignment",
        alignment: "parbox",
        baseline: a,
        size: g[0].content
      };
    };
    var peg$f18 = function(g1, g2) {
      return {
        type: "alignment",
        alignment: "parbox",
        baseline: g1[0].content,
        size: g2[0].content
      };
    };
    var peg$f19 = function(tok) {
      return options2.matchChar(tok, "|");
    };
    var peg$f20 = function(tok) {
      return options2.matchChar(tok, "l");
    };
    var peg$f21 = function(tok) {
      return options2.matchChar(tok, "r");
    };
    var peg$f22 = function(tok) {
      return options2.matchChar(tok, "c");
    };
    var peg$f23 = function(tok) {
      return options2.matchChar(tok, "p");
    };
    var peg$f24 = function(tok) {
      return options2.matchChar(tok, "m");
    };
    var peg$f25 = function(tok) {
      return options2.matchChar(tok, "b");
    };
    var peg$f26 = function(tok) {
      return options2.matchChar(tok, "w");
    };
    var peg$f27 = function(tok) {
      return options2.matchChar(tok, "W");
    };
    var peg$f28 = function(tok) {
      return options2.matchChar(tok, "X");
    };
    var peg$f29 = function(tok) {
      return options2.matchChar(tok, "!");
    };
    var peg$f30 = function(tok) {
      return options2.matchChar(tok, "@");
    };
    var peg$f31 = function(tok) {
      return options2.matchChar(tok, "<");
    };
    var peg$f32 = function(tok) {
      return options2.matchChar(tok, ">");
    };
    var peg$f33 = function(tok) {
      return options2.isGroup(tok);
    };
    var peg$f34 = function(tok) {
      return options2.isWhitespace(tok);
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$otherExpectation(description) {
      return { type: "other", description };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parsebody() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsecolumn();
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parse_();
        }
        s2 = peg$f0(s3);
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parsecolumn();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            s2 = peg$f0(s3);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f1(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseEOL();
        if (s1 !== peg$FAILED) {
          s1 = peg$f2();
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parsecolumn() {
      var s0, s1, s2, s3, s4, s5, s6;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsecolumn_divider();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsecolumn_divider();
      }
      s2 = peg$parsedecl_start();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = peg$parsealignment();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsedecl_end();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        s5 = [];
        s6 = peg$parsecolumn_divider();
        while (s6 !== peg$FAILED) {
          s5.push(s6);
          s6 = peg$parsecolumn_divider();
        }
        s0 = peg$f3(s1, s2, s3, s4, s5);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecolumn_divider() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      s2 = peg$currPos;
      s3 = peg$parsevert();
      if (s3 !== peg$FAILED) {
        s3 = peg$f4();
      }
      s2 = s3;
      if (s2 === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parsebang();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsegroup();
          if (s4 !== peg$FAILED) {
            s2 = peg$f5(s3, s4);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseat();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsegroup();
            if (s4 !== peg$FAILED) {
              s2 = peg$f6(s4);
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parse_();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parse_();
        }
        s0 = peg$f7(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsedecl_start() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsegreater();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsegroup();
        if (s2 !== peg$FAILED) {
          s0 = peg$f8(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      return s0;
    }
    function peg$parsedecl_end() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseless();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsegroup();
        if (s2 !== peg$FAILED) {
          s0 = peg$f9(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
      }
      return s0;
    }
    function peg$parsealignment() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$parsel();
      if (s1 !== peg$FAILED) {
        s1 = peg$f10();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsec();
        if (s1 !== peg$FAILED) {
          s1 = peg$f11();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parser();
          if (s1 !== peg$FAILED) {
            s1 = peg$f12();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseX();
            if (s1 !== peg$FAILED) {
              s1 = peg$f13();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$parsep();
              if (s2 !== peg$FAILED) {
                s2 = peg$f14();
              }
              s1 = s2;
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                s2 = peg$parsem();
                if (s2 !== peg$FAILED) {
                  s2 = peg$f15();
                }
                s1 = s2;
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s2 = peg$parseb();
                  if (s2 !== peg$FAILED) {
                    s2 = peg$f16();
                  }
                  s1 = s2;
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parse_();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parse_();
                }
                s3 = peg$parsegroup();
                if (s3 !== peg$FAILED) {
                  s0 = peg$f17(s1, s3);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsew();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseW();
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$parse_();
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parse_();
                  }
                  s3 = peg$parsegroup();
                  if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$parse_();
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$parse_();
                    }
                    s5 = peg$parsegroup();
                    if (s5 !== peg$FAILED) {
                      s0 = peg$f18(s3, s5);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parsevert() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f19(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      return s0;
    }
    function peg$parsel() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f20(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
      }
      return s0;
    }
    function peg$parser() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f21(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e5);
        }
      }
      return s0;
    }
    function peg$parsec() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f22(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e6);
        }
      }
      return s0;
    }
    function peg$parsep() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f23(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e7);
        }
      }
      return s0;
    }
    function peg$parsem() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f24(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e8);
        }
      }
      return s0;
    }
    function peg$parseb() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f25(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e9);
        }
      }
      return s0;
    }
    function peg$parsew() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f26(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e10);
        }
      }
      return s0;
    }
    function peg$parseW() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f27(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e11);
        }
      }
      return s0;
    }
    function peg$parseX() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f28(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e12);
        }
      }
      return s0;
    }
    function peg$parsebang() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f29(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e13);
        }
      }
      return s0;
    }
    function peg$parseat() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f30(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e14);
        }
      }
      return s0;
    }
    function peg$parseless() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f31(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e15);
        }
      }
      return s0;
    }
    function peg$parsegreater() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f32(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e16);
        }
      }
      return s0;
    }
    function peg$parsegroup() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f33(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e17);
        }
      }
      return s0;
    }
    function peg$parse_() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f34(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e18);
        }
      }
      return s0;
    }
    function peg$parseEOL() {
      var s0, s1;
      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = undefined;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    if (!options2.isHash) {
      try {
        Object.assign(options2, {
          matchChar: (node2, char) => node2.type === "string" && node2.content === char,
          isGroup: (node2) => node2.type === "group",
          isWhitespace: (node2) => node2.type === "whitespace"
        });
      } catch (e) {
        console.warn("Error when initializing parser", e);
      }
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _SystemePegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { body: peg$parsebody };
    var peg$startRuleFunction = peg$parsebody;
    var peg$e1 = peg$otherExpectation("item");
    var peg$e2 = peg$anyExpectation();
    var peg$e3 = peg$otherExpectation("equation");
    var peg$e4 = peg$otherExpectation("trailing comment");
    var peg$e5 = peg$otherExpectation("comment only line");
    var peg$e6 = peg$otherExpectation("non-var token");
    var peg$e7 = peg$otherExpectation("token");
    var peg$e8 = peg$otherExpectation("same line comment");
    var peg$e9 = peg$otherExpectation("own line comment");
    var peg$e10 = peg$otherExpectation(",");
    var peg$e11 = peg$otherExpectation("@");
    var peg$e12 = peg$otherExpectation("variable token");
    var peg$e13 = peg$otherExpectation("+/-");
    var peg$e14 = peg$otherExpectation("=");
    var peg$f0 = function(a, b) {
      return a.concat(b ? b : []);
    };
    var peg$f1 = function() {
      return [];
    };
    var peg$f3 = function(op, a, b, c) {
      return { type: "item", op, variable: b, content: a.concat(b, c) };
    };
    var peg$f4 = function(op, a) {
      return { type: "item", op, variable: null, content: a };
    };
    var peg$f5 = function(line, sep, comment) {
      return { ...line, sep: [].concat(sep), trailingComment: comment };
    };
    var peg$f6 = function(line, comment) {
      return { ...line, trailingComment: comment };
    };
    var peg$f7 = function(eq, ann) {
      return {
        type: "line",
        equation: eq,
        annotation: ann,
        sep: null
      };
    };
    var peg$f8 = function(at, ann) {
      return at ? { type: "annotation", marker: at, content: ann } : null;
    };
    var peg$f9 = function(left, eq, right) {
      return { type: "equation", left, right, equals: eq };
    };
    var peg$f10 = function(x) {
      return x;
    };
    var peg$f11 = function(x) {
      return {
        type: "line",
        trailingComment: x
      };
    };
    var peg$f12 = function(v, s2) {
      return [v].concat(s2 ? s2 : []);
    };
    var peg$f13 = function(t) {
      return t;
    };
    var peg$f14 = function(x) {
      return x;
    };
    var peg$f15 = function(x) {
      return x;
    };
    var peg$f16 = function(tok) {
      return options2.isSameLineComment(tok);
    };
    var peg$f17 = function(tok) {
      return tok;
    };
    var peg$f18 = function(tok) {
      return options2.isOwnLineComment(tok);
    };
    var peg$f19 = function(tok) {
      return tok;
    };
    var peg$f20 = function(tok) {
      return options2.isWhitespace(tok);
    };
    var peg$f21 = function(tok) {
      return tok;
    };
    var peg$f22 = function(tok) {
      return options2.isSep(tok);
    };
    var peg$f23 = function(tok) {
      return tok;
    };
    var peg$f24 = function(tok) {
      return options2.isAt(tok);
    };
    var peg$f25 = function(tok) {
      return tok;
    };
    var peg$f26 = function(tok) {
      return options2.isVar(tok);
    };
    var peg$f27 = function(tok) {
      return tok;
    };
    var peg$f28 = function(tok) {
      return options2.isOperation(tok);
    };
    var peg$f29 = function(tok) {
      return tok;
    };
    var peg$f30 = function(tok) {
      return options2.isEquals(tok);
    };
    var peg$f31 = function(tok) {
      return tok;
    };
    var peg$f32 = function(tok) {
      return options2.isSubscript(tok);
    };
    var peg$f33 = function(tok) {
      return tok;
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$otherExpectation(description) {
      return { type: "other", description };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parsebody() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsecomment_only_line();
      if (s2 === peg$FAILED) {
        s2 = peg$parseline_with_sep();
        if (s2 === peg$FAILED) {
          s2 = peg$parsepartial_line_with_comment();
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsecomment_only_line();
        if (s2 === peg$FAILED) {
          s2 = peg$parseline_with_sep();
          if (s2 === peg$FAILED) {
            s2 = peg$parsepartial_line_with_comment();
          }
        }
      }
      s2 = peg$parseline_without_sep();
      if (s2 === peg$FAILED) {
        s2 = peg$parseEOL();
      }
      if (s2 !== peg$FAILED) {
        s0 = peg$f0(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseEOL();
        if (s1 !== peg$FAILED) {
          s1 = peg$f1();
        }
        s0 = s1;
      }
      return s0;
    }
    function peg$parseitem() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseoperation();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      s2 = [];
      s3 = peg$parse_();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parse_();
      }
      s3 = [];
      s4 = peg$parsenon_var_token();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parsenon_var_token();
      }
      s4 = [];
      s5 = peg$parse_();
      while (s5 !== peg$FAILED) {
        s4.push(s5);
        s5 = peg$parse_();
      }
      s5 = peg$parsevar();
      if (s5 !== peg$FAILED) {
        s6 = [];
        s7 = peg$parse_();
        while (s7 !== peg$FAILED) {
          s6.push(s7);
          s7 = peg$parse_();
        }
        s7 = [];
        s8 = peg$parsetoken();
        while (s8 !== peg$FAILED) {
          s7.push(s8);
          s8 = peg$parsetoken();
        }
        s8 = [];
        s9 = peg$parse_();
        while (s9 !== peg$FAILED) {
          s8.push(s9);
          s9 = peg$parse_();
        }
        s0 = peg$f3(s1, s3, s5, s7);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseoperation();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        s3 = [];
        s4 = peg$parsenon_var_token();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsenon_var_token();
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          s0 = peg$f4(s1, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
      }
      return s0;
    }
    function peg$parseline_with_sep() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parseline_without_sep();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesep();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsetrailing_comment();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s0 = peg$f5(s1, s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsepartial_line_with_comment() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parseline_without_sep();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsetrailing_comment();
        if (s2 !== peg$FAILED) {
          s0 = peg$f6(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseline_without_sep() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      peg$silentFails--;
      if (s2 !== peg$FAILED) {
        peg$currPos = s1;
        s1 = undefined;
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseequation();
        s3 = peg$parseannotation();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s0 = peg$f7(s2, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseannotation() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parseat();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsenon_sep_token();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsenon_sep_token();
        }
        s0 = peg$f8(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseequation() {
      var s0, s1, s2, s3, s4;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseitem();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseitem();
      }
      s2 = peg$parseequals();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = [];
      s4 = peg$parsetoken();
      if (s4 === peg$FAILED) {
        s4 = peg$parseoperation();
      }
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parsetoken();
        if (s4 === peg$FAILED) {
          s4 = peg$parseoperation();
        }
      }
      s0 = peg$f9(s1, s2, s3);
      peg$silentFails--;
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e3);
      }
      return s0;
    }
    function peg$parsetrailing_comment() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      s2 = peg$parsesame_line_comment();
      if (s2 !== peg$FAILED) {
        s0 = peg$f10(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
      }
      return s0;
    }
    function peg$parsecomment_only_line() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      s2 = peg$parseown_line_comment();
      if (s2 !== peg$FAILED) {
        s0 = peg$f11(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e5);
        }
      }
      return s0;
    }
    function peg$parsevar() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$parsevar_token();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        s3 = peg$parsesubscript();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s0 = peg$f12(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsenon_var_token() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parsevar();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = undefined;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsetoken();
        if (s2 !== peg$FAILED) {
          s0 = peg$f13(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e6);
        }
      }
      return s0;
    }
    function peg$parsenon_sep_token() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parsesep();
      if (s2 === peg$FAILED) {
        s2 = peg$parsetrailing_comment();
        if (s2 === peg$FAILED) {
          s2 = peg$parseown_line_comment();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = undefined;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f14(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsetoken() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parsesep();
      if (s2 === peg$FAILED) {
        s2 = peg$parseat();
        if (s2 === peg$FAILED) {
          s2 = peg$parseoperation();
          if (s2 === peg$FAILED) {
            s2 = peg$parseequals();
            if (s2 === peg$FAILED) {
              s2 = peg$parsetrailing_comment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseown_line_comment();
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = undefined;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f15(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e7);
        }
      }
      return s0;
    }
    function peg$parsesame_line_comment() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f16(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f17(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e8);
        }
      }
      return s0;
    }
    function peg$parseown_line_comment() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f18(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f19(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e9);
        }
      }
      return s0;
    }
    function peg$parse_() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f20(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f21(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsesep() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f22(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f23(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e10);
        }
      }
      return s0;
    }
    function peg$parseat() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f24(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f25(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e11);
        }
      }
      return s0;
    }
    function peg$parsevar_token() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f26(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f27(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e12);
        }
      }
      return s0;
    }
    function peg$parseoperation() {
      var s0, s1, s2, s3, s4;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parse_();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parse_();
        }
        s4 = peg$f28(s2);
        if (s4) {
          s4 = undefined;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s0 = peg$f29(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e13);
        }
      }
      return s0;
    }
    function peg$parseequals() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f30(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f31(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e14);
        }
      }
      return s0;
    }
    function peg$parsesubscript() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f32(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f33(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseEOL() {
      var s0, s1;
      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = undefined;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    if (!options2.isWhitespace) {
      try {
        Object.assign(options2, {
          isSep: (node2) => node2.type === "string" && node2.content === ",",
          isVar: (node2) => node2.type === "string" && node2.content.match(/[a-zA-Z]/),
          isOperation: (node2) => node2.type === "string" && node2.content.match(/[+-]/),
          isEquals: (node2) => node2.type === "string" && node2.content === "=",
          isAt: (node2) => node2.type === "string" && node2.content === "@",
          isSubscript: (node2) => node2.content === "_",
          isWhitespace: (node2) => node2.type === "whitespace",
          isSameLineComment: (node2) => node2.type === "comment" && node2.sameline,
          isOwnLineComment: (node2) => node2.type === "comment" && !node2.sameline
        });
      } catch (e) {
        console.warn("Error when initializing parser", e);
      }
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _GluePegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { root: peg$parseroot };
    var peg$startRuleFunction = peg$parseroot;
    var peg$c0 = "plus";
    var peg$c1 = "minus";
    var peg$c2 = "pt";
    var peg$c3 = "mm";
    var peg$c4 = "cm";
    var peg$c5 = "in";
    var peg$c6 = "ex";
    var peg$c7 = "em";
    var peg$c8 = "bp";
    var peg$c9 = "pc";
    var peg$c10 = "dd";
    var peg$c11 = "cc";
    var peg$c12 = "nd";
    var peg$c13 = "nc";
    var peg$c14 = "sp";
    var peg$c15 = "filll";
    var peg$c16 = "fill";
    var peg$c17 = "fil";
    var peg$c18 = ".";
    var peg$c19 = "+";
    var peg$c20 = "-";
    var peg$r0 = /^[0-9]/;
    var peg$e0 = peg$anyExpectation();
    var peg$e1 = peg$literalExpectation("plus", false);
    var peg$e2 = peg$literalExpectation("minus", false);
    var peg$e3 = peg$literalExpectation("pt", false);
    var peg$e4 = peg$literalExpectation("mm", false);
    var peg$e5 = peg$literalExpectation("cm", false);
    var peg$e6 = peg$literalExpectation("in", false);
    var peg$e7 = peg$literalExpectation("ex", false);
    var peg$e8 = peg$literalExpectation("em", false);
    var peg$e9 = peg$literalExpectation("bp", false);
    var peg$e10 = peg$literalExpectation("pc", false);
    var peg$e11 = peg$literalExpectation("dd", false);
    var peg$e12 = peg$literalExpectation("cc", false);
    var peg$e13 = peg$literalExpectation("nd", false);
    var peg$e14 = peg$literalExpectation("nc", false);
    var peg$e15 = peg$literalExpectation("sp", false);
    var peg$e16 = peg$literalExpectation("filll", false);
    var peg$e17 = peg$literalExpectation("fill", false);
    var peg$e18 = peg$literalExpectation("fil", false);
    var peg$e19 = peg$otherExpectation("number");
    var peg$e20 = peg$classExpectation([["0", "9"]], false, false);
    var peg$e21 = peg$literalExpectation(".", false);
    var peg$e22 = peg$literalExpectation("+", false);
    var peg$e23 = peg$literalExpectation("-", false);
    var peg$f0 = function(b, st, sh) {
      return {
        type: "glue",
        fixed: b,
        stretchable: st,
        shrinkable: sh,
        position: location()
      };
    };
    var peg$f1 = function(glue) {
      return glue;
    };
    var peg$f2 = function(n, u) {
      return { type: "dim", value: n, unit: u };
    };
    var peg$f3 = function(n, u) {
      return { type: "dim", value: n, unit: u };
    };
    var peg$f4 = function(n, u) {
      return { type: "dim", value: n, unit: u };
    };
    var peg$f5 = function(n) {
      return parseFloat(n);
    };
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function peg$literalExpectation(text22, ignoreCase) {
      return { type: "literal", text: text22, ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts, inverted, ignoreCase };
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$otherExpectation(description) {
      return { type: "other", description };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parseroot() {
      var s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parsebase();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsestretchable();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s4 = peg$parseshrinkable();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        peg$savedPos = s1;
        s1 = peg$f0(s2, s3, s4);
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (input.length > peg$currPos) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (input.length > peg$currPos) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
        }
        peg$savedPos = s0;
        s0 = peg$f1(s1);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsebase() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsenumber();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseunit();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f2(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsestretchable() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c0) {
        s1 = peg$c0;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          s3 = peg$parserubber_unit();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f3(s2, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseshrinkable() {
      var s0, s1, s2, s3;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c1) {
        s1 = peg$c1;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          s3 = peg$parserubber_unit();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s2, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseunit() {
      var s0;
      if (input.substr(peg$currPos, 2) === peg$c2) {
        s0 = peg$c2;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c3) {
          s0 = peg$c3;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c4) {
            s0 = peg$c4;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c5) {
              s0 = peg$c5;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e6);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c6) {
                s0 = peg$c6;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e7);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c7) {
                  s0 = peg$c7;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e8);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c8) {
                    s0 = peg$c8;
                    peg$currPos += 2;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e9);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c9) {
                      s0 = peg$c9;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e10);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c10) {
                        s0 = peg$c10;
                        peg$currPos += 2;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e11);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c11) {
                          s0 = peg$c11;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e12);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c12) {
                            s0 = peg$c12;
                            peg$currPos += 2;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e13);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c13) {
                              s0 = peg$c13;
                              peg$currPos += 2;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e14);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c14) {
                                s0 = peg$c14;
                                peg$currPos += 2;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e15);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parserubber_unit() {
      var s0;
      s0 = peg$parseunit();
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 5) === peg$c15) {
          s0 = peg$c15;
          peg$currPos += 5;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c16) {
            s0 = peg$c16;
            peg$currPos += 4;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e17);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c17) {
              s0 = peg$c17;
              peg$currPos += 3;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e18);
              }
            }
          }
        }
      }
      return s0;
    }
    function peg$parsenumber() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$parsesign();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$currPos;
      s5 = [];
      if (peg$r0.test(input.charAt(peg$currPos))) {
        s6 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s6 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e20);
        }
      }
      while (s6 !== peg$FAILED) {
        s5.push(s6);
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
      }
      if (input.charCodeAt(peg$currPos) === 46) {
        s6 = peg$c18;
        peg$currPos++;
      } else {
        s6 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e21);
        }
      }
      if (s6 !== peg$FAILED) {
        s7 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s8 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s8 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s8 !== peg$FAILED) {
          while (s8 !== peg$FAILED) {
            s7.push(s8);
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s8 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
          }
        } else {
          s7 = peg$FAILED;
        }
        if (s7 !== peg$FAILED) {
          s5 = [s5, s6, s7];
          s4 = s5;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 === peg$FAILED) {
        s4 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$r0.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
          }
        } else {
          s4 = peg$FAILED;
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$f5(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e19);
        }
      }
      return s0;
    }
    function peg$parsesign() {
      var s0;
      if (input.charCodeAt(peg$currPos) === 43) {
        s0 = peg$c19;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e22);
        }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s0 = peg$c20;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e23);
          }
        }
      }
      return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var _TikzPegParser = function() {
  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C;
  }
  function peg$SyntaxError(message, expected, found, location) {
    var self2 = Error.call(this, message);
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
    }
    self2.expected = expected;
    self2.found = found;
    self2.location = location;
    self2.name = "SyntaxError";
    return self2;
  }
  peg$subclass(peg$SyntaxError, Error);
  function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }
  peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0;k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s2 = this.location.start;
      var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s2) : s2;
      var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd("", offset_s.line.toString().length, " ");
        var line = src[s2.line - 1];
        var last = s2.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s2.column || 1;
        str += `
 --> ` + loc + `
` + filler + ` |
` + offset_s.line + " | " + line + `
` + filler + " | " + peg$padEnd("", s2.column - 1, " ") + peg$padEnd("", hatLen, "^");
      } else {
        str += `
 at ` + loc;
      }
    }
    return str;
  };
  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        var escapedParts = expectation.parts.map(function(part) {
          return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
        });
        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
      },
      any: function() {
        return "any character";
      },
      end: function() {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      var descriptions = expected2.map(describeExpectation);
      var i, j;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1;i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options2) {
    options2 = options2 !== undefined ? options2 : {};
    var peg$FAILED = {};
    var peg$source = options2.grammarSource;
    var peg$startRuleFunctions = { path_spec: peg$parsepath_spec, foreach_body: peg$parseforeach_body };
    var peg$startRuleFunction = peg$parsepath_spec;
    var peg$e0 = peg$anyExpectation();
    var peg$e3 = peg$otherExpectation("comment");
    var peg$e4 = peg$otherExpectation("floating comment");
    var peg$e5 = peg$otherExpectation("operation");
    var peg$e6 = peg$otherExpectation("=");
    var peg$f0 = function(v) {
      return v;
    };
    var peg$f1 = function(ops) {
      return { type: "path_spec", content: ops };
    };
    var peg$f2 = function(c1, op, comment) {
      return { op, comment };
    };
    var peg$f3 = function(c1, ops, c2, body) {
      const comments = [c1, ...ops.map((x) => x.comment), c2].filter((x) => x);
      const attribute2 = ops.map((x) => x.op.content.content).join(" ");
      return {
        type: "animation",
        comments,
        attribute: attribute2,
        content: body.content
      };
    };
    var peg$f4 = function(start, b) {
      return { ...b, start, type: "foreach" };
    };
    var peg$f5 = function(c1, variables, options22, c2, c3, list3, c4, command) {
      const comments = [c1, c2, c3, c4].filter((x) => x);
      return {
        type: "foreach_body",
        variables,
        options: options22 && options22.content,
        list: list3,
        command,
        comments
      };
    };
    var peg$f6 = function(c1, options22, c2, body) {
      const comments = [c1, c2].filter((x) => x);
      return {
        type: "svg_operation",
        options: options22 && options22.content,
        content: body,
        comments
      };
    };
    var peg$f7 = function(c1, c2, coord, c3, c4, x) {
      return { coord: x, comment: c4 };
    };
    var peg$f8 = function(c1, c2, coord, c3, a, c5) {
      const comments = [c1, c2, c3, a && a.comment, c5].filter((x) => x);
      return {
        type: "curve_to",
        controls: a ? [coord, a.coord] : [coord],
        comments
      };
    };
    var peg$f9 = function() {
      return { type: "line_to", command: "|-" };
    };
    var peg$f10 = function() {
      return { type: "line_to", command: "-|" };
    };
    var peg$f11 = function() {
      return { type: "line_to", command: "--" };
    };
    var peg$f12 = function(prefix, content3) {
      return { type: "coordinate", content: content3, prefix };
    };
    var peg$f13 = function(content3) {
      return { type: "square_brace_group", content: content3 };
    };
    var peg$f14 = function(v) {
      return { type: "unknown", content: v };
    };
    var peg$f19 = function(tok) {
      return options2.isComment(tok);
    };
    var peg$f20 = function(tok) {
      return tok;
    };
    var peg$f21 = function(tok) {
      return options2.isWhitespace(tok);
    };
    var peg$f22 = function(tok) {
      return tok;
    };
    var peg$f23 = function(c) {
      return c;
    };
    var peg$f24 = function(tok) {
      return options2.isOperation(tok);
    };
    var peg$f25 = function(tok) {
      return { type: "operation", content: tok };
    };
    var peg$f26 = function(tok) {
      return options2.isChar(tok, "=");
    };
    var peg$f27 = function(tok) {
      return tok;
    };
    var peg$f28 = function(tok) {
      return options2.isChar(tok, "[");
    };
    var peg$f29 = function(tok) {
      return tok;
    };
    var peg$f30 = function(tok) {
      return options2.isChar(tok, "]");
    };
    var peg$f31 = function(tok) {
      return tok;
    };
    var peg$f32 = function(tok) {
      return options2.isChar(tok, "(");
    };
    var peg$f33 = function(tok) {
      return tok;
    };
    var peg$f34 = function(tok) {
      return options2.isChar(tok, ")");
    };
    var peg$f35 = function(tok) {
      return tok;
    };
    var peg$f36 = function(tok) {
      return options2.isChar(tok, "+");
    };
    var peg$f37 = function(tok) {
      return tok;
    };
    var peg$f38 = function(tok) {
      return options2.isChar(tok, "-");
    };
    var peg$f39 = function(tok) {
      return tok;
    };
    var peg$f40 = function(tok) {
      return options2.isChar(tok, "|");
    };
    var peg$f41 = function(tok) {
      return tok;
    };
    var peg$f42 = function(tok) {
      return options2.isChar(tok, ".");
    };
    var peg$f43 = function(tok) {
      return tok;
    };
    var peg$f44 = function(tok) {
      return options2.isChar(tok, "controls");
    };
    var peg$f45 = function(tok) {
      return tok;
    };
    var peg$f46 = function(tok) {
      return options2.isChar(tok, "and");
    };
    var peg$f47 = function(tok) {
      return tok;
    };
    var peg$f48 = function(tok) {
      return options2.isChar(tok, "svg");
    };
    var peg$f49 = function(tok) {
      return tok;
    };
    var peg$f50 = function(tok) {
      return options2.isGroup(tok);
    };
    var peg$f51 = function(tok) {
      return tok;
    };
    var peg$f52 = function(tok) {
      return options2.isAnyMacro(tok);
    };
    var peg$f53 = function(tok) {
      return tok;
    };
    var peg$f54 = function(tok) {
      return options2.isChar(tok, "foreach");
    };
    var peg$f55 = function(tok) {
      return tok;
    };
    var peg$f56 = function(tok) {
      return options2.isMacro(tok, "foreach");
    };
    var peg$f57 = function(tok) {
      return tok;
    };
    var peg$f58 = function(tok) {
      return options2.isChar(tok, "in");
    };
    var peg$f59 = function(tok) {
      return tok;
    };
    var peg$f60 = function(tok) {
      return options2.isChar(tok, ":");
    };
    var peg$f61 = function(tok) {
      return tok;
    };
    var peg$currPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options2) {
      if (!(options2.startRule in peg$startRuleFunctions)) {
        throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
      }
      peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
    }
    function peg$anyExpectation() {
      return { type: "any" };
    }
    function peg$endExpectation() {
      return { type: "end" };
    }
    function peg$otherExpectation(description) {
      return { type: "other", description };
    }
    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos, offset2) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);
      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
      return res;
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
    }
    function peg$parsepath_spec() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsesquare_brace_group();
      if (s3 === peg$FAILED) {
        s3 = peg$parsecoordinate();
        if (s3 === peg$FAILED) {
          s3 = peg$parsecurve_to();
          if (s3 === peg$FAILED) {
            s3 = peg$parseline_to();
            if (s3 === peg$FAILED) {
              s3 = peg$parsesvg();
              if (s3 === peg$FAILED) {
                s3 = peg$parseforeach();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseoperation();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parsecomment();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseanimation();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parseunknown();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$parse_();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parse_();
        }
        s2 = peg$f0(s3);
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parsesquare_brace_group();
          if (s3 === peg$FAILED) {
            s3 = peg$parsecoordinate();
            if (s3 === peg$FAILED) {
              s3 = peg$parsecurve_to();
              if (s3 === peg$FAILED) {
                s3 = peg$parseline_to();
                if (s3 === peg$FAILED) {
                  s3 = peg$parsesvg();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseforeach();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseoperation();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parsecomment();
                        if (s3 === peg$FAILED) {
                          s3 = peg$parseanimation();
                          if (s3 === peg$FAILED) {
                            s3 = peg$parseunknown();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            s2 = peg$f0(s3);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f1(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parseanimation() {
      var s0, s1, s2, s3, s4, s5, s6;
      s0 = peg$currPos;
      s1 = peg$parsecolon();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_comment_();
        s3 = [];
        s4 = peg$currPos;
        s5 = peg$parseoperation();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse_comment_();
          s4 = peg$f2(s2, s5, s6);
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parseoperation();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_comment_();
              s4 = peg$f2(s2, s5, s6);
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseequals();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_comment_();
            s6 = peg$parsegroup();
            if (s6 !== peg$FAILED) {
              s0 = peg$f3(s2, s3, s5, s6);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseforeach() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parseforeach_keyword();
      if (s1 === peg$FAILED) {
        s1 = peg$parseforeach_macro();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseforeach_body();
        if (s2 !== peg$FAILED) {
          s0 = peg$f4(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseforeach_body() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      s0 = peg$currPos;
      s1 = peg$parse_comment_();
      s2 = peg$currPos;
      s3 = [];
      s4 = peg$currPos;
      s5 = peg$currPos;
      peg$silentFails++;
      s6 = peg$parsein_keyword();
      if (s6 === peg$FAILED) {
        s6 = peg$parsesquare_brace_group();
      }
      peg$silentFails--;
      if (s6 === peg$FAILED) {
        s5 = undefined;
      } else {
        peg$currPos = s5;
        s5 = peg$FAILED;
      }
      if (s5 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s6 !== peg$FAILED) {
          s5 = [s5, s6];
          s4 = s5;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parsein_keyword();
        if (s6 === peg$FAILED) {
          s6 = peg$parsesquare_brace_group();
        }
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = undefined;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      }
      s2 = input.substring(s2, peg$currPos);
      s3 = peg$parsesquare_brace_group();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$parse_comment_();
      s5 = peg$parsein_keyword();
      if (s5 !== peg$FAILED) {
        s6 = peg$parse_comment_();
        s7 = peg$parsegroup();
        if (s7 === peg$FAILED) {
          s7 = peg$parsemacro();
        }
        if (s7 !== peg$FAILED) {
          s8 = peg$parse_comment_();
          s9 = peg$parseforeach();
          if (s9 === peg$FAILED) {
            s9 = peg$parsegroup();
            if (s9 === peg$FAILED) {
              s9 = peg$parsemacro();
            }
          }
          if (s9 !== peg$FAILED) {
            s0 = peg$f5(s1, s2, s3, s4, s6, s7, s8, s9);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsesvg() {
      var s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$parsesvg_keyword();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_comment_();
        s3 = peg$parsesquare_brace_group();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s4 = peg$parse_comment_();
        s5 = peg$parsegroup();
        if (s5 !== peg$FAILED) {
          s0 = peg$f6(s2, s3, s4, s5);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecurve_to() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
      s0 = peg$currPos;
      s1 = peg$parsedotdot();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_comment_();
        s3 = peg$parsecontrols_keyword();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_comment_();
          s5 = peg$parsecoordinate();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_comment_();
            s7 = peg$currPos;
            s8 = peg$parseand_keyword();
            if (s8 !== peg$FAILED) {
              s9 = peg$parse_comment_();
              s10 = peg$parsecoordinate();
              if (s10 !== peg$FAILED) {
                s7 = peg$f7(s2, s4, s5, s6, s9, s10);
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
            } else {
              peg$currPos = s7;
              s7 = peg$FAILED;
            }
            if (s7 === peg$FAILED) {
              s7 = null;
            }
            s8 = peg$parse_comment_();
            s9 = peg$parsedotdot();
            if (s9 !== peg$FAILED) {
              s0 = peg$f8(s2, s4, s5, s6, s7, s8);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseline_to() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsepipe();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseminus();
        if (s2 !== peg$FAILED) {
          s0 = peg$f9();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseminus();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsepipe();
          if (s2 !== peg$FAILED) {
            s0 = peg$f10();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseminus();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseminus();
            if (s2 !== peg$FAILED) {
              s0 = peg$f11();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
      return s0;
    }
    function peg$parsecoordinate() {
      var s0, s1, s2, s3, s4, s5, s6, s7;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$parseplus();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseplus();
        if (s4 === peg$FAILED) {
          s4 = null;
        }
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s1 = input.substring(s1, peg$currPos);
      s2 = peg$parseopen_paren();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        s5 = peg$currPos;
        s6 = peg$currPos;
        peg$silentFails++;
        s7 = peg$parseclose_paren();
        peg$silentFails--;
        if (s7 === peg$FAILED) {
          s6 = undefined;
        } else {
          peg$currPos = s6;
          s6 = peg$FAILED;
        }
        if (s6 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parseclose_paren();
          peg$silentFails--;
          if (s7 === peg$FAILED) {
            s6 = undefined;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        }
        s3 = input.substring(s3, peg$currPos);
        s4 = peg$parseclose_paren();
        if (s4 !== peg$FAILED) {
          s0 = peg$f12(s1, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsesquare_brace_group() {
      var s0, s1, s2, s3, s4, s5, s6;
      s0 = peg$currPos;
      s1 = peg$parseopen_square_brace();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parseclose_square_brace();
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = undefined;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseclose_square_brace();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = undefined;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        }
        s2 = input.substring(s2, peg$currPos);
        s3 = peg$parseclose_square_brace();
        if (s3 !== peg$FAILED) {
          s0 = peg$f13(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsedotdot() {
      var s0, s1, s2;
      s0 = peg$currPos;
      s1 = peg$parsedot();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsedot();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseunknown() {
      var s0, s1;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$f14(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsecomment() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f19(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f20(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e3);
        }
      }
      return s0;
    }
    function peg$parse_() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f21(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f22(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parse_comment_() {
      var s0, s1, s2, s3, s4;
      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      s2 = peg$parsecomment();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      s3 = [];
      s4 = peg$parse_();
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$parse_();
      }
      s0 = peg$f23(s2);
      peg$silentFails--;
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e4);
      }
      return s0;
    }
    function peg$parseoperation() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f24(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f25(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e5);
        }
      }
      return s0;
    }
    function peg$parseequals() {
      var s0, s1, s2;
      peg$silentFails++;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f26(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f27(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e6);
        }
      }
      return s0;
    }
    function peg$parseopen_square_brace() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f28(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f29(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseclose_square_brace() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f30(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f31(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseopen_paren() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f32(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f33(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseclose_paren() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f34(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f35(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseplus() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f36(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f37(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseminus() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f38(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f39(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsepipe() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f40(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f41(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsedot() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f42(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f43(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecontrols_keyword() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f44(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f45(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseand_keyword() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f46(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f47(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsesvg_keyword() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f48(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f49(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsegroup() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f50(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f51(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsemacro() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f52(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f53(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseforeach_keyword() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f54(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f55(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parseforeach_macro() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f56(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f57(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsein_keyword() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f58(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f59(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    function peg$parsecolon() {
      var s0, s1, s2;
      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$f60(s1);
        if (s2) {
          s2 = undefined;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s0 = peg$f61(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      return s0;
    }
    if (!options2.isWhitespace) {
      try {
        Object.assign(options2, {
          isChar: (node2, char) => node2.type === "string" && node2.content === char,
          isOperation: (node2) => node2.type === "string" && node2.content.match(/[a-zA-Z]/),
          isWhitespace: (node2) => node2.type === "whitespace" || node2.type === "parbreak",
          isSameLineComment: (node2) => node2.type === "comment" && node2.sameline,
          isOwnLineComment: (node2) => node2.type === "comment" && !node2.sameline,
          isComment: (node2) => node2.type === "comment",
          isGroup: (node2) => node2.type === "group",
          isMacro: (node2, name) => node2.type === "macro" && node2.content === name,
          isAnyMacro: (node2) => node2.type === "macro"
        });
      } catch (e) {
        console.warn("Error when initializing parser", e);
      }
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();
var LatexPegParser = _LatexPegParser;
var ArgSpecPegParser = _ArgSpecPegParser;

// node_modules/@unified-latex/unified-latex-util-argspec/index.js
var parseCache = {};
function parse2(str = "") {
  parseCache[str] = parseCache[str] || ArgSpecPegParser.parse(str);
  return parseCache[str];
}

// node_modules/@unified-latex/unified-latex-util-scan/index.js
var import_trie_prefix_tree = __toESM(require_dist(), 1);
var import_trie_prefix_tree2 = __toESM(require_dist(), 1);
function scan(nodes, token, options2) {
  const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } = options2 || {};
  if (typeof token === "string") {
    token = { type: "string", content: token };
  }
  for (let i = startIndex || 0;i < nodes.length; i++) {
    const node2 = nodes[i];
    if (node2.type === token.type) {
      switch (node2.type) {
        case "comment":
        case "displaymath":
        case "inlinemath":
        case "root":
        case "parbreak":
        case "whitespace":
        case "verb":
        case "verbatim":
        case "group":
          return i;
        case "macro":
          if (node2.content === token.content) {
            return i;
          }
          break;
        case "environment":
        case "mathenv":
          if (printRaw(node2.env) === printRaw(token.env)) {
            return i;
          }
          break;
        case "string":
          if (node2.content === token.content) {
            return i;
          }
          if (allowSubstringMatches && node2.content.indexOf(token.content) >= 0) {
            return i;
          }
          break;
      }
    }
    if (onlySkipWhitespaceAndComments && !match.whitespace(node2) && !match.comment(node2)) {
      return null;
    }
  }
  return null;
}

// node_modules/@unified-latex/unified-latex-util-arguments/index.js
function gobbleSingleArgument(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string" || !argSpec.type) {
    throw new Error(`argSpec must be an already-parsed argument specification, not "${JSON.stringify(argSpec)}"`);
  }
  let argument = null;
  let currPos = startPos;
  const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {} : () => {
    while (currPos < nodes.length) {
      if (!match.whitespace(nodes[currPos])) {
        break;
      }
      currPos++;
    }
  };
  const openMark = argSpec.openBrace || "";
  const closeMark = argSpec.closeBrace || "";
  const acceptGroup = (argSpec.type === "mandatory" || argSpec.type === "optional") && openMark === "{" && closeMark === "}";
  gobbleWhitespace();
  const currNode = nodes[currPos];
  if (currNode == null || match.comment(currNode) || match.parbreak(currNode)) {
    const ret = {
      argument,
      nodesRemoved: 0
    };
    return ret;
  }
  switch (argSpec.type) {
    case "mandatory":
      if (acceptGroup) {
        let content3 = [currNode];
        if (match.group(currNode)) {
          content3 = currNode.content;
        }
        argument = arg(content3, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      } else {
        const bracePos2 = findBracePositions(nodes, currPos, openMark, closeMark);
        if (bracePos2) {
          argument = arg(nodes.slice(bracePos2[0] + 1, bracePos2[1]), {
            openMark,
            closeMark
          });
          currPos = bracePos2[1] + 1;
          break;
        }
      }
    case "optional":
      if (acceptGroup && match.group(currNode)) {
        argument = arg(currNode.content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
      const bracePos = findBracePositions(nodes, currPos, openMark, closeMark);
      if (bracePos) {
        argument = arg(nodes.slice(bracePos[0] + 1, bracePos[1]), {
          openMark,
          closeMark
        });
        currPos = bracePos[1] + 1;
        break;
      }
      break;
    case "optionalStar":
    case "optionalToken": {
      const bracePos2 = findBracePositions(nodes, currPos, argSpec.type === "optionalStar" ? "*" : argSpec.token);
      if (bracePos2) {
        argument = arg(currNode, { openMark: "", closeMark: "" });
        currPos = bracePos2[0] + 1;
      }
      break;
    }
    case "until": {
      if (argSpec.stopTokens.length > 1) {
        console.warn(`"until" matches with multi-token stop conditions are not yet implemented`);
        break;
      }
      const rawToken = argSpec.stopTokens[0];
      const stopToken = rawToken === " " ? { type: "whitespace" } : rawToken;
      let bracePos2 = findBracePositions(nodes, startPos, undefined, stopToken);
      if (!bracePos2) {
        break;
      }
      argument = arg(nodes.slice(startPos, bracePos2[1]), {
        openMark: "",
        closeMark: rawToken
      });
      currPos = bracePos2[1];
      if (currPos < nodes.length) {
        currPos++;
      }
      break;
    }
    case "embellishment": {
      for (const token of argSpec.embellishmentTokens) {
        const bracePos2 = findBracePositions(nodes, currPos, token);
        if (!bracePos2) {
          continue;
        }
        let argNode = nodes[bracePos2[0] + 1];
        argument = arg(match.group(argNode) ? argNode.content : argNode, {
          openMark: token,
          closeMark: ""
        });
        currPos = bracePos2[1] + 1;
        break;
      }
      break;
    }
    default:
      console.warn(`Don't know how to find an argument of argspec type "${argSpec.type}"`);
  }
  const nodesRemoved = argument ? currPos - startPos : 0;
  nodes.splice(startPos, nodesRemoved);
  return { argument, nodesRemoved };
}
function cloneStringNode(node2, content3) {
  return Object.assign({}, node2, { content: content3 });
}
function findBracePositions(nodes, startPos, openMark, closeMark) {
  const currNode = nodes[startPos];
  let openMarkPos = startPos;
  let closeMarkPos = startPos;
  if (openMark) {
    if (!match.anyString(currNode)) {
      return;
    }
    const nodeContent = currNode.content;
    if (!nodeContent.startsWith(openMark)) {
      return;
    }
    openMarkPos = startPos;
    if (currNode.content.length > openMark.length) {
      const nodeContent2 = currNode.content;
      currNode.content = openMark;
      nodes.splice(openMarkPos + 1, 0, cloneStringNode(currNode, nodeContent2.slice(openMark.length)));
    }
    closeMarkPos = openMarkPos + 1;
  }
  if (!closeMark) {
    const argNode = nodes[closeMarkPos];
    if (!argNode) {
      return;
    }
    if (match.anyString(argNode) && argNode.content.length > 1) {
      const argContent = argNode.content;
      argNode.content = argContent[0];
      nodes.splice(closeMarkPos + 1, 0, cloneStringNode(argNode, argContent.slice(1)));
    }
    return [openMarkPos, closeMarkPos];
  }
  closeMarkPos = scan(nodes, closeMark, {
    startIndex: closeMarkPos,
    allowSubstringMatches: true
  });
  if (closeMarkPos === null) {
    return;
  }
  const closingNode = nodes[closeMarkPos];
  if (match.anyString(closingNode) && typeof closeMark === "string") {
    const closingNodeContent = closingNode.content;
    let closeMarkIndex = closingNodeContent.indexOf(closeMark);
    if (closingNodeContent.length > closeMark.length) {
      closingNode.content = closeMark;
      const prev = closingNodeContent.slice(0, closeMarkIndex);
      const next = closingNodeContent.slice(closeMarkIndex + closeMark.length);
      if (prev) {
        nodes.splice(closeMarkPos, 0, cloneStringNode(closingNode, prev));
        closeMarkPos++;
      }
      if (next) {
        nodes.splice(closeMarkPos + 1, 0, cloneStringNode(closingNode, next));
      }
    }
  }
  return [openMarkPos, closeMarkPos];
}
function gobbleArguments(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "function") {
    return argSpec(nodes, startPos);
  }
  if (typeof argSpec === "string") {
    argSpec = parse2(argSpec);
  }
  const args = [];
  let nodesRemoved = 0;
  for (const spec of argSpec) {
    if (spec.type === "embellishment") {
      const remainingTokens = new Set(spec.embellishmentTokens);
      const argForToken = Object.fromEntries(spec.embellishmentTokens.map((t, i) => {
        var _a;
        const defaultArg = "defaultArg" in spec ? (_a = spec.defaultArg) == null ? undefined : _a[i] : undefined;
        return [t, emptyArg(defaultArg)];
      }));
      let { argument, nodesRemoved: removed } = gobbleSingleArgument(nodes, embellishmentSpec(remainingTokens), startPos);
      while (argument) {
        const token = argument.openMark;
        remainingTokens.delete(token);
        argForToken[token] = argument;
        nodesRemoved += removed;
        const newSpec = embellishmentSpec(remainingTokens);
        ({ argument, nodesRemoved: removed } = gobbleSingleArgument(nodes, newSpec, startPos));
      }
      args.push(...spec.embellishmentTokens.map((t) => argForToken[t]));
    } else {
      const { argument, nodesRemoved: removed } = gobbleSingleArgument(nodes, spec, startPos);
      const defaultArg = "defaultArg" in spec ? spec.defaultArg : undefined;
      args.push(argument || emptyArg(defaultArg));
      nodesRemoved += removed;
    }
  }
  return { args, nodesRemoved };
}
function embellishmentSpec(tokens) {
  return {
    type: "embellishment",
    embellishmentTokens: [...tokens]
  };
}
function emptyArg(defaultArg) {
  const ret = arg([], { openMark: "", closeMark: "" });
  if (defaultArg != null) {
    updateRenderInfo(ret, { defaultArg });
  }
  return ret;
}
function attachMacroArgsInArray(nodes, macros7) {
  let currIndex;
  const isRelevantMacro = match.createMacroMatcher(macros7);
  function gobbleUntilMacro() {
    while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {
      currIndex--;
    }
  }
  currIndex = nodes.length - 1;
  while (currIndex >= 0) {
    gobbleUntilMacro();
    if (currIndex < 0) {
      return;
    }
    const macroIndex = currIndex;
    const macro = nodes[macroIndex];
    const macroName = macro.content;
    const macroInfo = macros7[macroName];
    updateRenderInfo(macro, macroInfo.renderInfo);
    const signatureOrParser = macroInfo.argumentParser || macroInfo.signature;
    if (signatureOrParser == null) {
      currIndex--;
      continue;
    }
    if (macro.args != null) {
      currIndex = macroIndex - 1;
      continue;
    }
    currIndex++;
    const { args } = gobbleArguments(nodes, signatureOrParser, currIndex);
    macro.args = args;
    currIndex = macroIndex - 1;
  }
}

// node_modules/@unified-latex/unified-latex-ctan/provides-Ch0mvkO_.js
var argSpecM = parse2("m")[0];
var argSpecO = parse2("o")[0];
var argSpecRDelim = {};
var argumentParser = (nodes, startPos) => {
  const { argument: optionalArg, nodesRemoved: optionalArgNodesRemoved } = gobbleSingleArgument(nodes, argSpecO, startPos);
  let codeArg = null;
  let codeArgNodesRemoved = 0;
  const nextNode = nodes[startPos];
  if (match.group(nextNode)) {
    const mandatoryArg = gobbleSingleArgument(nodes, argSpecM, startPos);
    codeArg = mandatoryArg.argument;
    codeArgNodesRemoved = mandatoryArg.nodesRemoved;
  } else if (match.string(nextNode) && nextNode.content.length === 1) {
    const delim = nextNode.content;
    argSpecRDelim[delim] = argSpecRDelim[delim] || parse2(`r${delim}${delim}`)[0];
    const delimArg = gobbleSingleArgument(nodes, argSpecRDelim[delim], startPos);
    codeArg = delimArg.argument;
    codeArgNodesRemoved = delimArg.nodesRemoved;
  }
  return {
    args: [optionalArg || arg(null), codeArg || arg(null)],
    nodesRemoved: optionalArgNodesRemoved + codeArgNodesRemoved
  };
};
var macros7 = {
  lstset: { signature: "m" },
  lstinline: { argumentParser },
  lstinputlisting: { signature: "o m" },
  lstdefinestyle: { signature: "m m" },
  lstnewenvironment: { signature: "m o o m m" },
  lstMakeShortInline: { signature: "o m" },
  lstDeleteShortInline: { signature: "m" },
  lstdefineformat: { signature: "m m" },
  lstdefinelanguage: { signature: "o m o m o" },
  lstalias: { signature: "o m o m" },
  lstloadlanguages: { signature: "m" }
};
var environments7 = {};

// node_modules/@unified-latex/unified-latex-ctan/package/makeidx/index.js
var macros8 = {
  see: { signature: "m m" },
  seealso: { signature: "m m" },
  seename: { signature: "m" },
  alsoname: { signature: "m" },
  index: { signature: "m" }
};
var environments8 = {};

// node_modules/@unified-latex/unified-latex-ctan/package/mathtools/index.js
var macros9 = {
  mathtoolsset: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  mathllap: {
    signature: "o m"
  },
  mathrlap: {
    signature: "o m"
  },
  mathclap: {
    signature: "o m"
  },
  clap: {
    signature: "m"
  },
  mathmbox: {
    signature: "m"
  },
  mathmakebox: {
    signature: "o o m"
  },
  cramped: {
    signature: "o m"
  },
  crampedllap: {
    signature: "o m"
  },
  crampedrlap: {
    signature: "o m"
  },
  crampedclap: {
    signature: "o m"
  },
  crampedsubstack: {
    signature: "o m"
  },
  smashoperator: {
    signature: "o m"
  },
  newtagform: {
    signature: "m o m m"
  },
  renewtagform: {
    signature: "m o m m"
  },
  usetagform: {
    signature: "m"
  },
  xleftrightarrow: { signature: "o m" },
  xLeftarrow: { signature: "o m" },
  xhookleftarrow: { signature: "o m" },
  xmapsto: { signature: "o m" },
  xRightarrow: { signature: "o m" },
  xLeftrightarrow: { signature: "o m" },
  xhookrightarrow: { signature: "o m" },
  underbracket: { signature: "o o m" },
  overbracket: { signature: "o o m" },
  underbrace: { signature: "m" },
  overbrace: { signature: "m" },
  shoveleft: { signature: "o m" },
  shoveright: { signature: "o m" },
  ArrowBetweenLines: { signature: "s o" },
  vdotswithin: { signature: "m" },
  shortdotswithin: { signature: "s m" },
  DeclarePairedDelimiter: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  DeclarePairedDelimiterX: {
    signature: "m o m m m",
    renderInfo: { breakAround: true }
  },
  DeclarePairedDelimiterXPP: {
    signature: "m o m m m m m",
    renderInfo: { breakAround: true }
  },
  prescript: { signature: "m m m" },
  DeclareMathSizes: { signature: "m m m m" },
  newgathered: { signature: "m m m m" },
  renewgathered: { signature: "m m m m" },
  splitfrac: { signature: "m m" },
  splitdfrac: { signature: "m m" },
  xmathstrut: { signature: "o m" },
  newtheorem: { signature: "s m o m o", renderInfo: { breakAround: true } },
  theoremstyle: { signature: "m", renderInfo: { breakAround: true } },
  newtheoremstyle: {
    signature: "m m m m m m m m m",
    renderInfo: { breakAround: true }
  },
  text: { signature: "m", renderInfo: { inMathMode: false } },
  mathbb: { signature: "m" },
  mathscr: { signature: "m" },
  mathfrak: { signature: "m" },
  frak: { signature: "m" },
  Bdd: { signature: "m" },
  bold: { signature: "m" },
  operatorname: { signature: "s m" },
  DeclareMathOperator: {
    signature: "s m m",
    renderInfo: { breakAround: true }
  }
};
var environments9 = {
  crampedsubarray: {
    signature: "m",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  matrix: { renderInfo: { alignContent: true, inMathMode: true } },
  bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  pmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  Bmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  Vmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  smallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  psmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  Bsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  Vsmallmatrix: { renderInfo: { alignContent: true, inMathMode: true } },
  "matrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "bmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "pmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "vmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "Bmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "Vmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "smallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "psmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "bsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "vsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "Bsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  "Vsmallmatrix*": {
    signature: "o",
    renderInfo: { alignContent: true, inMathMode: true }
  },
  multilined: { signature: "o o", renderInfo: { inMathMode: true } },
  cases: { renderInfo: { alignContent: true, inMathMode: true } },
  "cases*": { renderInfo: { alignContent: true, inMathMode: true } },
  dcases: { renderInfo: { alignContent: true, inMathMode: true } },
  "dcases*": { renderInfo: { alignContent: true, inMathMode: true } },
  rcases: { renderInfo: { alignContent: true, inMathMode: true } },
  "rcases*": { renderInfo: { alignContent: true, inMathMode: true } },
  drcases: { renderInfo: { alignContent: true, inMathMode: true } },
  "drcases*": { renderInfo: { alignContent: true, inMathMode: true } },
  spreadlines: { signature: "m", renderInfo: { inMathMode: true } },
  lgathered: { signature: "o", renderInfo: { inMathMode: true } },
  rgathered: { signature: "o", renderInfo: { inMathMode: true } },
  "align*": { renderInfo: { inMathMode: true, alignContent: true } },
  align: { renderInfo: { inMathMode: true, alignContent: true } },
  aligned: { renderInfo: { inMathMode: true, alignContent: true } },
  "alignat*": { renderInfo: { inMathMode: true, alignContent: true } },
  alignat: { renderInfo: { inMathMode: true, alignContent: true } },
  "equation*": { renderInfo: { inMathMode: true } },
  equation: { renderInfo: { inMathMode: true } },
  "gather*": { renderInfo: { inMathMode: true } },
  gather: { renderInfo: { inMathMode: true } },
  "multline*": { renderInfo: { inMathMode: true } },
  multline: { renderInfo: { inMathMode: true } },
  "flalign*": { renderInfo: { inMathMode: true, alignContent: true } },
  flalign: { renderInfo: { inMathMode: true, alignContent: true } },
  split: { renderInfo: { inMathMode: true } },
  displaymath: { renderInfo: { inMathMode: true } },
  theorem: { signature: "o" },
  lemma: { signature: "o" },
  definition: { signature: "o" },
  proposition: { signature: "o" },
  corollary: { signature: "o" },
  remark: { signature: "!o" },
  example: { signature: "!o" },
  proof: { signature: "o" }
};

// node_modules/@unified-latex/unified-latex-ctan/provides-sdqk_ZBm.js
var argSpecM2 = parse2("m")[0];
var argSpecO2 = parse2("o")[0];
var argSpecRDelim2 = {};
var argumentParser2 = (nodes, startPos) => {
  const { argument: optionalArg, nodesRemoved: optionalArgNodesRemoved } = gobbleSingleArgument(nodes, argSpecO2, startPos);
  const { argument: languageArg, nodesRemoved: languageArgNodesRemoved } = gobbleSingleArgument(nodes, argSpecM2, startPos);
  let codeArg = null;
  let codeArgNodesRemoved = 0;
  const nextNode = nodes[startPos];
  if (match.group(nextNode)) {
    const mandatoryArg = gobbleSingleArgument(nodes, argSpecM2, startPos);
    codeArg = mandatoryArg.argument;
    codeArgNodesRemoved = mandatoryArg.nodesRemoved;
  } else if (match.string(nextNode) && nextNode.content.length === 1) {
    const delim = nextNode.content;
    argSpecRDelim2[delim] = argSpecRDelim2[delim] || parse2(`r${delim}${delim}`)[0];
    const delimArg = gobbleSingleArgument(nodes, argSpecRDelim2[delim], startPos);
    codeArg = delimArg.argument;
    codeArgNodesRemoved = delimArg.nodesRemoved;
  }
  return {
    args: [
      optionalArg || arg(null),
      languageArg || arg(null),
      codeArg || arg(null)
    ],
    nodesRemoved: optionalArgNodesRemoved + languageArgNodesRemoved + codeArgNodesRemoved
  };
};
var macros10 = {
  mint: { argumentParser: argumentParser2 },
  mintinline: { argumentParser: argumentParser2 },
  inputminted: { argumentParser: argumentParser2 },
  usemintedstyle: { signature: "m" },
  setminted: { signature: "o m" },
  setmintedinline: { signature: "o m" },
  newmint: { signature: "o m m" },
  newminted: { signature: "o m m" },
  newmintinline: { signature: "o m m" },
  newmintedfile: { signature: "o m m" }
};
var environments10 = {
  minted: { signature: "o m" }
};

// node_modules/@unified-latex/unified-latex-ctan/package/nicematrix/index.js
var macros11 = {
  NiceMatrixOptions: {
    signature: "m",
    renderInfo: { pgfkeysArgs: true, breakAround: true }
  }
};
var environments11 = {
  NiceTabular: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  NiceMatrixBlock: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  NiceArrayWithDelims: {
    signature: "m m o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  NiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  pNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  bNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  BNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  vNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  VNiceArray: {
    signature: "o m !o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  NiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  pNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  bNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  BNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  vNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  },
  VNiceMatrix: {
    signature: "!o",
    renderInfo: { pgfkeysArgs: true, alignContent: true }
  }
};

// node_modules/@unified-latex/unified-latex-ctan/provides-yGf6-zdY.js
var macros12 = {
  systeme: {
    signature: "s o o m",
    renderInfo: { inMathMode: true }
  },
  sysdelim: {
    signature: "m m"
  },
  syseqsep: { signature: "m" },
  sysalign: { signature: "m" },
  syssignspace: { signature: "m" },
  syseqspace: { signature: "m" },
  syslineskipcoeff: { signature: "m" },
  syseqivsign: { signature: "m" },
  sysaddeqsign: { signature: "m" },
  sysremoveeqsign: { signature: "m" },
  sysextracolonsign: { signature: "m" },
  syscodeextracol: { signature: "m" },
  sysautonum: { signature: "m" },
  syssubstitute: { signature: "m" }
};
var environments12 = {};

// node_modules/@unified-latex/unified-latex-ctan/index-NHd3tQDq.js
(function() {
  if (typeof globalThis === "object") {
    return;
  }
  Object.defineProperty(Object.prototype, "__magic__", {
    get: function() {
      return this;
    },
    configurable: true
  });
  __magic__.globalThis = __magic__;
  delete Object.prototype.__magic__;
})();
var clone = typeof globalThis.structuredClone === "function" ? globalThis.structuredClone : (obj) => JSON.parse(JSON.stringify(obj));

// node_modules/@unified-latex/unified-latex-ctan/parser-BBXMi7mQ.js
var OPTIONAL_ARGUMENT_ARG_SPEC = parse2("o")[0];
function blankArg() {
  return arg([], { openMark: "", closeMark: "" });
}
var tikzCommandArgumentParser = (nodes, startPos) => {
  const origStartPos = startPos;
  let pos = startPos;
  let nodesRemoved = 0;
  const cursorPosAfterAnimations = eatAllAnimationSpecs(nodes, pos);
  let animationArg = blankArg();
  if (cursorPosAfterAnimations !== pos) {
    const argContent = nodes.splice(pos, cursorPosAfterAnimations - pos);
    trim(argContent);
    animationArg = arg(argContent, {
      openMark: " ",
      closeMark: " "
    });
  }
  nodesRemoved += cursorPosAfterAnimations - pos;
  const {
    argument: _optionalArgument,
    nodesRemoved: optionalArgumentNodesRemoved
  } = gobbleSingleArgument(nodes, OPTIONAL_ARGUMENT_ARG_SPEC, pos);
  nodesRemoved += optionalArgumentNodesRemoved;
  const optionalArg = _optionalArgument || blankArg();
  while (match.whitespace(nodes[pos])) {
    pos++;
  }
  const firstNode = nodes[pos];
  if (!firstNode) {
    return {
      args: [animationArg, optionalArg, blankArg()],
      nodesRemoved: 0
    };
  }
  if (match.group(firstNode)) {
    const args = [animationArg, optionalArg, arg(firstNode.content)];
    nodes.splice(origStartPos, pos - origStartPos + 1);
    return { args, nodesRemoved: pos - origStartPos + 1 + nodesRemoved };
  }
  const semicolonPosition = scan(nodes, ";", { startIndex: pos });
  if (semicolonPosition != null) {
    const argNodes = nodes.splice(origStartPos, semicolonPosition - origStartPos + 1);
    trim(argNodes);
    const args = [animationArg, optionalArg, arg(argNodes)];
    return {
      args,
      nodesRemoved: origStartPos - semicolonPosition + 1 + nodesRemoved
    };
  }
  return {
    args: [animationArg, optionalArg, blankArg()],
    nodesRemoved: 0
  };
};
function eatAllAnimationSpecs(nodes, startPos) {
  const colonPos = scan(nodes, ":", {
    startIndex: startPos,
    allowSubstringMatches: true,
    onlySkipWhitespaceAndComments: true
  });
  if (!colonPos) {
    return startPos;
  }
  let lastMatchPos = startPos;
  let i = colonPos + 1;
  for (;i < nodes.length; i++) {
    const node2 = nodes[i];
    if (match.string(node2, "[")) {
      break;
    }
    if (match.string(node2, "=")) {
      i++;
      while (match.whitespace(nodes[i]) || match.comment(nodes[i])) {
        i++;
      }
      if (!match.group(nodes[i])) {
        break;
      }
      lastMatchPos = i + 1;
      const colonPos2 = scan(nodes, ":", {
        startIndex: lastMatchPos,
        allowSubstringMatches: true,
        onlySkipWhitespaceAndComments: true
      });
      if (colonPos2 == null) {
        break;
      }
      i = colonPos2 + 1;
    }
  }
  return lastMatchPos;
}
var macros13 = {
  pgfkeys: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  tikzoption: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  tikzstyle: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  usetikzlibrary: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  usepgfmodule: { signature: "m", renderInfo: { pgfkeysArgs: true } },
  usepgflibrary: { signature: "m", renderInfo: { pgfkeysArgs: true } },
  pgfplotsset: {
    signature: "m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  pgfplotstabletypeset: {
    signature: "o m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  tikz: {
    signature: "o o m",
    argumentParser: tikzCommandArgumentParser,
    renderInfo: { namedArguments: ["animation", "options", "command"] }
  }
};
var environments13 = {
  tikzpicture: {
    signature: "o",
    renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  axis: {
    signature: "o",
    renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  scope: {
    signature: "o",
    renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  pgfonlayer: {
    signature: "m",
    renderInfo: { tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  pgflowlevelscope: {
    signature: "m",
    renderInfo: { tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  pgfviewboxscope: {
    signature: "m m m m m",
    renderInfo: { tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  pgftransparencygroup: {
    signature: "o",
    renderInfo: { pgfkeysArgs: true, tikzEnvironment: true },
    processContent: processTikzEnvironmentContent
  },
  behindforegroundpath: {
    signature: "m",
    processContent: processTikzEnvironmentContent
  },
  pgfmetadecoration: {
    signature: "m",
    processContent: processTikzEnvironmentContent
  },
  colormixin: { signature: "m", renderInfo: { pgfkeysArgs: true } }
};
function processTikzEnvironmentContent(nodes) {
  attachMacroArgsInArray(nodes, conditionalMacros);
  return nodes;
}
var conditionalMacros = {
  pgfextra: { signature: "m" },
  beginpgfgraphicnamed: { signature: "m" },
  pgfrealjobname: { signature: "m" },
  pgfplotstreampoint: { signature: "m" },
  pgfplotstreampointoutlier: { signature: "m" },
  pgfplotstreamspecial: { signature: "m" },
  pgfplotxyfile: { signature: "m" },
  pgfplotxyzfile: { signature: "m" },
  pgfplotfunction: { signature: "mmm" },
  pgfplotgnuplot: { signature: "o m" },
  pgfplothandlerrecord: { signature: "m" },
  pgfdeclareplothandler: { signature: "m m m" },
  pgfdeclarelayer: { signature: "m" },
  pgfsetlayers: { signature: "m", renderInfo: { pgfkeysArgs: true } },
  pgfonlayer: { signature: "m" },
  startpgfonlayer: { signature: "m" },
  pgfdeclarehorizontalshading: { signature: "o m m m " },
  pgfdeclareradialshading: { signature: "o m m m" },
  pgfdeclarefunctionalshading: { signature: "o m m m m m" },
  pgfshadecolortorgb: { signature: "m m" },
  pgfshadecolortocmyk: { signature: "m m" },
  pgfshadecolortogray: { signature: "m m" },
  pgfuseshading: { signature: "m" },
  pgfshadepath: { signature: "m m" },
  pgfsetadditionalshadetransform: { signature: "m" },
  pgfsetstrokeopacity: { signature: "m" },
  pgfsetfillopacity: { signature: "m" },
  pgfsetblendmode: { signature: "m" },
  pgfdeclarefading: { signature: "m m" },
  pgfsetfading: { signature: "m m" },
  pgfsetfadingforcurrentpath: { signature: "m m" },
  pgfsetfadingforcurrentpathstroked: { signature: "m m" },
  pgfanimateattribute: { signature: "m m" },
  pgfsnapshot: { signature: "m" },
  pgfqpoint: { signature: "m m" },
  pgfqpointxy: { signature: "m m" },
  pgfqpointxyz: { signature: "m m m" },
  pgfqpointscale: { signature: "m m" },
  pgfpathqmoveto: { signature: "m m" },
  pgfpathqlineto: { signature: "m m" },
  pgfpathqcurveto: { signature: "m m m m m m" },
  pgfpathqcircle: { signature: "m" },
  pgfqbox: { signature: "m" },
  pgfqboxsynced: { signature: "m" },
  pgfaliasimage: { signature: "m m" },
  pgfuseimage: { signature: "m" },
  pgfimage: { signature: "o m", renderInfo: { pgfkeysArgs: true } },
  pgfdeclaremask: { signature: "o m m", renderInfo: { pgfkeysArgs: true } },
  pgfdeclarepatternformonly: { signature: "o m m m m m" },
  pgfdeclarepatterninherentlycolored: { signature: "o m m m m m" },
  pgfsetfillpattern: { signature: "m m" },
  pgftransformshift: { signature: "m" },
  pgftransformxshift: { signature: "m" },
  pgftransformyshift: { signature: "m" },
  pgftransformscale: { signature: "m" },
  pgftransformxscale: { signature: "m" },
  pgftransformyscale: { signature: "m" },
  pgftransformxslant: { signature: "m" },
  pgftransformyslant: { signature: "m" },
  pgftransformrotate: { signature: "m" },
  pgftransformtriangle: { signature: "m m m" },
  pgftransformcm: { signature: "m m m m m" },
  pgftransformarrow: { signature: "m m" },
  pgftransformlineattime: { signature: "m m m" },
  pgftransformcurveattime: { signature: "m m m m m" },
  pgftransformarcaxesattime: { signature: "m m m m m m" },
  pgfgettransform: { signature: "m" },
  pgfsettransform: { signature: "m" },
  pgfgettransformentries: { signature: "m m m m m m" },
  pgfsettransformentries: { signature: "m m m m m m" },
  pgfpointtransformed: { signature: "m" },
  pgflowlevel: { signature: "m" },
  pgflowlevelobj: { signature: "m m" },
  pgflowlevelscope: { signature: "m" },
  startpgflowlevelscope: { signature: "m" },
  pgfviewboxscope: { signature: "m m m m m" },
  startpgfviewboxscope: { signature: "m m m m m" },
  pgftransformnonlinear: { signature: "m" },
  pgfpointtransformednonlinear: { signature: "m" },
  pgfsetcurvilinearbeziercurve: { signature: "m m m m" },
  pgfcurvilineardistancetotime: { signature: "m" },
  pgfpointcurvilinearbezierorthogonal: { signature: "m m" },
  pgfpointcurvilinearbezierpolar: { signature: "m m" },
  pgfmatrix: { signature: "m m m m m m m" },
  pgfsetmatrixcolumnsep: { signature: "m" },
  pgfmatrixnextcell: { signature: "o" },
  pgfsetmatrixrowsep: { signature: "m" },
  pgfmatrixendrow: { signature: "o" },
  pgfnode: { signature: "m m m m m" },
  pgfmultipartnode: { signature: "m m m m" },
  pgfcoordinate: { signature: "m m" },
  pgfnodealias: { signature: "m m" },
  pgfnoderename: { signature: "m m" },
  pgfpositionnodelater: { signature: "m" },
  pgfpositionnodenow: { signature: "m" },
  pgfnodepostsetupcode: { signature: "m m" },
  pgfpointanchor: { signature: "m m" },
  pgfpointshapeborder: { signature: "m m" },
  pgfdeclareshape: { signature: "m m" },
  saveddimen: { signature: "m m" },
  savedmacro: { signature: " m" },
  anchor: { signature: "m m" },
  deferredanchor: { signature: "m m" },
  anchorborder: { signature: "m" },
  backgroundpath: { signature: "m" },
  foregroundpath: { signature: "m" },
  behindbackgroundpath: { signature: "m" },
  beforebackgroundpath: { signature: "m" },
  beforeforegroundpath: { signature: "m" },
  behindforegroundpath: { signature: "m" },
  pgfdeclarearrow: { signature: "m" },
  pgfarrowssettipend: { signature: "m" },
  pgfarrowssetbackend: { signature: "m" },
  pgfarrowssetlineend: { signature: "m" },
  pgfarrowssetvisualbackend: { signature: "m" },
  pgfarrowssetvisualtipend: { signature: "m" },
  pgfarrowshullpoint: { signature: "m m" },
  pgfarrowsupperhullpoint: { signature: "m m" },
  pgfarrowssave: { signature: "m" },
  pgfarrowssavethe: { signature: "m" },
  pgfarrowsaddtooptions: { signature: "m" },
  pgfarrowsaddtolateoptions: { signature: "m" },
  pgfarrowsaddtolengthscalelist: { signature: "m" },
  pgfarrowsaddtowidthscalelist: { signature: "m" },
  pgfarrowsthreeparameters: { signature: "m" },
  pgfarrowslinewidthdependent: { signature: "m m m" },
  pgfarrowslengthdependent: { signature: "m" },
  pgfusepath: { signature: "m" },
  pgfsetlinewidth: { signature: "m" },
  pgfsetmiterlimit: { signature: "m" },
  pgfsetdash: { signature: "m m" },
  pgfsetstrokecolor: { signature: "m" },
  pgfsetcolor: { signature: "m" },
  pgfsetinnerlinewidth: { signature: "m" },
  pgfsetinnerstrokecolor: { signature: "m" },
  pgfsetarrowsstart: { signature: "m" },
  pgfsetarrowsend: { signature: "m" },
  pgfsetarrows: { signature: "m" },
  pgfsetshortenstart: { signature: "m" },
  pgfsetshortenend: { signature: "m" },
  pgfsetfillcolor: { signature: "m" },
  pgfdeclaredecoration: { signature: "m m m" },
  state: { signature: "m o m" },
  pgfdecoratepath: { signature: "m m" },
  startpgfdecoration: { signature: "m" },
  pgfdecoration: { signature: "m" },
  pgfdecoratecurrentpath: { signature: "m" },
  pgfsetdecorationsegmenttransformation: { signature: "m" },
  pgfdeclaremetadecorate: { signature: "m m m" },
  pgfmetadecoration: { signature: "m" },
  startpgfmetadecoration: { signature: "m" },
  pgfpathmoveto: { signature: "m" },
  pgfpathlineto: { signature: "m" },
  pgfpathcurveto: { signature: "m m m" },
  pgfpathquadraticcurveto: { signature: "m m" },
  pgfpathcurvebetweentime: { signature: "m m m m m m" },
  pgfpathcurvebetweentimecontinue: { signature: "m m m m m m" },
  pgfpatharc: { signature: "m m m" },
  pgfpatharcaxes: { signature: "m m m m" },
  pgfpatharcto: { signature: "m m m m m m" },
  pgfpatharctoprecomputed: { signature: "m m m m m m m m" },
  pgfpathellipse: { signature: "m m m" },
  pgfpathcircle: { signature: "m m" },
  pgfpathrectangle: { signature: "m m" },
  pgfpathrectanglecorners: { signature: "m m" },
  pgfpathgrid: { signature: " o m m" },
  pgfpathparabola: { signature: "m m" },
  pgfpathsine: { signature: "m" },
  pgfpathcosine: { signature: "m" },
  pgfsetcornersarced: { signature: "m" },
  "pgf@protocolsizes": { signature: "m m" },
  pgfpoint: { signature: "m m" },
  pgfpointpolar: { signature: "m m m" },
  pgfpointxy: { signature: "m m" },
  pgfsetxvec: { signature: "m" },
  pgfsetyvec: { signature: "m" },
  pgfpointpolarxy: { signature: "m m" },
  pgfpointxyz: { signature: "m m m" },
  pgfsetzvec: { signature: "m" },
  pgfpointcylindrical: { signature: "m m m" },
  pgfpointspherical: { signature: "m m m" },
  pgfpointadd: { signature: "m m" },
  pgfpointscale: { signature: "m m" },
  pgfpointdiff: { signature: "m m" },
  pgfpointnormalised: { signature: "m" },
  pgfpointlineattime: { signature: "m m m" },
  pgfpointlineatdistance: { signature: "m m m" },
  pgfpointarcaxesattime: { signature: "m m m m m m" },
  pgfpointcurveattime: { signature: "m m m m m" },
  pgfpointborderrectangle: { signature: "m m" },
  pgfpointborderellipse: { signature: "m m" },
  pgfpointintersectionoflines: { signature: "m m m m" },
  pgfpointintersectionofcircles: { signature: "m m m m m" },
  pgfintersectionofpaths: { signature: "m m" },
  pgfpointintersectionsolution: { signature: "m" },
  pgfextractx: { signature: "m m" },
  pgfextracty: { signature: "m m" },
  pgfgetlastxy: { signature: "m m" },
  "pgf@process": { signature: "m" },
  pgfsetbaseline: { signature: "m" },
  pgfsetbaselinepointnow: { signature: "m" },
  pgfsetbaselinepointlater: { signature: "m" },
  pgftext: { signature: "o m", renderInfo: { pgfkeysArgs: true } },
  pgfuseid: { signature: "m" },
  pgfusetype: { signature: "m" },
  pgfidrefnextuse: { signature: "m m" },
  pgfidrefprevuse: { signature: "m m" },
  pgfaliasid: { signature: "m m" },
  pgfgaliasid: { signature: "m m" },
  pgfifidreferenced: { signature: "m m m" },
  pgfrdfabout: { signature: "m" },
  pgfrdfcontent: { signature: "m" },
  pgfrdfdatatype: { signature: "m" },
  pgfrdfhref: { signature: "m" },
  pgfrdfprefix: { signature: "m" },
  pgfrdfproperty: { signature: "m" },
  pgfrdfrel: { signature: "m" },
  pgfrdfresource: { signature: "m" },
  pgfrdfrev: { signature: "m" },
  pgfrdfsrc: { signature: "m" },
  pgfrdftypeof: { signature: "m" },
  pgfrdfvocab: { signature: "m" },
  pgferror: { signature: "m" },
  pgfwarning: { signature: "m" },
  path: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  draw: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  fill: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  filldraw: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  pattern: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  shade: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  clip: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  useasboundingbox: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  node: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  coordinate: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  graph: {
    signature: "u;",
    renderInfo: { breakAround: true, tikzPathCommand: true }
  },
  scoped: {
    signature: "o o m",
    argumentParser: tikzCommandArgumentParser,
    renderInfo: {
      namedArguments: ["animation", "options", "command"],
      breakAround: true
    }
  }
};
function createMatchers2() {
  return {
    isChar: match.string,
    isTerminal: (node2) => match.string(node2, ";"),
    isOperation: (node2) => match.anyString(node2) && node2.content.match(/[a-zA-Z]/),
    isWhitespace: (node2) => match.whitespace(node2) || match.parbreak(node2),
    isComment: match.comment,
    isGroup: match.group,
    isMacro: match.macro,
    isAnyMacro: match.anyMacro
  };
}
var matchers = createMatchers2();

// node_modules/@unified-latex/unified-latex-ctan/xcolor-CIejE3rZ.js
var import_color2 = __toESM(require_color(), 1);
var macros14 = {
  substitutecolormodel: {
    signature: "m m",
    renderInfo: { breakAround: true }
  },
  selectcolormodel: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  definecolor: {
    signature: "o m m m",
    renderInfo: { breakAround: true }
  },
  providecolor: {
    signature: "o m m m",
    renderInfo: { breakAround: true }
  },
  colorlet: {
    signature: "o m o m",
    renderInfo: { breakAround: true }
  },
  definecolorset: {
    signature: "o m m m",
    renderInfo: { breakAround: true }
  },
  providecolorset: {
    signature: "o m m m m",
    renderInfo: { breakAround: true }
  },
  preparecolor: {
    signature: "o m m m",
    renderInfo: { breakAround: true }
  },
  preparecolorset: {
    signature: "o m m m m",
    renderInfo: { breakAround: true }
  },
  DefineNamedColor: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  definecolors: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  providecolors: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  color: { signature: "o m", renderInfo: { breakAround: true } },
  textcolor: { signature: "o m m", renderInfo: { inParMode: true } },
  pagecolor: { signature: "o m" },
  colorbox: { signature: "o m m" },
  fcolorbox: { signature: "o m o m m" },
  boxframe: { signature: "o m" },
  testcolor: { signature: "o m" },
  blendcolors: { signature: "s m" },
  maskcolors: { signature: "o m" },
  definecolorseries: {
    signature: "m m m o m o m",
    renderInfo: { breakAround: true }
  },
  resetcolorseries: {
    signature: "o m",
    renderInfo: { breakAround: true }
  },
  rowcolors: { signature: "s o m m m" },
  extractcolorspec: { signature: "m m" },
  extractcolorspecs: { signature: "m m m" },
  convertcolorspec: { signature: "m m m m" }
};
var environments14 = {
  testcolors: { signature: "o", renderInfo: { pgfkeysArgs: true } }
};
var fromRgb = ([r, g, b]) => import_color2.default([r * 255, g * 255, b * 255], "rgb");
var DVI_PS_NAMES = {
  Apricot: import_color2.default("#FBB982"),
  Aquamarine: import_color2.default("#00B5BE"),
  Bittersweet: import_color2.default("#C04F17"),
  Black: import_color2.default("#221E1F"),
  Blue: import_color2.default("#2D2F92"),
  BlueGreen: import_color2.default("#00B3B8"),
  BlueViolet: import_color2.default("#473992"),
  BrickRed: import_color2.default("#B6321C"),
  Brown: import_color2.default("#792500"),
  BurntOrange: import_color2.default("#F7921D"),
  CadetBlue: import_color2.default("#74729A"),
  CarnationPink: import_color2.default("#F282B4"),
  Cerulean: import_color2.default("#00A2E3"),
  CornflowerBlue: import_color2.default("#41B0E4"),
  Cyan: import_color2.default("#00AEEF"),
  Dandelion: import_color2.default("#FDBC42"),
  DarkOrchid: import_color2.default("#A4538A"),
  Emerald: import_color2.default("#00A99D"),
  ForestGreen: import_color2.default("#009B55"),
  Fuchsia: import_color2.default("#8C368C"),
  Goldenrod: import_color2.default("#FFDF42"),
  Gray: import_color2.default("#949698"),
  Green: import_color2.default("#00A64F"),
  GreenYellow: import_color2.default("#DFE674"),
  JungleGreen: import_color2.default("#00A99A"),
  Lavender: import_color2.default("#F49EC4"),
  LimeGreen: import_color2.default("#8DC73E"),
  Magenta: import_color2.default("#EC008C"),
  Mahogany: import_color2.default("#A9341F"),
  Maroon: import_color2.default("#AF3235"),
  Melon: import_color2.default("#F89E7B"),
  MidnightBlue: import_color2.default("#006795"),
  Mulberry: import_color2.default("#A93C93"),
  NavyBlue: import_color2.default("#006EB8"),
  OliveGreen: import_color2.default("#3C8031"),
  Orange: import_color2.default("#F58137"),
  OrangeRed: import_color2.default("#ED135A"),
  Orchid: import_color2.default("#AF72B0"),
  Peach: import_color2.default("#F7965A"),
  Periwinkle: import_color2.default("#7977B8"),
  PineGreen: import_color2.default("#008B72"),
  Plum: import_color2.default("#92268F"),
  ProcessBlue: import_color2.default("#00B0F0"),
  Purple: import_color2.default("#99479B"),
  RawSienna: import_color2.default("#974006"),
  Red: import_color2.default("#ED1B23"),
  RedOrange: import_color2.default("#F26035"),
  RedViolet: import_color2.default("#A1246B"),
  Rhodamine: import_color2.default("#EF559F"),
  RoyalBlue: import_color2.default("#0071BC"),
  RoyalPurple: import_color2.default("#613F99"),
  RubineRed: import_color2.default("#ED017D"),
  Salmon: import_color2.default("#F69289"),
  SeaGreen: import_color2.default("#3FBC9D"),
  Sepia: import_color2.default("#671800"),
  SkyBlue: import_color2.default("#46C5DD"),
  SpringGreen: import_color2.default("#C6DC67"),
  Tan: import_color2.default("#DA9D76"),
  TealBlue: import_color2.default("#00AEB3"),
  Thistle: import_color2.default("#D883B7"),
  Turquoise: import_color2.default("#00B4CE"),
  Violet: import_color2.default("#58429B"),
  VioletRed: import_color2.default("#EF58A0"),
  White: import_color2.default("#FFFFFF"),
  WildStrawberry: import_color2.default("#EE2967"),
  Yellow: import_color2.default("#FFF200"),
  YellowGreen: import_color2.default("#98CC70"),
  YellowOrange: import_color2.default("#FAA21A")
};
var SVG_NAMES = {
  AliceBlue: fromRgb([0.94, 0.972, 1]),
  AntiqueWhite: fromRgb([0.98, 0.92, 0.844]),
  Aqua: fromRgb([0, 1, 1]),
  Aquamarine: fromRgb([0.498, 1, 0.83]),
  Azure: fromRgb([0.94, 1, 1]),
  Beige: fromRgb([0.96, 0.96, 0.864]),
  Bisque: fromRgb([1, 0.894, 0.77]),
  Black: fromRgb([0, 0, 0]),
  BlanchedAlmond: fromRgb([1, 0.92, 0.804]),
  Blue: fromRgb([0, 0, 1]),
  BlueViolet: fromRgb([0.54, 0.17, 0.888]),
  Brown: fromRgb([0.648, 0.165, 0.165]),
  BurlyWood: fromRgb([0.87, 0.72, 0.53]),
  CadetBlue: fromRgb([0.372, 0.62, 0.628]),
  Chartreuse: fromRgb([0.498, 1, 0]),
  Chocolate: fromRgb([0.824, 0.41, 0.116]),
  Coral: fromRgb([1, 0.498, 0.312]),
  CornflowerBlue: fromRgb([0.392, 0.585, 0.93]),
  Cornsilk: fromRgb([1, 0.972, 0.864]),
  Crimson: fromRgb([0.864, 0.08, 0.235]),
  Cyan: fromRgb([0, 1, 1]),
  DarkBlue: fromRgb([0, 0, 0.545]),
  DarkCyan: fromRgb([0, 0.545, 0.545]),
  DarkGoldenrod: fromRgb([0.72, 0.525, 0.044]),
  DarkGray: fromRgb([0.664, 0.664, 0.664]),
  DarkGreen: fromRgb([0, 0.392, 0]),
  DarkGrey: fromRgb([0.664, 0.664, 0.664]),
  DarkKhaki: fromRgb([0.74, 0.716, 0.42]),
  DarkMagenta: fromRgb([0.545, 0, 0.545]),
  DarkOliveGreen: fromRgb([0.332, 0.42, 0.185]),
  DarkOrange: fromRgb([1, 0.55, 0]),
  DarkOrchid: fromRgb([0.6, 0.196, 0.8]),
  DarkRed: fromRgb([0.545, 0, 0]),
  DarkSalmon: fromRgb([0.912, 0.59, 0.48]),
  DarkSeaGreen: fromRgb([0.56, 0.736, 0.56]),
  DarkSlateBlue: fromRgb([0.284, 0.24, 0.545]),
  DarkSlateGray: fromRgb([0.185, 0.31, 0.31]),
  DarkSlateGrey: fromRgb([0.185, 0.31, 0.31]),
  DarkTurquoise: fromRgb([0, 0.808, 0.82]),
  DarkViolet: fromRgb([0.58, 0, 0.828]),
  DeepPink: fromRgb([1, 0.08, 0.576]),
  DeepSkyBlue: fromRgb([0, 0.75, 1]),
  DimGray: fromRgb([0.41, 0.41, 0.41]),
  DimGrey: fromRgb([0.41, 0.41, 0.41]),
  DodgerBlue: fromRgb([0.116, 0.565, 1]),
  FireBrick: fromRgb([0.698, 0.132, 0.132]),
  FloralWhite: fromRgb([1, 0.98, 0.94]),
  ForestGreen: fromRgb([0.132, 0.545, 0.132]),
  Fuchsia: fromRgb([1, 0, 1]),
  Gainsboro: fromRgb([0.864, 0.864, 0.864]),
  GhostWhite: fromRgb([0.972, 0.972, 1]),
  Gold: fromRgb([1, 0.844, 0]),
  Goldenrod: fromRgb([0.855, 0.648, 0.125]),
  Gray: fromRgb([0.5, 0.5, 0.5]),
  Green: fromRgb([0, 0.5, 0]),
  GreenYellow: fromRgb([0.68, 1, 0.185]),
  Grey: fromRgb([0.5, 0.5, 0.5]),
  Honeydew: fromRgb([0.94, 1, 0.94]),
  HotPink: fromRgb([1, 0.41, 0.705]),
  IndianRed: fromRgb([0.804, 0.36, 0.36]),
  Indigo: fromRgb([0.294, 0, 0.51]),
  Ivory: fromRgb([1, 1, 0.94]),
  Khaki: fromRgb([0.94, 0.9, 0.55]),
  Lavender: fromRgb([0.9, 0.9, 0.98]),
  LavenderBlush: fromRgb([1, 0.94, 0.96]),
  LawnGreen: fromRgb([0.488, 0.99, 0]),
  LemonChiffon: fromRgb([1, 0.98, 0.804]),
  LightBlue: fromRgb([0.68, 0.848, 0.9]),
  LightCoral: fromRgb([0.94, 0.5, 0.5]),
  LightCyan: fromRgb([0.88, 1, 1]),
  LightGoldenrod: fromRgb([0.933, 0.867, 0.51]),
  LightGoldenrodYellow: fromRgb([0.98, 0.98, 0.824]),
  LightGray: fromRgb([0.828, 0.828, 0.828]),
  LightGreen: fromRgb([0.565, 0.932, 0.565]),
  LightGrey: fromRgb([0.828, 0.828, 0.828]),
  LightPink: fromRgb([1, 0.712, 0.756]),
  LightSalmon: fromRgb([1, 0.628, 0.48]),
  LightSeaGreen: fromRgb([0.125, 0.698, 0.668]),
  LightSkyBlue: fromRgb([0.53, 0.808, 0.98]),
  LightSlateBlue: fromRgb([0.518, 0.44, 1]),
  LightSlateGray: fromRgb([0.468, 0.532, 0.6]),
  LightSlateGrey: fromRgb([0.468, 0.532, 0.6]),
  LightSteelBlue: fromRgb([0.69, 0.77, 0.87]),
  LightYellow: fromRgb([1, 1, 0.88]),
  Lime: fromRgb([0, 1, 0]),
  LimeGreen: fromRgb([0.196, 0.804, 0.196]),
  Linen: fromRgb([0.98, 0.94, 0.9]),
  Magenta: fromRgb([1, 0, 1]),
  Maroon: fromRgb([0.5, 0, 0]),
  MediumAquamarine: fromRgb([0.4, 0.804, 0.668]),
  MediumBlue: fromRgb([0, 0, 0.804]),
  MediumOrchid: fromRgb([0.73, 0.332, 0.828]),
  MediumPurple: fromRgb([0.576, 0.44, 0.86]),
  MediumSeaGreen: fromRgb([0.235, 0.7, 0.444]),
  MediumSlateBlue: fromRgb([0.484, 0.408, 0.932]),
  MediumSpringGreen: fromRgb([0, 0.98, 0.604]),
  MediumTurquoise: fromRgb([0.284, 0.82, 0.8]),
  MediumVioletRed: fromRgb([0.78, 0.084, 0.52]),
  MidnightBlue: fromRgb([0.098, 0.098, 0.44]),
  MintCream: fromRgb([0.96, 1, 0.98]),
  MistyRose: fromRgb([1, 0.894, 0.884]),
  Moccasin: fromRgb([1, 0.894, 0.71]),
  NavajoWhite: fromRgb([1, 0.87, 0.68]),
  Navy: fromRgb([0, 0, 0.5]),
  NavyBlue: fromRgb([0, 0, 0.5]),
  OldLace: fromRgb([0.992, 0.96, 0.9]),
  Olive: fromRgb([0.5, 0.5, 0]),
  OliveDrab: fromRgb([0.42, 0.556, 0.136]),
  Orange: fromRgb([1, 0.648, 0]),
  OrangeRed: fromRgb([1, 0.27, 0]),
  Orchid: fromRgb([0.855, 0.44, 0.84]),
  PaleGoldenrod: fromRgb([0.932, 0.91, 0.668]),
  PaleGreen: fromRgb([0.596, 0.985, 0.596]),
  PaleTurquoise: fromRgb([0.688, 0.932, 0.932]),
  PaleVioletRed: fromRgb([0.86, 0.44, 0.576]),
  PapayaWhip: fromRgb([1, 0.936, 0.835]),
  PeachPuff: fromRgb([1, 0.855, 0.725]),
  Peru: fromRgb([0.804, 0.52, 0.248]),
  Pink: fromRgb([1, 0.752, 0.796]),
  Plum: fromRgb([0.868, 0.628, 0.868]),
  PowderBlue: fromRgb([0.69, 0.88, 0.9]),
  Purple: fromRgb([0.5, 0, 0.5]),
  Red: fromRgb([1, 0, 0]),
  RosyBrown: fromRgb([0.736, 0.56, 0.56]),
  RoyalBlue: fromRgb([0.255, 0.41, 0.884]),
  SaddleBrown: fromRgb([0.545, 0.27, 0.075]),
  Salmon: fromRgb([0.98, 0.5, 0.448]),
  SandyBrown: fromRgb([0.956, 0.644, 0.376]),
  SeaGreen: fromRgb([0.18, 0.545, 0.34]),
  Seashell: fromRgb([1, 0.96, 0.932]),
  Sienna: fromRgb([0.628, 0.32, 0.176]),
  Silver: fromRgb([0.752, 0.752, 0.752]),
  SkyBlue: fromRgb([0.53, 0.808, 0.92]),
  SlateBlue: fromRgb([0.415, 0.352, 0.804]),
  SlateGray: fromRgb([0.44, 0.5, 0.565]),
  SlateGrey: fromRgb([0.44, 0.5, 0.565]),
  Snow: fromRgb([1, 0.98, 0.98]),
  SpringGreen: fromRgb([0, 1, 0.498]),
  SteelBlue: fromRgb([0.275, 0.51, 0.705]),
  Tan: fromRgb([0.824, 0.705, 0.55]),
  Teal: fromRgb([0, 0.5, 0.5]),
  Thistle: fromRgb([0.848, 0.75, 0.848]),
  Tomato: fromRgb([1, 0.39, 0.28]),
  Turquoise: fromRgb([0.25, 0.88, 0.815]),
  Violet: fromRgb([0.932, 0.51, 0.932]),
  VioletRed: fromRgb([0.816, 0.125, 0.565]),
  Wheat: fromRgb([0.96, 0.87, 0.7]),
  White: fromRgb([1, 1, 1]),
  WhiteSmoke: fromRgb([0.96, 0.96, 0.96]),
  Yellow: fromRgb([1, 1, 0]),
  YellowGreen: fromRgb([0.604, 0.804, 0.196])
};
var X11_NAMES = {
  AntiqueWhite1: fromRgb([1, 0.936, 0.86]),
  AntiqueWhite2: fromRgb([0.932, 0.875, 0.8]),
  AntiqueWhite3: fromRgb([0.804, 0.752, 0.69]),
  AntiqueWhite4: fromRgb([0.545, 0.512, 0.47]),
  Aquamarine1: fromRgb([0.498, 1, 0.83]),
  Aquamarine2: fromRgb([0.464, 0.932, 0.776]),
  Aquamarine3: fromRgb([0.4, 0.804, 0.668]),
  Aquamarine4: fromRgb([0.27, 0.545, 0.455]),
  Azure1: fromRgb([0.94, 1, 1]),
  Azure2: fromRgb([0.88, 0.932, 0.932]),
  Azure3: fromRgb([0.756, 0.804, 0.804]),
  Azure4: fromRgb([0.512, 0.545, 0.545]),
  Bisque1: fromRgb([1, 0.894, 0.77]),
  Bisque2: fromRgb([0.932, 0.835, 0.716]),
  Bisque3: fromRgb([0.804, 0.716, 0.62]),
  Bisque4: fromRgb([0.545, 0.49, 0.42]),
  Blue1: fromRgb([0, 0, 1]),
  Blue2: fromRgb([0, 0, 0.932]),
  Blue3: fromRgb([0, 0, 0.804]),
  Blue4: fromRgb([0, 0, 0.545]),
  Brown1: fromRgb([1, 0.25, 0.25]),
  Brown2: fromRgb([0.932, 0.23, 0.23]),
  Brown3: fromRgb([0.804, 0.2, 0.2]),
  Brown4: fromRgb([0.545, 0.136, 0.136]),
  Burlywood1: fromRgb([1, 0.828, 0.608]),
  Burlywood2: fromRgb([0.932, 0.772, 0.57]),
  Burlywood3: fromRgb([0.804, 0.668, 0.49]),
  Burlywood4: fromRgb([0.545, 0.45, 0.332]),
  CadetBlue1: fromRgb([0.596, 0.96, 1]),
  CadetBlue2: fromRgb([0.556, 0.898, 0.932]),
  CadetBlue3: fromRgb([0.48, 0.772, 0.804]),
  CadetBlue4: fromRgb([0.325, 0.525, 0.545]),
  Chartreuse1: fromRgb([0.498, 1, 0]),
  Chartreuse2: fromRgb([0.464, 0.932, 0]),
  Chartreuse3: fromRgb([0.4, 0.804, 0]),
  Chartreuse4: fromRgb([0.27, 0.545, 0]),
  Chocolate1: fromRgb([1, 0.498, 0.14]),
  Chocolate2: fromRgb([0.932, 0.464, 0.13]),
  Chocolate3: fromRgb([0.804, 0.4, 0.112]),
  Chocolate4: fromRgb([0.545, 0.27, 0.075]),
  Coral1: fromRgb([1, 0.448, 0.336]),
  Coral2: fromRgb([0.932, 0.415, 0.312]),
  Coral3: fromRgb([0.804, 0.356, 0.27]),
  Coral4: fromRgb([0.545, 0.244, 0.185]),
  Cornsilk1: fromRgb([1, 0.972, 0.864]),
  Cornsilk2: fromRgb([0.932, 0.91, 0.804]),
  Cornsilk3: fromRgb([0.804, 0.785, 0.694]),
  Cornsilk4: fromRgb([0.545, 0.532, 0.47]),
  Cyan1: fromRgb([0, 1, 1]),
  Cyan2: fromRgb([0, 0.932, 0.932]),
  Cyan3: fromRgb([0, 0.804, 0.804]),
  Cyan4: fromRgb([0, 0.545, 0.545]),
  DarkGoldenrod1: fromRgb([1, 0.725, 0.06]),
  DarkGoldenrod2: fromRgb([0.932, 0.68, 0.055]),
  DarkGoldenrod3: fromRgb([0.804, 0.585, 0.048]),
  DarkGoldenrod4: fromRgb([0.545, 0.396, 0.03]),
  DarkOliveGreen1: fromRgb([0.792, 1, 0.44]),
  DarkOliveGreen2: fromRgb([0.736, 0.932, 0.408]),
  DarkOliveGreen3: fromRgb([0.635, 0.804, 0.352]),
  DarkOliveGreen4: fromRgb([0.43, 0.545, 0.24]),
  DarkOrange1: fromRgb([1, 0.498, 0]),
  DarkOrange2: fromRgb([0.932, 0.464, 0]),
  DarkOrange3: fromRgb([0.804, 0.4, 0]),
  DarkOrange4: fromRgb([0.545, 0.27, 0]),
  DarkOrchid1: fromRgb([0.75, 0.244, 1]),
  DarkOrchid2: fromRgb([0.698, 0.228, 0.932]),
  DarkOrchid3: fromRgb([0.604, 0.196, 0.804]),
  DarkOrchid4: fromRgb([0.408, 0.132, 0.545]),
  DarkSeaGreen1: fromRgb([0.756, 1, 0.756]),
  DarkSeaGreen2: fromRgb([0.705, 0.932, 0.705]),
  DarkSeaGreen3: fromRgb([0.608, 0.804, 0.608]),
  DarkSeaGreen4: fromRgb([0.41, 0.545, 0.41]),
  DarkSlateGray1: fromRgb([0.592, 1, 1]),
  DarkSlateGray2: fromRgb([0.552, 0.932, 0.932]),
  DarkSlateGray3: fromRgb([0.475, 0.804, 0.804]),
  DarkSlateGray4: fromRgb([0.32, 0.545, 0.545]),
  DeepPink1: fromRgb([1, 0.08, 0.576]),
  DeepPink2: fromRgb([0.932, 0.07, 0.536]),
  DeepPink3: fromRgb([0.804, 0.064, 0.464]),
  DeepPink4: fromRgb([0.545, 0.04, 0.312]),
  DeepSkyBlue1: fromRgb([0, 0.75, 1]),
  DeepSkyBlue2: fromRgb([0, 0.698, 0.932]),
  DeepSkyBlue3: fromRgb([0, 0.604, 0.804]),
  DeepSkyBlue4: fromRgb([0, 0.408, 0.545]),
  DodgerBlue1: fromRgb([0.116, 0.565, 1]),
  DodgerBlue2: fromRgb([0.11, 0.525, 0.932]),
  DodgerBlue3: fromRgb([0.094, 0.455, 0.804]),
  DodgerBlue4: fromRgb([0.064, 0.305, 0.545]),
  Firebrick1: fromRgb([1, 0.19, 0.19]),
  Firebrick2: fromRgb([0.932, 0.172, 0.172]),
  Firebrick3: fromRgb([0.804, 0.15, 0.15]),
  Firebrick4: fromRgb([0.545, 0.1, 0.1]),
  Gold1: fromRgb([1, 0.844, 0]),
  Gold2: fromRgb([0.932, 0.79, 0]),
  Gold3: fromRgb([0.804, 0.68, 0]),
  Gold4: fromRgb([0.545, 0.46, 0]),
  Goldenrod1: fromRgb([1, 0.756, 0.145]),
  Goldenrod2: fromRgb([0.932, 0.705, 0.132]),
  Goldenrod3: fromRgb([0.804, 0.608, 0.112]),
  Goldenrod4: fromRgb([0.545, 0.41, 0.08]),
  Green1: fromRgb([0, 1, 0]),
  Green2: fromRgb([0, 0.932, 0]),
  Green3: fromRgb([0, 0.804, 0]),
  Green4: fromRgb([0, 0.545, 0]),
  Honeydew1: fromRgb([0.94, 1, 0.94]),
  Honeydew2: fromRgb([0.88, 0.932, 0.88]),
  Honeydew3: fromRgb([0.756, 0.804, 0.756]),
  Honeydew4: fromRgb([0.512, 0.545, 0.512]),
  HotPink1: fromRgb([1, 0.43, 0.705]),
  HotPink2: fromRgb([0.932, 0.415, 0.655]),
  HotPink3: fromRgb([0.804, 0.376, 0.565]),
  HotPink4: fromRgb([0.545, 0.228, 0.385]),
  IndianRed1: fromRgb([1, 0.415, 0.415]),
  IndianRed2: fromRgb([0.932, 0.39, 0.39]),
  IndianRed3: fromRgb([0.804, 0.332, 0.332]),
  IndianRed4: fromRgb([0.545, 0.228, 0.228]),
  Ivory1: fromRgb([1, 1, 0.94]),
  Ivory2: fromRgb([0.932, 0.932, 0.88]),
  Ivory3: fromRgb([0.804, 0.804, 0.756]),
  Ivory4: fromRgb([0.545, 0.545, 0.512]),
  Khaki1: fromRgb([1, 0.965, 0.56]),
  Khaki2: fromRgb([0.932, 0.9, 0.52]),
  Khaki3: fromRgb([0.804, 0.776, 0.45]),
  Khaki4: fromRgb([0.545, 0.525, 0.305]),
  LavenderBlush1: fromRgb([1, 0.94, 0.96]),
  LavenderBlush2: fromRgb([0.932, 0.88, 0.898]),
  LavenderBlush3: fromRgb([0.804, 0.756, 0.772]),
  LavenderBlush4: fromRgb([0.545, 0.512, 0.525]),
  LemonChiffon1: fromRgb([1, 0.98, 0.804]),
  LemonChiffon2: fromRgb([0.932, 0.912, 0.75]),
  LemonChiffon3: fromRgb([0.804, 0.79, 0.648]),
  LemonChiffon4: fromRgb([0.545, 0.536, 0.44]),
  LightBlue1: fromRgb([0.75, 0.936, 1]),
  LightBlue2: fromRgb([0.698, 0.875, 0.932]),
  LightBlue3: fromRgb([0.604, 0.752, 0.804]),
  LightBlue4: fromRgb([0.408, 0.512, 0.545]),
  LightCyan1: fromRgb([0.88, 1, 1]),
  LightCyan2: fromRgb([0.82, 0.932, 0.932]),
  LightCyan3: fromRgb([0.705, 0.804, 0.804]),
  LightCyan4: fromRgb([0.48, 0.545, 0.545]),
  LightGoldenrod1: fromRgb([1, 0.925, 0.545]),
  LightGoldenrod2: fromRgb([0.932, 0.864, 0.51]),
  LightGoldenrod3: fromRgb([0.804, 0.745, 0.44]),
  LightGoldenrod4: fromRgb([0.545, 0.505, 0.298]),
  LightPink1: fromRgb([1, 0.684, 0.725]),
  LightPink2: fromRgb([0.932, 0.635, 0.68]),
  LightPink3: fromRgb([0.804, 0.55, 0.585]),
  LightPink4: fromRgb([0.545, 0.372, 0.396]),
  LightSalmon1: fromRgb([1, 0.628, 0.48]),
  LightSalmon2: fromRgb([0.932, 0.585, 0.448]),
  LightSalmon3: fromRgb([0.804, 0.505, 0.385]),
  LightSalmon4: fromRgb([0.545, 0.34, 0.26]),
  LightSkyBlue1: fromRgb([0.69, 0.888, 1]),
  LightSkyBlue2: fromRgb([0.644, 0.828, 0.932]),
  LightSkyBlue3: fromRgb([0.552, 0.712, 0.804]),
  LightSkyBlue4: fromRgb([0.376, 0.484, 0.545]),
  LightSteelBlue1: fromRgb([0.792, 0.884, 1]),
  LightSteelBlue2: fromRgb([0.736, 0.824, 0.932]),
  LightSteelBlue3: fromRgb([0.635, 0.71, 0.804]),
  LightSteelBlue4: fromRgb([0.43, 0.484, 0.545]),
  LightYellow1: fromRgb([1, 1, 0.88]),
  LightYellow2: fromRgb([0.932, 0.932, 0.82]),
  LightYellow3: fromRgb([0.804, 0.804, 0.705]),
  LightYellow4: fromRgb([0.545, 0.545, 0.48]),
  Magenta1: fromRgb([1, 0, 1]),
  Magenta2: fromRgb([0.932, 0, 0.932]),
  Magenta3: fromRgb([0.804, 0, 0.804]),
  Magenta4: fromRgb([0.545, 0, 0.545]),
  Maroon1: fromRgb([1, 0.204, 0.7]),
  Maroon2: fromRgb([0.932, 0.19, 0.655]),
  Maroon3: fromRgb([0.804, 0.16, 0.565]),
  Maroon4: fromRgb([0.545, 0.11, 0.385]),
  MediumOrchid1: fromRgb([0.88, 0.4, 1]),
  MediumOrchid2: fromRgb([0.82, 0.372, 0.932]),
  MediumOrchid3: fromRgb([0.705, 0.32, 0.804]),
  MediumOrchid4: fromRgb([0.48, 0.215, 0.545]),
  MediumPurple1: fromRgb([0.67, 0.51, 1]),
  MediumPurple2: fromRgb([0.624, 0.475, 0.932]),
  MediumPurple3: fromRgb([0.536, 0.408, 0.804]),
  MediumPurple4: fromRgb([0.365, 0.28, 0.545]),
  MistyRose1: fromRgb([1, 0.894, 0.884]),
  MistyRose2: fromRgb([0.932, 0.835, 0.824]),
  MistyRose3: fromRgb([0.804, 0.716, 0.71]),
  MistyRose4: fromRgb([0.545, 0.49, 0.484]),
  NavajoWhite1: fromRgb([1, 0.87, 0.68]),
  NavajoWhite2: fromRgb([0.932, 0.81, 0.63]),
  NavajoWhite3: fromRgb([0.804, 0.7, 0.545]),
  NavajoWhite4: fromRgb([0.545, 0.475, 0.37]),
  OliveDrab1: fromRgb([0.752, 1, 0.244]),
  OliveDrab2: fromRgb([0.7, 0.932, 0.228]),
  OliveDrab3: fromRgb([0.604, 0.804, 0.196]),
  OliveDrab4: fromRgb([0.41, 0.545, 0.132]),
  Orange1: fromRgb([1, 0.648, 0]),
  Orange2: fromRgb([0.932, 0.604, 0]),
  Orange3: fromRgb([0.804, 0.52, 0]),
  Orange4: fromRgb([0.545, 0.352, 0]),
  OrangeRed1: fromRgb([1, 0.27, 0]),
  OrangeRed2: fromRgb([0.932, 0.25, 0]),
  OrangeRed3: fromRgb([0.804, 0.215, 0]),
  OrangeRed4: fromRgb([0.545, 0.145, 0]),
  Orchid1: fromRgb([1, 0.512, 0.98]),
  Orchid2: fromRgb([0.932, 0.48, 0.912]),
  Orchid3: fromRgb([0.804, 0.41, 0.79]),
  Orchid4: fromRgb([0.545, 0.28, 0.536]),
  PaleGreen1: fromRgb([0.604, 1, 0.604]),
  PaleGreen2: fromRgb([0.565, 0.932, 0.565]),
  PaleGreen3: fromRgb([0.488, 0.804, 0.488]),
  PaleGreen4: fromRgb([0.33, 0.545, 0.33]),
  PaleTurquoise1: fromRgb([0.732, 1, 1]),
  PaleTurquoise2: fromRgb([0.684, 0.932, 0.932]),
  PaleTurquoise3: fromRgb([0.59, 0.804, 0.804]),
  PaleTurquoise4: fromRgb([0.4, 0.545, 0.545]),
  PaleVioletRed1: fromRgb([1, 0.51, 0.67]),
  PaleVioletRed2: fromRgb([0.932, 0.475, 0.624]),
  PaleVioletRed3: fromRgb([0.804, 0.408, 0.536]),
  PaleVioletRed4: fromRgb([0.545, 0.28, 0.365]),
  PeachPuff1: fromRgb([1, 0.855, 0.725]),
  PeachPuff2: fromRgb([0.932, 0.796, 0.68]),
  PeachPuff3: fromRgb([0.804, 0.688, 0.585]),
  PeachPuff4: fromRgb([0.545, 0.468, 0.396]),
  Pink1: fromRgb([1, 0.71, 0.772]),
  Pink2: fromRgb([0.932, 0.664, 0.72]),
  Pink3: fromRgb([0.804, 0.57, 0.62]),
  Pink4: fromRgb([0.545, 0.39, 0.424]),
  Plum1: fromRgb([1, 0.732, 1]),
  Plum2: fromRgb([0.932, 0.684, 0.932]),
  Plum3: fromRgb([0.804, 0.59, 0.804]),
  Plum4: fromRgb([0.545, 0.4, 0.545]),
  Purple1: fromRgb([0.608, 0.19, 1]),
  Purple2: fromRgb([0.57, 0.172, 0.932]),
  Purple3: fromRgb([0.49, 0.15, 0.804]),
  Purple4: fromRgb([0.332, 0.1, 0.545]),
  Red1: fromRgb([1, 0, 0]),
  Red2: fromRgb([0.932, 0, 0]),
  Red3: fromRgb([0.804, 0, 0]),
  Red4: fromRgb([0.545, 0, 0]),
  RosyBrown1: fromRgb([1, 0.756, 0.756]),
  RosyBrown2: fromRgb([0.932, 0.705, 0.705]),
  RosyBrown3: fromRgb([0.804, 0.608, 0.608]),
  RosyBrown4: fromRgb([0.545, 0.41, 0.41]),
  RoyalBlue1: fromRgb([0.284, 0.464, 1]),
  RoyalBlue2: fromRgb([0.264, 0.43, 0.932]),
  RoyalBlue3: fromRgb([0.228, 0.372, 0.804]),
  RoyalBlue4: fromRgb([0.152, 0.25, 0.545]),
  Salmon1: fromRgb([1, 0.55, 0.41]),
  Salmon2: fromRgb([0.932, 0.51, 0.385]),
  Salmon3: fromRgb([0.804, 0.44, 0.33]),
  Salmon4: fromRgb([0.545, 0.298, 0.224]),
  SeaGreen1: fromRgb([0.33, 1, 0.624]),
  SeaGreen2: fromRgb([0.305, 0.932, 0.58]),
  SeaGreen3: fromRgb([0.264, 0.804, 0.5]),
  SeaGreen4: fromRgb([0.18, 0.545, 0.34]),
  Seashell1: fromRgb([1, 0.96, 0.932]),
  Seashell2: fromRgb([0.932, 0.898, 0.87]),
  Seashell3: fromRgb([0.804, 0.772, 0.75]),
  Seashell4: fromRgb([0.545, 0.525, 0.51]),
  Sienna1: fromRgb([1, 0.51, 0.28]),
  Sienna2: fromRgb([0.932, 0.475, 0.26]),
  Sienna3: fromRgb([0.804, 0.408, 0.224]),
  Sienna4: fromRgb([0.545, 0.28, 0.15]),
  SkyBlue1: fromRgb([0.53, 0.808, 1]),
  SkyBlue2: fromRgb([0.494, 0.752, 0.932]),
  SkyBlue3: fromRgb([0.424, 0.65, 0.804]),
  SkyBlue4: fromRgb([0.29, 0.44, 0.545]),
  SlateBlue1: fromRgb([0.512, 0.435, 1]),
  SlateBlue2: fromRgb([0.48, 0.404, 0.932]),
  SlateBlue3: fromRgb([0.41, 0.35, 0.804]),
  SlateBlue4: fromRgb([0.28, 0.235, 0.545]),
  SlateGray1: fromRgb([0.776, 0.888, 1]),
  SlateGray2: fromRgb([0.725, 0.828, 0.932]),
  SlateGray3: fromRgb([0.624, 0.712, 0.804]),
  SlateGray4: fromRgb([0.424, 0.484, 0.545]),
  Snow1: fromRgb([1, 0.98, 0.98]),
  Snow2: fromRgb([0.932, 0.912, 0.912]),
  Snow3: fromRgb([0.804, 0.79, 0.79]),
  Snow4: fromRgb([0.545, 0.536, 0.536]),
  SpringGreen1: fromRgb([0, 1, 0.498]),
  SpringGreen2: fromRgb([0, 0.932, 0.464]),
  SpringGreen3: fromRgb([0, 0.804, 0.4]),
  SpringGreen4: fromRgb([0, 0.545, 0.27]),
  SteelBlue1: fromRgb([0.39, 0.72, 1]),
  SteelBlue2: fromRgb([0.36, 0.675, 0.932]),
  SteelBlue3: fromRgb([0.31, 0.58, 0.804]),
  SteelBlue4: fromRgb([0.21, 0.392, 0.545]),
  Tan1: fromRgb([1, 0.648, 0.31]),
  Tan2: fromRgb([0.932, 0.604, 0.288]),
  Tan3: fromRgb([0.804, 0.52, 0.248]),
  Tan4: fromRgb([0.545, 0.352, 0.17]),
  Thistle1: fromRgb([1, 0.884, 1]),
  Thistle2: fromRgb([0.932, 0.824, 0.932]),
  Thistle3: fromRgb([0.804, 0.71, 0.804]),
  Thistle4: fromRgb([0.545, 0.484, 0.545]),
  Tomato1: fromRgb([1, 0.39, 0.28]),
  Tomato2: fromRgb([0.932, 0.36, 0.26]),
  Tomato3: fromRgb([0.804, 0.31, 0.224]),
  Tomato4: fromRgb([0.545, 0.21, 0.15]),
  Turquoise1: fromRgb([0, 0.96, 1]),
  Turquoise2: fromRgb([0, 0.898, 0.932]),
  Turquoise3: fromRgb([0, 0.772, 0.804]),
  Turquoise4: fromRgb([0, 0.525, 0.545]),
  VioletRed1: fromRgb([1, 0.244, 0.59]),
  VioletRed2: fromRgb([0.932, 0.228, 0.55]),
  VioletRed3: fromRgb([0.804, 0.196, 0.47]),
  VioletRed4: fromRgb([0.545, 0.132, 0.32]),
  Wheat1: fromRgb([1, 0.905, 0.73]),
  Wheat2: fromRgb([0.932, 0.848, 0.684]),
  Wheat3: fromRgb([0.804, 0.73, 0.59]),
  Wheat4: fromRgb([0.545, 0.494, 0.4]),
  Yellow1: fromRgb([1, 1, 0]),
  Yellow2: fromRgb([0.932, 0.932, 0]),
  Yellow3: fromRgb([0.804, 0.804, 0]),
  Yellow4: fromRgb([0.545, 0.545, 0]),
  Gray0: fromRgb([0.745, 0.745, 0.745]),
  Green0: fromRgb([0, 1, 0]),
  Grey0: fromRgb([0.745, 0.745, 0.745]),
  Maroon0: fromRgb([0.69, 0.19, 0.376]),
  Purple0: fromRgb([0.628, 0.125, 0.94])
};
var XColorCoreModelToColor = {
  rgb: ([r, g, b]) => import_color2.default([r * 255, g * 255, b * 255], "rgb"),
  cmy: ([c, m, y]) => XColorCoreModelToColor.rgb([1 - c, 1 - m, 1 - y]),
  cmyk: ([c, m, y, k]) => import_color2.default([c * 255, m * 255, y * 255, k * 100], "cmyk"),
  hsb: ([h, s2, b]) => import_color2.default([h * 360, s2 * 100, b * 100], "hsv"),
  gray: ([v]) => import_color2.default([v * 255, v * 255, v * 255], "rgb")
};
var XColorModelToColor = {
  wave: ([lambda]) => {
    const gamma = 0.8;
    let baseRgb = [0, 0, 0];
    if (380 <= lambda && lambda < 440) {
      baseRgb = [(440 - lambda) / (440 - 380), 0, 1];
    }
    if (440 <= lambda && lambda < 490) {
      baseRgb = [0, (lambda - 440) / (490 - 440), 1];
    }
    if (490 <= lambda && lambda < 510) {
      baseRgb = [0, 1, (510 - lambda) / (510 - 490)];
    }
    if (510 <= lambda && lambda < 580) {
      baseRgb = [(lambda - 510) / (580 - 510), 1, 0];
    }
    if (580 <= lambda && lambda < 6450) {
      baseRgb = [1, (645 - lambda) / (645 - 580), 0];
    }
    if (645 <= lambda && lambda <= 780) {
      baseRgb = [1, 0, 0];
    }
    let f = 1;
    if (380 <= lambda && 420 < lambda) {
      f = 0.3 + 0.7 * (lambda - 380) / (420 - 380);
    }
    if (700 < lambda && lambda <= 780) {
      f = 0.3 + 0.7 * (780 - lambda) / (780 - 700);
    }
    const rgb = [
      Math.pow(baseRgb[0] * f, gamma),
      Math.pow(baseRgb[1] * f, gamma),
      Math.pow(baseRgb[2] * f, gamma)
    ];
    return import_color2.default([rgb[0] * 255, rgb[1] * 255, rgb[2] * 255], "rgb");
  },
  Hsb: ([h, s2, b]) => XColorCoreModelToColor.hsb([h / 360, s2, b]),
  HSB: ([h, s2, b]) => XColorCoreModelToColor.hsb([h / 240, s2 / 240, b / 240]),
  HTML: ([v]) => v.startsWith("#") ? import_color2.default(v) : import_color2.default(`#${v}`),
  RGB: ([r, g, b]) => import_color2.default([r, g, b], "rgb"),
  Gray: ([v]) => XColorCoreModelToColor.gray([v / 15]),
  ...XColorCoreModelToColor
};
var PREDEFINED_XCOLOR_COLORS = {
  red: XColorCoreModelToColor.rgb([1, 0, 0]),
  green: XColorCoreModelToColor.rgb([0, 1, 0]),
  blue: XColorCoreModelToColor.rgb([0, 0, 1]),
  brown: XColorCoreModelToColor.rgb([0.75, 0.5, 0.25]),
  lime: XColorCoreModelToColor.rgb([0.75, 1, 0]),
  orange: XColorCoreModelToColor.rgb([1, 0.5, 0]),
  pink: XColorCoreModelToColor.rgb([1, 0.75, 0.75]),
  purple: XColorCoreModelToColor.rgb([0.75, 0, 0.25]),
  teal: XColorCoreModelToColor.rgb([0, 0.5, 0.5]),
  violet: XColorCoreModelToColor.rgb([0.5, 0, 0.5]),
  cyan: XColorCoreModelToColor.rgb([0, 1, 1]),
  magenta: XColorCoreModelToColor.rgb([1, 0, 1]),
  yellow: XColorCoreModelToColor.rgb([1, 1, 0]),
  olive: XColorCoreModelToColor.rgb([0.5, 0.5, 0]),
  black: XColorCoreModelToColor.rgb([0, 0, 0]),
  darkgray: XColorCoreModelToColor.rgb([0.25, 0.25, 0.25]),
  gray: XColorCoreModelToColor.rgb([0.5, 0.5, 0.5]),
  lightgray: XColorCoreModelToColor.rgb([0.75, 0.75, 0.75]),
  white: XColorCoreModelToColor.rgb([1, 1, 1]),
  ...DVI_PS_NAMES,
  ...SVG_NAMES,
  ...X11_NAMES
};

// node_modules/@unified-latex/unified-latex-ctan/package/xparse/index.js
var macros15 = {
  NewDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  RenewDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  ProvideDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  DeclareDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  NewDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  RenewDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  ProvideDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  DeclareDocumentEnvironment: {
    signature: "m m m m",
    renderInfo: { breakAround: true }
  },
  NewExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  RenewExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  ProvideExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  DeclareExpandableDocumentCommand: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  RequirePackage: {
    signature: "o m",
    renderInfo: { pgfkeysArgs: true, breakAround: true }
  },
  DeclareOption: { signature: "m m", renderInfo: { breakAround: true } }
};
var environments15 = {};

// node_modules/@unified-latex/unified-latex-ctan/package/beamer/index.js
var macros16 = {
  mode: { signature: "s d<> d{}", renderInfo: { breakAround: true } },
  insertnavigation: { signature: "m", renderInfo: { breakAround: true } },
  insertsectionnavigation: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  insertsectionnavigationhorizontal: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  insertauthor: { signature: "o", renderInfo: { breakAround: true } },
  insertshortauthor: { signature: "o", renderInfo: { breakAround: true } },
  insertshortdate: { signature: "o", renderInfo: { breakAround: true } },
  insertshortinstitute: { signature: "o", renderInfo: { breakAround: true } },
  insertshortpart: { signature: "o", renderInfo: { breakAround: true } },
  insertshorttitle: { signature: "o", renderInfo: { breakAround: true } },
  insertsubsectionnavigation: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  insertsubsectionnavigationhorizontal: {
    signature: "m m m",
    renderInfo: { breakAround: true }
  },
  insertverticalnavigation: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  usebeamercolor: { signature: "s m", renderInfo: { breakAround: true } },
  usebeamertemplate: { signature: "s m", renderInfo: { breakAround: true } },
  setbeamercolor: {
    signature: "m m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  setbeamersize: {
    signature: "m o o",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  setbeamertemplate: {
    signature: "m o o d{}",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  newcommand: {
    signature: "s d<> +m o +o +m",
    renderInfo: {
      breakAround: true,
      namedArguments: [
        "starred",
        null,
        "name",
        "numArgs",
        "default",
        "body"
      ]
    }
  },
  renewcommand: {
    signature: "s d<> +m o +o +m",
    renderInfo: {
      breakAround: true,
      namedArguments: [
        "starred",
        null,
        "name",
        "numArgs",
        "default",
        "body"
      ]
    }
  },
  newenvironment: {
    signature: "s d<> m o o m m",
    renderInfo: { breakAround: true }
  },
  renewenvironment: {
    signature: "s d<> m o o m m",
    renderInfo: { breakAround: true }
  },
  resetcounteronoverlays: {
    signature: "m",
    renderInfo: { breakAround: true }
  },
  resetcountonoverlays: { signature: "m", renderInfo: { breakAround: true } },
  logo: { signature: "m", renderInfo: { breakAround: true } },
  frametitle: { signature: "d<> o m", renderInfo: { breakAround: true } },
  framesubtitle: { signature: "d<> m", renderInfo: { breakAround: true } },
  pause: { signature: "o" },
  onslide: { signature: "t+ t* d<> d{}" },
  only: { signature: "d<> m d<>" },
  uncover: { signature: "d<> m" },
  visible: { signature: "d<> m" },
  invisible: { signature: "d<> m" },
  alt: { signature: "d<> m m d<>" },
  temporal: { signature: "r<> m m m" },
  item: {
    signature: "d<> o d<>",
    renderInfo: {
      hangingIndent: true,
      namedArguments: [null, "label", null]
    }
  },
  label: { signature: "d<> o m" },
  action: { signature: "d<> m" },
  beamerdefaultoverlayspecification: { signature: "m" },
  titlegraphic: { signature: "m", renderInfo: { breakAround: true } },
  subject: { signature: "m", renderInfo: { breakAround: true } },
  keywords: { signature: "m", renderInfo: { breakAround: true } },
  lecture: { signature: "o m m", renderInfo: { breakAround: true } },
  partpage: { renderInfo: { breakAround: true } },
  sectionpage: { renderInfo: { breakAround: true } },
  subsectionpage: { renderInfo: { breakAround: true } },
  AtBeginLecture: { signature: "m", renderInfo: { breakAround: true } },
  AtBeginPart: { signature: "m", renderInfo: { breakAround: true } },
  tableofcontents: {
    signature: "o",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  againframe: { signature: "d<> o o m", renderInfo: { breakAround: true } },
  framezoom: {
    signature: "r<> r<> o r() r()",
    renderInfo: { breakAround: true }
  },
  column: { signature: "d<> o m", renderInfo: { breakAround: true } },
  animate: { signature: "r<>", renderInfo: { breakAround: true } },
  animatevalue: { signature: "r<> m m m", renderInfo: { breakAround: true } },
  sound: {
    signature: "o m m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  hyperlinksound: {
    signature: "o m m",
    renderInfo: { breakAround: true, pgfkeysArgs: true }
  },
  hyperlinkmute: { signature: "m", renderInfo: { breakAround: true } },
  section: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  subsection: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  subsubsection: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  part: {
    signature: "s d<> o m",
    renderInfo: {
      breakAround: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  },
  bibitem: {
    signature: "s d<> o m",
    renderInfo: {
      hangingIndent: true,
      namedArguments: ["starred", null, "tocTitle", "title"]
    }
  }
};
var environments16 = {
  frame: {
    signature: "!d<> !o !o !d{} !d{}"
  },
  block: {
    signature: "!d<> !d{} !d<>"
  },
  alertblock: {
    signature: "!d<> !d{} !d<>"
  },
  exampleblock: {
    signature: "!d<> !d{} !d<>"
  },
  onlyenv: {
    signature: "!d<>"
  },
  altenv: {
    signature: "!d<> m m m m !d<>"
  },
  overlayarea: { signature: "m m" },
  overprint: { signature: "o" },
  actionenv: { signature: "!d<>" },
  columns: { signature: "d<> o" },
  column: { signature: "d<> o m" }
};

// node_modules/@unified-latex/unified-latex-ctan/package/multicol/index.js
var macros17 = {
  columnbreak: { renderInfo: { breakAround: true } }
};
var environments17 = {
  multicols: {
    signature: "m o o"
  },
  "multicols*": {
    signature: "m o o"
  }
};

// node_modules/@unified-latex/unified-latex-ctan/index.js
var macroInfo = {
  amsart: macros,
  cleveref: macros2,
  exam: macros3,
  geometry: macros4,
  hyperref: macros5,
  latex2e: macros6,
  listings: macros7,
  makeidx: macros8,
  mathtools: macros9,
  minted: macros10,
  nicematrix: macros11,
  systeme: macros12,
  tikz: macros13,
  xcolor: macros14,
  xparse: macros15,
  beamer: macros16,
  multicol: macros17
};
var environmentInfo = {
  amsart: environments,
  cleveref: environments2,
  exam: environments3,
  geometry: environments4,
  hyperref: environments5,
  latex2e: environments6,
  listings: environments7,
  makeidx: environments8,
  mathtools: environments9,
  minted: environments10,
  nicematrix: environments11,
  systeme: environments12,
  tikz: environments13,
  xcolor: environments14,
  xparse: environments15,
  beamer: environments16,
  multicol: environments17
};

// node_modules/@unified-latex/unified-latex-util-environments/index.js
function processEnvironment(envNode, envInfo) {
  if (envInfo.signature && envNode.args == null) {
    const { args } = gobbleArguments(envNode.content, envInfo.signature);
    envNode.args = args;
  }
  updateRenderInfo(envNode, envInfo.renderInfo);
  if (typeof envInfo.processContent === "function") {
    envNode.content = envInfo.processContent(envNode.content);
  }
}

// node_modules/@unified-latex/unified-latex-util-catcode/index.js
function findRegionInArray(tree, start, end) {
  const ret = [];
  let currRegion = { start: undefined, end: tree.length };
  for (let i = 0;i < tree.length; i++) {
    const node2 = tree[i];
    if (start(node2)) {
      currRegion.start = i;
    }
    if (end(node2)) {
      currRegion.end = i + 1;
      ret.push(currRegion);
      currRegion = { start: undefined, end: tree.length };
    }
  }
  if (currRegion.start != null) {
    ret.push(currRegion);
  }
  return ret;
}
function refineRegions(regions) {
  const _regions = [...regions];
  _regions.sort((a, b) => a.start - b.start);
  const cutPointsSet = new Set(_regions.flatMap((r) => [r.start, r.end]));
  const cutPoints = Array.from(cutPointsSet);
  cutPoints.sort((a, b) => a - b);
  const retRegions = [];
  const retRegionsContainedIn = [];
  let seekIndex = 0;
  for (let i = 0;i < cutPoints.length - 1; i++) {
    const start = cutPoints[i];
    const end = cutPoints[i + 1];
    const region = { start, end };
    const regionContainedIn = /* @__PURE__ */ new Set;
    let encounteredEndPastStart = false;
    for (let j = seekIndex;j < _regions.length; j++) {
      const superRegion = _regions[j];
      if (superRegion.end >= region.start) {
        encounteredEndPastStart = true;
      }
      if (!encounteredEndPastStart && superRegion.end < region.start) {
        seekIndex = j + 1;
        continue;
      }
      if (superRegion.start > end) {
        break;
      }
      if (superRegion.start <= region.start && superRegion.end >= region.end) {
        encounteredEndPastStart = true;
        regionContainedIn.add(superRegion);
      }
    }
    if (regionContainedIn.size > 0) {
      retRegions.push(region);
      retRegionsContainedIn.push(regionContainedIn);
    }
  }
  return { regions: retRegions, regionsContainedIn: retRegionsContainedIn };
}
function splitByRegions(array, regionsRecord) {
  const ret = [];
  const indices = [0, array.length];
  const reverseMap = {};
  for (const [key, records] of Object.entries(regionsRecord)) {
    indices.push(...records.flatMap((r) => {
      reverseMap["" + [r.start, r.end]] = key;
      return [r.start, r.end];
    }));
  }
  indices.sort((a, b) => a - b);
  for (let i = 0;i < indices.length - 1; i++) {
    const start = indices[i];
    const end = indices[i + 1];
    if (start === end) {
      continue;
    }
    const regionKey = reverseMap["" + [start, end]];
    ret.push([regionKey || null, array.slice(start, end)]);
  }
  return ret;
}
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function buildWordRegex(allowedSet) {
  const regexpStr = `^(${["\\p{L}"].concat(Array.from(allowedSet).map(escapeRegExp)).join("|")})*`;
  return new RegExp(regexpStr, "u");
}
function hasReparsableMacroNamesInArray(tree, allowedTokens) {
  for (let i = 0;i < tree.length; i++) {
    const macro = tree[i];
    const string3 = tree[i + 1];
    if (match.anyMacro(macro) && match.anyString(string3)) {
      if (allowedTokens.has(macro.content.charAt(macro.content.length - 1)) || allowedTokens.has(string3.content.charAt(0))) {
        return true;
      }
    }
  }
  return false;
}
function hasReparsableMacroNames(tree, allowedTokens) {
  if (typeof allowedTokens === "string") {
    allowedTokens = new Set(allowedTokens.split(""));
  }
  const _allowedTokens = allowedTokens;
  for (const v of _allowedTokens) {
    if (v.length > 1) {
      throw new Error(`Only single characters are allowed as \`allowedTokens\` when reparsing macro names, not \`${v}\`.`);
    }
  }
  let ret = false;
  visit3(tree, (nodes) => {
    if (hasReparsableMacroNamesInArray(nodes, _allowedTokens)) {
      ret = true;
      return EXIT4;
    }
  }, { includeArrays: true, test: Array.isArray });
  return ret;
}
function reparseMacroNamesInArray(tree, allowedTokens) {
  var _a, _b, _c;
  const regex = buildWordRegex(allowedTokens);
  let i = 0;
  while (i < tree.length) {
    const macro = tree[i];
    const string3 = tree[i + 1];
    if (match.anyMacro(macro) && (macro.escapeToken == null || macro.escapeToken === "\\") && match.anyString(string3) && (allowedTokens.has(macro.content.charAt(macro.content.length - 1)) || allowedTokens.has(string3.content.charAt(0)))) {
      const match2 = string3.content.match(regex);
      const takeable = match2 ? match2[0] : "";
      if (takeable.length > 0) {
        if (takeable.length === string3.content.length) {
          macro.content += string3.content;
          tree.splice(i + 1, 1);
          if (macro.position && ((_a = string3.position) == null ? undefined : _a.end)) {
            macro.position.end = string3.position.end;
          }
        } else {
          macro.content += takeable;
          string3.content = string3.content.slice(takeable.length);
          if ((_b = macro.position) == null ? undefined : _b.end) {
            macro.position.end.offset += takeable.length;
            macro.position.end.column += takeable.length;
          }
          if ((_c = string3.position) == null ? undefined : _c.start) {
            string3.position.start.offset += takeable.length;
            string3.position.start.column += takeable.length;
          }
        }
      } else {
        i++;
      }
    } else {
      ++i;
    }
  }
}
function reparseMacroNames(tree, allowedTokens) {
  if (typeof allowedTokens === "string") {
    allowedTokens = new Set(allowedTokens.split(""));
  }
  const _allowedTokens = allowedTokens;
  for (const v of _allowedTokens) {
    if (v.length > 1) {
      throw new Error(`Only single characters are allowed as \`allowedTokens\` when reparsing macro names, not \`${v}\`.`);
    }
  }
  visit3(tree, (nodes) => {
    reparseMacroNamesInArray(nodes, _allowedTokens);
  }, { includeArrays: true, test: Array.isArray });
}
var expl3Find = {
  start: match.createMacroMatcher(["ExplSyntaxOn"]),
  end: match.createMacroMatcher(["ExplSyntaxOff"])
};
var atLetterFind = {
  start: match.createMacroMatcher(["makeatletter"]),
  end: match.createMacroMatcher(["makeatother"])
};
function findExpl3AndAtLetterRegionsInArray(tree) {
  const expl3 = findRegionInArray(tree, expl3Find.start, expl3Find.end);
  const atLetter = findRegionInArray(tree, atLetterFind.start, atLetterFind.end);
  const regionMap = new Map([
    ...expl3.map((x) => [x, "expl"]),
    ...atLetter.map((x) => [x, "atLetter"])
  ]);
  const all2 = refineRegions([...expl3, ...atLetter]);
  const ret = {
    explOnly: [],
    atLetterOnly: [],
    both: []
  };
  for (let i = 0;i < all2.regions.length; i++) {
    const region = all2.regions[i];
    const containedIn = all2.regionsContainedIn[i];
    if (containedIn.size === 2) {
      ret.both.push(region);
      continue;
    }
    for (const v of containedIn.values()) {
      if (regionMap.get(v) === "expl") {
        ret.explOnly.push(region);
      }
      if (regionMap.get(v) === "atLetter") {
        ret.atLetterOnly.push(region);
      }
    }
  }
  ret.explOnly = ret.explOnly.filter((r) => r.end - r.start > 1);
  ret.atLetterOnly = ret.atLetterOnly.filter((r) => r.end - r.start > 1);
  ret.both = ret.both.filter((r) => r.end - r.start > 1);
  return ret;
}
var atLetterSet = /* @__PURE__ */ new Set(["@"]);
var explSet = /* @__PURE__ */ new Set(["_", ":"]);
var bothSet = /* @__PURE__ */ new Set(["_", ":", "@"]);
function reparseExpl3AndAtLetterRegions(tree) {
  visit3(tree, {
    leave: (nodes) => {
      const regions = findExpl3AndAtLetterRegionsInArray(nodes);
      const totalNumRegions = regions.both.length + regions.atLetterOnly.length + regions.explOnly.length;
      if (totalNumRegions === 0) {
        return;
      }
      const splits = splitByRegions(nodes, regions);
      const processed = [];
      for (const [key, slice] of splits) {
        switch (key) {
          case null:
            processed.push(...slice);
            continue;
          case "atLetterOnly":
            reparseMacroNames(slice, atLetterSet);
            processed.push(...slice);
            continue;
          case "explOnly":
            reparseMacroNames(slice, explSet);
            processed.push(...slice);
            continue;
          case "both":
            reparseMacroNames(slice, bothSet);
            processed.push(...slice);
            continue;
          default:
            throw new Error(`Unexpected case when splitting ${key}`);
        }
      }
      nodes.length = 0;
      nodes.push(...processed);
      return SKIP4;
    }
  }, { includeArrays: true, test: Array.isArray });
}

// node_modules/@unified-latex/unified-latex-util-parse/index.js
var unifiedLatexAstComplier = function unifiedLatexAstComplier2() {
  Object.assign(this, { Compiler: (x) => x });
};
function parseMinimal(str) {
  return LatexPegParser.parse(str);
}
function parseMathMinimal(str) {
  return LatexPegParser.parse(str, { startRule: "math" });
}
var unifiedLatexFromStringMinimal = function unifiedLatexFromStringMinimal2(options2) {
  const parser2 = (str) => {
    if ((options2 == null ? undefined : options2.mode) === "math") {
      return {
        type: "root",
        content: parseMathMinimal(str),
        _renderInfo: { inMathMode: true }
      };
    }
    return parseMinimal(str);
  };
  Object.assign(this, { Parser: parser2 });
};
function unifiedLatexReparseMathConstructPlugin({
  mathEnvs,
  mathMacros
}) {
  const isMathEnvironment = match.createEnvironmentMatcher(mathEnvs);
  const isMathMacro = match.createMacroMatcher(mathMacros);
  return (tree) => {
    visit3(tree, (node2) => {
      if (match.anyMacro(node2)) {
        for (const arg2 of node2.args || []) {
          if (arg2.content.length > 0 && !wasParsedInMathMode(arg2.content)) {
            arg2.content = parseMathMinimal(printRaw(arg2.content));
          }
        }
      }
      if (match.anyEnvironment(node2)) {
        if (!wasParsedInMathMode(node2.content)) {
          node2.content = parseMathMinimal(printRaw(node2.content));
        }
      }
    }, {
      test: (node2) => isMathEnvironment(node2) || isMathMacro(node2)
    });
  };
}
function wasParsedInMathMode(nodes) {
  return !nodes.some((node2) => match.anyString(node2) && node2.content.length > 1 || match.string(node2, "^") || match.string(node2, "_"));
}
var unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse = function unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse2(options2) {
  const { environments: environments18 = {}, macros: macros18 = {} } = options2 || {};
  const mathMacros = Object.fromEntries(Object.entries(macros18).filter(([_, info]) => {
    var _a;
    return ((_a = info.renderInfo) == null ? undefined : _a.inMathMode) === true;
  }));
  const mathEnvs = Object.fromEntries(Object.entries(environments18).filter(([_, info]) => {
    var _a;
    return ((_a = info.renderInfo) == null ? undefined : _a.inMathMode) === true;
  }));
  const mathReparser = unifiedLatexReparseMathConstructPlugin({
    mathEnvs: Object.keys(mathEnvs),
    mathMacros: Object.keys(mathMacros)
  });
  const isRelevantEnvironment = match.createEnvironmentMatcher(environments18);
  const isRelevantMathEnvironment = match.createEnvironmentMatcher(mathEnvs);
  return (tree) => {
    visit3(tree, {
      enter: (nodes) => {
        if (!Array.isArray(nodes)) {
          return;
        }
        attachMacroArgsInArray(nodes, mathMacros);
      },
      leave: (node2) => {
        if (!isRelevantMathEnvironment(node2)) {
          return;
        }
        const envName = printRaw(node2.env);
        const envInfo = environments18[envName];
        if (!envInfo) {
          throw new Error(`Could not find environment info for environment "${envName}"`);
        }
        processEnvironment(node2, envInfo);
      }
    }, { includeArrays: true });
    mathReparser(tree);
    visit3(tree, {
      enter: (nodes) => {
        if (!Array.isArray(nodes)) {
          return;
        }
        attachMacroArgsInArray(nodes, macros18);
      },
      leave: (node2) => {
        if (!isRelevantEnvironment(node2)) {
          return;
        }
        const envName = printRaw(node2.env);
        const envInfo = environments18[envName];
        if (!envInfo) {
          throw new Error(`Could not find environment info for environment "${envName}"`);
        }
        processEnvironment(node2, envInfo);
      }
    }, { includeArrays: true });
  };
};
var unifiedLatexProcessAtLetterAndExplMacros = function unifiedLatexProcessAtLetterAndExplMacros2(options2) {
  let {
    atLetter = false,
    expl3 = false,
    autodetectExpl3AndAtLetter = false
  } = options2 || {};
  return (tree) => {
    reparseExpl3AndAtLetterRegions(tree);
    if (atLetter || expl3) {
      autodetectExpl3AndAtLetter = false;
    }
    if (autodetectExpl3AndAtLetter) {
      atLetter = hasReparsableMacroNames(tree, "@");
      expl3 = hasReparsableMacroNames(tree, "_");
    }
    const charSet = /* @__PURE__ */ new Set;
    if (atLetter) {
      charSet.add("@");
    }
    if (expl3) {
      charSet.add(":");
      charSet.add("_");
    }
    if (charSet.size > 0) {
      reparseMacroNames(tree, charSet);
    }
  };
};
var unifiedLatexFromString = function unifiedLatexFromString2(options2) {
  const {
    mode = "regular",
    macros: macros18 = {},
    environments: environments18 = {},
    flags: {
      atLetter = false,
      expl3 = false,
      autodetectExpl3AndAtLetter = false
    } = {}
  } = options2 || {};
  const allMacroInfo = Object.assign({}, ...Object.values(macroInfo), macros18);
  const allEnvInfo = Object.assign({}, ...Object.values(environmentInfo), environments18);
  const fullParser = unified2().use(unifiedLatexFromStringMinimal, { mode }).use(unifiedLatexProcessAtLetterAndExplMacros, {
    atLetter,
    expl3,
    autodetectExpl3AndAtLetter
  }).use(unifiedLatexProcessMacrosAndEnvironmentsWithMathReparse, {
    macros: allMacroInfo,
    environments: allEnvInfo
  }).use(unifiedLatexTrimEnvironmentContents).use(unifiedLatexTrimRoot).use(unifiedLatexAstComplier);
  const parser2 = (str) => {
    const file = fullParser.processSync({ value: str });
    return file.result;
  };
  Object.assign(this, { Parser: parser2 });
};
var parser = unified2().use(unifiedLatexFromString).freeze();
function parseMath(str) {
  if (typeof str !== "string") {
    str = printRaw(str);
  }
  const parser2 = unified2().use(unifiedLatexFromString, { mode: "math" });
  return parser2.parse({ value: str }).content;
}

// node_modules/remark-docx/lib/index.mjs
var unreachable = (_) => {
  throw new Error("unreachable");
};
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
var hasSquareBrackets = (arg2) => {
  return !!arg2 && arg2.openMark === "[" && arg2.closeMark === "]";
};
var hasCurlyBrackets = (arg2) => {
  return !!arg2 && arg2.openMark === "{" && arg2.closeMark === "}";
};
var mapString = (s2) => new MathRun(s2);
var mapMacro = (n, runs) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  switch (n.content) {
    case "#":
      return mapString("#");
    case "$":
      return mapString("$");
    case "%":
      return mapString("%");
    case "&":
      return mapString("&");
    case "textasciitilde":
      return mapString("~");
    case "textasciicircum":
      return mapString("^");
    case "textbackslash":
      return mapString("");
    case "{":
      return mapString("{");
    case "}":
      return mapString("}");
    case "textbar":
      return mapString("|");
    case "textless":
      return mapString("<");
    case "textgreater":
      return mapString(">");
    case "neq":
      return mapString("");
    case "sim":
      return mapString("");
    case "simeq":
      return mapString("");
    case "approx":
      return mapString("");
    case "fallingdotseq":
      return mapString("");
    case "risingdotseq":
      return mapString("");
    case "equiv":
      return mapString("");
    case "geq":
      return mapString("");
    case "geqq":
      return mapString("");
    case "leq":
      return mapString("");
    case "leqq":
      return mapString("");
    case "gg":
      return mapString("");
    case "ll":
      return mapString("");
    case "times":
      return mapString("");
    case "div":
      return mapString("");
    case "pm":
      return mapString("");
    case "mp":
      return mapString("");
    case "oplus":
      return mapString("");
    case "ominus":
      return mapString("");
    case "otimes":
      return mapString("");
    case "oslash":
      return mapString("");
    case "circ":
      return mapString("");
    case "cdot":
      return mapString("");
    case "bullet":
      return mapString("");
    case "ltimes":
      return mapString("");
    case "rtimes":
      return mapString("");
    case "in":
      return mapString("");
    case "ni":
      return mapString("");
    case "notin":
      return mapString("");
    case "subset":
      return mapString("");
    case "supset":
      return mapString("");
    case "subseteq":
      return mapString("");
    case "supseteq":
      return mapString("");
    case "nsubseteq":
      return mapString("");
    case "nsupseteq":
      return mapString("");
    case "subsetneq":
      return mapString("");
    case "supsetneq":
      return mapString("");
    case "cap":
      return mapString("");
    case "cup":
      return mapString("");
    case "emptyset":
      return mapString("");
    case "infty":
      return mapString("");
    case "partial":
      return mapString("");
    case "aleph":
      return mapString("");
    case "hbar":
      return mapString("");
    case "wp":
      return mapString("");
    case "Re":
      return mapString("");
    case "Im":
      return mapString("");
    case "alpha":
      return mapString("");
    case "beta":
      return mapString("");
    case "gamma":
      return mapString("");
    case "delta":
      return mapString("");
    case "epsilon":
      return mapString("");
    case "zeta":
      return mapString("");
    case "eta":
      return mapString("");
    case "theta":
      return mapString("");
    case "iota":
      return mapString("");
    case "kappa":
      return mapString("");
    case "lambda":
      return mapString("");
    case "eta":
      return mapString("");
    case "mu":
      return mapString("");
    case "nu":
      return mapString("");
    case "xi":
      return mapString("");
    case "pi":
      return mapString("");
    case "rho":
      return mapString("");
    case "sigma":
      return mapString("");
    case "tau":
      return mapString("");
    case "upsilon":
      return mapString("");
    case "phi":
      return mapString("");
    case "chi":
      return mapString("");
    case "psi":
      return mapString("");
    case "omega":
      return mapString("");
    case "varepsilon":
      return mapString("");
    case "vartheta":
      return mapString("");
    case "varrho":
      return mapString("");
    case "varsigma":
      return mapString("");
    case "varphi":
      return mapString("");
    case "Gamma":
      return mapString("");
    case "Delta":
      return mapString("");
    case "Theta":
      return mapString("");
    case "Lambda":
      return mapString("");
    case "Xi":
      return mapString("");
    case "Pi":
      return mapString("");
    case "Sigma":
      return mapString("");
    case "Upsilon":
      return mapString("");
    case "Phi":
      return mapString("");
    case "Psi":
      return mapString("");
    case "Omega":
      return mapString("");
    case "newline":
    case "\\":
      return false;
    case "^": {
      const prev = runs.pop();
      if (!prev)
        break;
      return new MathSuperScript({
        children: [prev],
        superScript: mapGroup((_c = (_b = (_a = n.args) === null || _a === undefined ? undefined : _a[0]) === null || _b === undefined ? undefined : _b.content) !== null && _c !== undefined ? _c : [])
      });
    }
    case "_": {
      const prev = runs.pop();
      if (!prev)
        break;
      return new MathSubScript({
        children: [prev],
        subScript: mapGroup((_f = (_e = (_d = n.args) === null || _d === undefined ? undefined : _d[0]) === null || _e === undefined ? undefined : _e.content) !== null && _f !== undefined ? _f : [])
      });
    }
    case "hat":
      break;
    case "widehat":
      break;
    case "sum": {
      return new MathSum({
        children: []
      });
    }
    case "int":
      return mapString("");
    case "frac":
    case "tfrac":
    case "dfrac": {
      const args = (_g = n.args) !== null && _g !== undefined ? _g : [];
      if (args.length === 2 && hasCurlyBrackets(args[0]) && hasCurlyBrackets(args[1])) {
        return new MathFraction({
          numerator: mapGroup(args[0].content),
          denominator: mapGroup(args[1].content)
        });
      }
      break;
    }
    case "sqrt": {
      const args = (_h = n.args) !== null && _h !== undefined ? _h : [];
      if (args.length === 1 && hasCurlyBrackets(args[0])) {
        return new MathRadical({
          children: mapGroup(args[0].content)
        });
      }
      if (args.length === 2 && hasSquareBrackets(args[0]) && hasCurlyBrackets(args[1])) {
        return new MathRadical({
          children: mapGroup(args[1].content),
          degree: mapGroup(args[0].content)
        });
      }
      break;
    }
  }
  return mapString(n.content);
};
var mapGroup = (nodes) => {
  const group = [];
  for (const c of nodes) {
    group.push(...mapNode(c, group) || []);
  }
  return group;
};
var mapNode = (n, runs) => {
  switch (n.type) {
    case "root":
      break;
    case "string":
      return [mapString(n.content)];
    case "whitespace":
      break;
    case "parbreak":
      break;
    case "comment":
      break;
    case "macro":
      const run = mapMacro(n, runs);
      if (!run) {
        return false;
      } else {
        return [run];
      }
    case "environment":
    case "mathenv":
      break;
    case "verbatim":
      break;
    case "inlinemath":
      break;
    case "displaymath":
      break;
    case "group":
      return mapGroup(n.content);
    case "verb":
      break;
    default:
      unreachable();
  }
  return [];
};
var parseLatex = (value) => {
  const parsed = parseMath(value);
  const paragraphs = [[]];
  let runs = paragraphs[0];
  for (const n of parsed) {
    const res = mapNode(n, runs);
    if (!res) {
      paragraphs.push(runs = []);
    } else {
      runs.push(...res);
    }
  }
  return paragraphs;
};
var ORDERED_LIST_REF = "ordered";
var INDENT = 0.5;
var DEFAULT_NUMBERINGS = [
  {
    level: 0,
    format: LevelFormat.DECIMAL,
    text: "%1.",
    alignment: AlignmentType.START
  },
  {
    level: 1,
    format: LevelFormat.DECIMAL,
    text: "%2.",
    alignment: AlignmentType.START,
    style: {
      paragraph: {
        indent: { start: convertInchesToTwip(INDENT * 1) }
      }
    }
  },
  {
    level: 2,
    format: LevelFormat.DECIMAL,
    text: "%3.",
    alignment: AlignmentType.START,
    style: {
      paragraph: {
        indent: { start: convertInchesToTwip(INDENT * 2) }
      }
    }
  },
  {
    level: 3,
    format: LevelFormat.DECIMAL,
    text: "%4.",
    alignment: AlignmentType.START,
    style: {
      paragraph: {
        indent: { start: convertInchesToTwip(INDENT * 3) }
      }
    }
  },
  {
    level: 4,
    format: LevelFormat.DECIMAL,
    text: "%5.",
    alignment: AlignmentType.START,
    style: {
      paragraph: {
        indent: { start: convertInchesToTwip(INDENT * 4) }
      }
    }
  },
  {
    level: 5,
    format: LevelFormat.DECIMAL,
    text: "%6.",
    alignment: AlignmentType.START,
    style: {
      paragraph: {
        indent: { start: convertInchesToTwip(INDENT * 5) }
      }
    }
  }
];
var createFootnoteRegistry = () => {
  const idToInternalId = new Map;
  const defs = new Map;
  const getId = (id) => {
    let internalId = idToInternalId.get(id);
    if (internalId == null) {
      idToInternalId.set(id, internalId = idToInternalId.size + 1);
    }
    return internalId;
  };
  return {
    ref: (id) => {
      return getId(id);
    },
    def: (id, def) => {
      const internalId = getId(id);
      defs.set(internalId, def);
    },
    footnotes: () => {
      return defs.entries().reduce((acc, [key, def]) => {
        acc[key] = def;
        return acc;
      }, {});
    }
  };
};
var mdastToDocx = async (node2, { output = "buffer", title, subject, creator, keywords, description, lastModifiedBy, revision, styles, background }, images) => {
  const definition3 = {};
  visit2(node2, "definition", (node3) => {
    definition3[node3.identifier] = node3.url;
  });
  const footnote = createFootnoteRegistry();
  const nodes = convertNodes(node2.children, {
    deco: {},
    images,
    indent: 0,
    def: definition3,
    footnote
  });
  const doc = new File({
    title,
    subject,
    creator,
    keywords,
    description,
    lastModifiedBy,
    revision,
    styles,
    background,
    footnotes: footnote.footnotes(),
    sections: [{ children: nodes }],
    numbering: {
      config: [
        {
          reference: ORDERED_LIST_REF,
          levels: DEFAULT_NUMBERINGS
        }
      ]
    }
  });
  switch (output) {
    case "buffer":
      const bufOut = await Packer.toBuffer(doc);
      return typeof Buffer === "function" ? Buffer.from(bufOut) : bufOut;
    case "blob":
      return Packer.toBlob(doc);
  }
};
var convertNodes = (nodes, ctx) => {
  const results = [];
  for (const node2 of nodes) {
    switch (node2.type) {
      case "paragraph": {
        results.push(buildParagraph(node2, ctx));
        break;
      }
      case "heading": {
        results.push(buildHeading(node2, ctx));
        break;
      }
      case "thematicBreak":
        results.push(buildThematicBreak());
        break;
      case "blockquote": {
        results.push(...buildBlockquote(node2, ctx));
        break;
      }
      case "list": {
        results.push(...buildList(node2, ctx));
        break;
      }
      case "listItem":
        invariant(false, "unreachable");
      case "table":
        results.push(buildTable(node2, ctx));
        break;
      case "tableRow":
        invariant(false, "unreachable");
      case "tableCell":
        invariant(false, "unreachable");
      case "html":
        results.push(buildHtml(node2));
        break;
      case "code":
        results.push(buildCode(node2));
        break;
      case "yaml":
        break;
      case "toml":
        break;
      case "definition":
        break;
      case "footnoteDefinition": {
        registerFootnoteDefinition(node2, ctx);
        break;
      }
      case "text":
        results.push(buildText(node2.value, ctx.deco));
        break;
      case "emphasis":
      case "strong":
      case "delete": {
        const { type, children } = node2;
        const nodes2 = convertNodes(children, {
          ...ctx,
          deco: { ...ctx.deco, [type]: true }
        });
        results.push(...nodes2);
        break;
      }
      case "inlineCode":
        results.push(buildText(node2.value, ctx.deco));
        break;
      case "break":
        results.push(buildBreak());
        break;
      case "link": {
        results.push(buildLink(node2, ctx));
        break;
      }
      case "image":
        results.push(buildImage(node2, ctx.images));
        break;
      case "linkReference":
        results.push(...buildLinkReference(node2, ctx));
        break;
      case "imageReference": {
        const image2 = buildImageReference(node2, ctx);
        if (image2) {
          results.push(image2);
        }
        break;
      }
      case "footnote": {
        break;
      }
      case "footnoteReference":
        results.push(buildFootnoteReference(node2, ctx));
        break;
      case "math":
        results.push(...buildMath(node2));
        break;
      case "inlineMath":
        results.push(buildInlineMath(node2));
        break;
      default:
        unreachable();
        break;
    }
  }
  return results;
};
var buildParagraph = ({ children }, ctx) => {
  const list3 = ctx.list;
  const nodes = convertNodes(children, ctx);
  if (list3 && list3.checked != null) {
    nodes.unshift(new CheckBox({
      checked: list3.checked,
      checkedState: { value: "2611" },
      uncheckedState: { value: "2610" }
    }));
  }
  return new Paragraph({
    children: nodes,
    indent: ctx.indent > 0 ? {
      start: convertInchesToTwip(INDENT * ctx.indent)
    } : undefined,
    ...list3 && (list3.ordered ? {
      numbering: {
        reference: ORDERED_LIST_REF,
        level: list3.level
      }
    } : {
      bullet: {
        level: list3.level
      }
    })
  });
};
var buildHeading = ({ children, depth }, ctx) => {
  let headingLevel;
  switch (depth) {
    case 1:
      headingLevel = HeadingLevel.TITLE;
      break;
    case 2:
      headingLevel = HeadingLevel.HEADING_1;
      break;
    case 3:
      headingLevel = HeadingLevel.HEADING_2;
      break;
    case 4:
      headingLevel = HeadingLevel.HEADING_3;
      break;
    case 5:
      headingLevel = HeadingLevel.HEADING_4;
      break;
    case 6:
      headingLevel = HeadingLevel.HEADING_5;
      break;
  }
  const nodes = convertNodes(children, ctx);
  return new Paragraph({
    heading: headingLevel,
    children: nodes
  });
};
var buildThematicBreak = (_) => {
  return new Paragraph({
    thematicBreak: true
  });
};
var buildBlockquote = ({ children }, ctx) => {
  return convertNodes(children, {
    ...ctx,
    indent: ctx.indent + 1
  });
};
var buildList = ({ children, ordered, start: _start, spread: _spread }, ctx) => {
  const list3 = {
    level: ctx.list ? ctx.list.level + 1 : 0,
    ordered: !!ordered
  };
  return children.flatMap((item) => {
    return buildListItem(item, {
      ...ctx,
      list: list3
    });
  });
};
var buildListItem = ({ children, checked, spread: _spread }, ctx) => {
  return convertNodes(children, {
    ...ctx,
    ...ctx.list && { list: { ...ctx.list, checked: checked !== null && checked !== undefined ? checked : undefined } }
  });
};
var buildTable = ({ children, align }, ctx) => {
  const cellAligns = align === null || align === undefined ? undefined : align.map((a) => {
    switch (a) {
      case "left":
        return AlignmentType.LEFT;
      case "right":
        return AlignmentType.RIGHT;
      case "center":
        return AlignmentType.CENTER;
      default:
        return AlignmentType.LEFT;
    }
  });
  return new Table({
    rows: children.map((r) => {
      return buildTableRow(r, ctx, cellAligns);
    })
  });
};
var buildTableRow = ({ children }, ctx, cellAligns) => {
  return new TableRow({
    children: children.map((c, i) => {
      return buildTableCell(c, ctx, cellAligns === null || cellAligns === undefined ? undefined : cellAligns[i]);
    })
  });
};
var buildTableCell = ({ children }, ctx, align) => {
  const nodes = convertNodes(children, ctx);
  return new TableCell({
    children: [
      new Paragraph({
        alignment: align,
        children: nodes
      })
    ]
  });
};
var buildHtml = ({ value }) => {
  return new Paragraph({
    children: [buildText(value, {})]
  });
};
var buildCode = ({ value, lang: _lang, meta: _meta }) => {
  return new Paragraph({
    children: [buildText(value, {})]
  });
};
var buildMath = ({ value }) => {
  return parseLatex(value).map((runs) => new Paragraph({
    children: [
      new Math$1({
        children: runs
      })
    ]
  }));
};
var buildInlineMath = ({ value }) => {
  return new Math$1({
    children: parseLatex(value).flatMap((runs) => runs)
  });
};
var buildText = (text5, deco) => {
  return new TextRun({
    text: text5,
    bold: deco.strong,
    italics: deco.emphasis,
    strike: deco.delete
  });
};
var buildBreak = (_) => {
  return new TextRun({ text: "", break: 1 });
};
var buildLink = ({ children, url }, ctx) => {
  const nodes = convertNodes(children, ctx);
  return new ExternalHyperlink({
    link: url,
    children: nodes
  });
};
var buildImage = ({ url }, images) => {
  const img = images[url];
  invariant(img, `Fetch image was failed: ${url}`);
  const { image: image2, width, height } = img;
  return new ImageRun({
    data: image2,
    transformation: {
      width,
      height
    }
  });
};
var buildLinkReference = ({ children, identifier }, ctx) => {
  const def = ctx.def[identifier];
  if (def == null) {
    return convertNodes(children, ctx);
  }
  return [buildLink({ children, url: def }, ctx)];
};
var buildImageReference = ({ identifier }, ctx) => {
  const def = ctx.def[identifier];
  if (def == null) {
    return;
  }
  return buildImage({ url: def }, ctx.images);
};
var registerFootnoteDefinition = ({ children, identifier }, ctx) => {
  const definition3 = {
    children: children.map((node2) => {
      const nodes = convertNodes([node2], ctx);
      if (nodes[0] instanceof Paragraph) {
        return nodes[0];
      }
      return new Paragraph({ children: nodes });
    })
  };
  ctx.footnote.def(identifier, definition3);
};
var buildFootnoteReference = ({ identifier }, ctx) => {
  return new FootnoteReferenceRun(ctx.footnote.ref(identifier));
};
var plugin = function(opts = {}) {
  let images = {};
  this.Compiler = (node2) => {
    return mdastToDocx(node2, opts, images);
  };
  return async (node2) => {
    const imageList = [];
    visit2(node2, "image", (node3) => {
      imageList.push(node3);
    });
    const defs = new Map;
    visit2(node2, "definition", (node3) => {
      defs.set(node3.identifier, node3);
    });
    visit2(node2, "imageReference", (node3) => {
      const maybeImage = defs.get(node3.identifier);
      if (maybeImage) {
        imageList.push(maybeImage);
      }
    });
    if (imageList.length === 0) {
      return node2;
    }
    const imageResolver = opts.imageResolver;
    invariant(imageResolver, "options.imageResolver is not defined.");
    const resolved = new Set;
    const promises = [];
    imageList.forEach(({ url }) => {
      if (!resolved.has(url)) {
        resolved.add(url);
        promises.push((async () => {
          const img = await imageResolver(url);
          return { img, url };
        })());
      }
    });
    images = (await Promise.all(promises)).reduce((acc, { img, url }) => {
      acc[url] = img;
      return acc;
    }, {});
    return node2;
  };
};

// node_modules/clipboardy/index.js
import process10 from "node:process";

// node_modules/is-wsl/index.js
import process3 from "node:process";
import os from "node:os";
import fs3 from "node:fs";

// node_modules/is-inside-container/index.js
import fs2 from "node:fs";

// node_modules/is-docker/index.js
import fs from "node:fs";
var isDockerCached;
function hasDockerEnv() {
  try {
    fs.statSync("/.dockerenv");
    return true;
  } catch {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch {
    return false;
  }
}
function isDocker() {
  if (isDockerCached === undefined) {
    isDockerCached = hasDockerEnv() || hasDockerCGroup();
  }
  return isDockerCached;
}

// node_modules/is-inside-container/index.js
var cachedResult;
var hasContainerEnv = () => {
  try {
    fs2.statSync("/run/.containerenv");
    return true;
  } catch {
    return false;
  }
};
function isInsideContainer() {
  if (cachedResult === undefined) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}

// node_modules/is-wsl/index.js
var isWsl = () => {
  if (process3.platform !== "linux") {
    return false;
  }
  if (os.release().toLowerCase().includes("microsoft")) {
    if (isInsideContainer()) {
      return false;
    }
    return true;
  }
  try {
    return fs3.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isInsideContainer() : false;
  } catch {
    return false;
  }
};
var is_wsl_default = process3.env.__IS_WSL_TEST__ ? isWsl : isWsl();

// node_modules/execa/index.js
var import_cross_spawn = __toESM(require_cross_spawn(), 1);
import { Buffer as Buffer3 } from "node:buffer";
import path3 from "node:path";
import childProcess from "node:child_process";
import process8 from "node:process";

// node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  const LF = typeof input === "string" ? `
` : `
`.charCodeAt();
  const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
  if (input[input.length - 1] === LF) {
    input = input.slice(0, -1);
  }
  if (input[input.length - 1] === CR) {
    input = input.slice(0, -1);
  }
  return input;
}

// node_modules/npm-run-path/index.js
import process4 from "node:process";
import path2 from "node:path";
import { fileURLToPath as fileURLToPath3 } from "node:url";

// node_modules/npm-run-path/node_modules/path-key/index.js
function pathKey(options2 = {}) {
  const {
    env = process.env,
    platform = process.platform
  } = options2;
  if (platform !== "win32") {
    return "PATH";
  }
  return Object.keys(env).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}

// node_modules/npm-run-path/index.js
var npmRunPath = ({
  cwd = process4.cwd(),
  path: pathOption = process4.env[pathKey()],
  preferLocal = true,
  execPath = process4.execPath,
  addExecPath = true
} = {}) => {
  const cwdString = cwd instanceof URL ? fileURLToPath3(cwd) : cwd;
  const cwdPath = path2.resolve(cwdString);
  const result = [];
  if (preferLocal) {
    applyPreferLocal(result, cwdPath);
  }
  if (addExecPath) {
    applyExecPath(result, execPath, cwdPath);
  }
  return [...result, pathOption].join(path2.delimiter);
};
var applyPreferLocal = (result, cwdPath) => {
  let previous3;
  while (previous3 !== cwdPath) {
    result.push(path2.join(cwdPath, "node_modules/.bin"));
    previous3 = cwdPath;
    cwdPath = path2.resolve(cwdPath, "..");
  }
};
var applyExecPath = (result, execPath, cwdPath) => {
  const execPathString = execPath instanceof URL ? fileURLToPath3(execPath) : execPath;
  result.push(path2.resolve(cwdPath, execPathString, ".."));
};
var npmRunPathEnv = ({ env = process4.env, ...options2 } = {}) => {
  env = { ...env };
  const pathName = pathKey({ env });
  options2.path = env[pathName];
  env[pathName] = npmRunPath(options2);
  return env;
};

// node_modules/mimic-fn/index.js
var copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
var canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
var changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
var changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}

// node_modules/onetime/index.js
var calledFunctions = new WeakMap;
var onetime = (function_, options2 = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options2.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFunction(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetime_default = onetime;

// node_modules/execa/lib/error.js
import process5 from "node:process";

// node_modules/human-signals/build/src/main.js
import { constants as constants3 } from "node:os";

// node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals = () => {
  const length = SIGRTMAX - SIGRTMIN + 1;
  return Array.from({ length }, getRealtimeSignal);
};
var getRealtimeSignal = (value, index3) => ({
  name: `SIGRT${index3 + 1}`,
  number: SIGRTMIN + index3,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
});
var SIGRTMIN = 34;
var SIGRTMAX = 64;

// node_modules/human-signals/build/src/signals.js
import { constants as constants2 } from "node:os";

// node_modules/human-signals/build/src/core.js
var SIGNALS = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// node_modules/human-signals/build/src/signals.js
var getSignals = () => {
  const realtimeSignals = getRealtimeSignals();
  const signals = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
  return signals;
};
var normalizeSignal = ({
  name,
  number: defaultNumber,
  description,
  action,
  forced = false,
  standard
}) => {
  const {
    signals: { [name]: constantSignal }
  } = constants2;
  const supported = constantSignal !== undefined;
  const number = supported ? constantSignal : defaultNumber;
  return { name, number, description, supported, action, forced, standard };
};

// node_modules/human-signals/build/src/main.js
var getSignalsByName = () => {
  const signals = getSignals();
  return Object.fromEntries(signals.map(getSignalByName));
};
var getSignalByName = ({
  name,
  number,
  description,
  supported,
  action,
  forced,
  standard
}) => [name, { name, number, description, supported, action, forced, standard }];
var signalsByName = getSignalsByName();
var getSignalsByNumber = () => {
  const signals = getSignals();
  const length = SIGRTMAX + 1;
  const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
  return Object.assign({}, ...signalsA);
};
var getSignalByNumber = (number, signals) => {
  const signal = findSignalByNumber(number, signals);
  if (signal === undefined) {
    return {};
  }
  const { name, description, supported, action, forced, standard } = signal;
  return {
    [number]: {
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }
  };
};
var findSignalByNumber = (number, signals) => {
  const signal = signals.find(({ name }) => constants3.signals[name] === number);
  if (signal !== undefined) {
    return signal;
  }
  return signals.find((signalA) => signalA.number === number);
};
var signalsByNumber = getSignalsByNumber();

// node_modules/execa/lib/error.js
var getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
  if (timedOut) {
    return `timed out after ${timeout} milliseconds`;
  }
  if (isCanceled) {
    return "was canceled";
  }
  if (errorCode !== undefined) {
    return `failed with ${errorCode}`;
  }
  if (signal !== undefined) {
    return `was killed with ${signal} (${signalDescription})`;
  }
  if (exitCode !== undefined) {
    return `failed with exit code ${exitCode}`;
  }
  return "failed";
};
var makeError = ({
  stdout,
  stderr,
  all: all2,
  error,
  signal,
  exitCode,
  command,
  escapedCommand,
  timedOut,
  isCanceled,
  killed,
  parsed: { options: { timeout, cwd = process5.cwd() } }
}) => {
  exitCode = exitCode === null ? undefined : exitCode;
  signal = signal === null ? undefined : signal;
  const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;
  const errorCode = error && error.code;
  const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
  const execaMessage = `Command ${prefix}: ${command}`;
  const isError = Object.prototype.toString.call(error) === "[object Error]";
  const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
  const message = [shortMessage, stderr, stdout].filter(Boolean).join(`
`);
  if (isError) {
    error.originalMessage = error.message;
    error.message = message;
  } else {
    error = new Error(message);
  }
  error.shortMessage = shortMessage;
  error.command = command;
  error.escapedCommand = escapedCommand;
  error.exitCode = exitCode;
  error.signal = signal;
  error.signalDescription = signalDescription;
  error.stdout = stdout;
  error.stderr = stderr;
  error.cwd = cwd;
  if (all2 !== undefined) {
    error.all = all2;
  }
  if ("bufferedData" in error) {
    delete error.bufferedData;
  }
  error.failed = true;
  error.timedOut = Boolean(timedOut);
  error.isCanceled = isCanceled;
  error.killed = killed && !timedOut;
  return error;
};

// node_modules/execa/lib/stdio.js
var aliases = ["stdin", "stdout", "stderr"];
var hasAlias = (options2) => aliases.some((alias) => options2[alias] !== undefined);
var normalizeStdio = (options2) => {
  if (!options2) {
    return;
  }
  const { stdio } = options2;
  if (stdio === undefined) {
    return aliases.map((alias) => options2[alias]);
  }
  if (hasAlias(options2)) {
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
  }
  if (typeof stdio === "string") {
    return stdio;
  }
  if (!Array.isArray(stdio)) {
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
  }
  const length = Math.max(stdio.length, aliases.length);
  return Array.from({ length }, (value, index3) => stdio[index3]);
};

// node_modules/execa/lib/kill.js
import os2 from "node:os";

// node_modules/signal-exit/dist/mjs/signals.js
var signals = [];
signals.push("SIGHUP", "SIGINT", "SIGTERM");
if (process.platform !== "win32") {
  signals.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
}
if (process.platform === "linux") {
  signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
}

// node_modules/signal-exit/dist/mjs/index.js
var processOk = (process6) => !!process6 && typeof process6 === "object" && typeof process6.removeListener === "function" && typeof process6.emit === "function" && typeof process6.reallyExit === "function" && typeof process6.listeners === "function" && typeof process6.kill === "function" && typeof process6.pid === "number" && typeof process6.on === "function";
var kExitEmitter = Symbol.for("signal-exit emitter");
var global2 = globalThis;
var ObjectDefineProperty = Object.defineProperty.bind(Object);

class Emitter {
  emitted = {
    afterExit: false,
    exit: false
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global2[kExitEmitter]) {
      return global2[kExitEmitter];
    }
    ObjectDefineProperty(global2, kExitEmitter, {
      value: this,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list3 = this.listeners[ev];
    const i = list3.indexOf(fn);
    if (i === -1) {
      return;
    }
    if (i === 0 && list3.length === 1) {
      list3.length = 0;
    } else {
      list3.splice(i, 1);
    }
  }
  emit(ev, code3, signal) {
    if (this.emitted[ev]) {
      return false;
    }
    this.emitted[ev] = true;
    let ret = false;
    for (const fn of this.listeners[ev]) {
      ret = fn(code3, signal) === true || ret;
    }
    if (ev === "exit") {
      ret = this.emit("afterExit", code3, signal) || ret;
    }
    return ret;
  }
}

class SignalExitBase {
}
var signalExitWrap = (handler) => {
  return {
    onExit(cb, opts) {
      return handler.onExit(cb, opts);
    },
    load() {
      return handler.load();
    },
    unload() {
      return handler.unload();
    }
  };
};

class SignalExitFallback extends SignalExitBase {
  onExit() {
    return () => {};
  }
  load() {}
  unload() {}
}

class SignalExit extends SignalExitBase {
  #hupSig = process6.platform === "win32" ? "SIGINT" : "SIGHUP";
  #emitter = new Emitter;
  #process;
  #originalProcessEmit;
  #originalProcessReallyExit;
  #sigListeners = {};
  #loaded = false;
  constructor(process6) {
    super();
    this.#process = process6;
    this.#sigListeners = {};
    for (const sig of signals) {
      this.#sigListeners[sig] = () => {
        const listeners2 = this.#process.listeners(sig);
        let { count } = this.#emitter;
        const p = process6;
        if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
          count += p.__signal_exit_emitter__.count;
        }
        if (listeners2.length === count) {
          this.unload();
          const ret = this.#emitter.emit("exit", null, sig);
          const s2 = sig === "SIGHUP" ? this.#hupSig : sig;
          if (!ret)
            process6.kill(process6.pid, s2);
        }
      };
    }
    this.#originalProcessReallyExit = process6.reallyExit;
    this.#originalProcessEmit = process6.emit;
  }
  onExit(cb, opts) {
    if (!processOk(this.#process)) {
      return () => {};
    }
    if (this.#loaded === false) {
      this.load();
    }
    const ev = opts?.alwaysLast ? "afterExit" : "exit";
    this.#emitter.on(ev, cb);
    return () => {
      this.#emitter.removeListener(ev, cb);
      if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
        this.unload();
      }
    };
  }
  load() {
    if (this.#loaded) {
      return;
    }
    this.#loaded = true;
    this.#emitter.count += 1;
    for (const sig of signals) {
      try {
        const fn = this.#sigListeners[sig];
        if (fn)
          this.#process.on(sig, fn);
      } catch (_) {}
    }
    this.#process.emit = (ev, ...a) => {
      return this.#processEmit(ev, ...a);
    };
    this.#process.reallyExit = (code3) => {
      return this.#processReallyExit(code3);
    };
  }
  unload() {
    if (!this.#loaded) {
      return;
    }
    this.#loaded = false;
    signals.forEach((sig) => {
      const listener = this.#sigListeners[sig];
      if (!listener) {
        throw new Error("Listener not defined for signal: " + sig);
      }
      try {
        this.#process.removeListener(sig, listener);
      } catch (_) {}
    });
    this.#process.emit = this.#originalProcessEmit;
    this.#process.reallyExit = this.#originalProcessReallyExit;
    this.#emitter.count -= 1;
  }
  #processReallyExit(code3) {
    if (!processOk(this.#process)) {
      return 0;
    }
    this.#process.exitCode = code3 || 0;
    this.#emitter.emit("exit", this.#process.exitCode, null);
    return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
  }
  #processEmit(ev, ...args) {
    const og = this.#originalProcessEmit;
    if (ev === "exit" && processOk(this.#process)) {
      if (typeof args[0] === "number") {
        this.#process.exitCode = args[0];
      }
      const ret = og.call(this.#process, ev, ...args);
      this.#emitter.emit("exit", this.#process.exitCode, null);
      return ret;
    } else {
      return og.call(this.#process, ev, ...args);
    }
  }
}
var process6 = globalThis.process;
var {
  onExit,
  load,
  unload
} = signalExitWrap(processOk(process6) ? new SignalExit(process6) : new SignalExitFallback);

// node_modules/execa/lib/kill.js
var DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
var spawnedKill = (kill, signal = "SIGTERM", options2 = {}) => {
  const killResult = kill(signal);
  setKillTimeout(kill, signal, options2, killResult);
  return killResult;
};
var setKillTimeout = (kill, signal, options2, killResult) => {
  if (!shouldForceKill(signal, options2, killResult)) {
    return;
  }
  const timeout = getForceKillAfterTimeout(options2);
  const t = setTimeout(() => {
    kill("SIGKILL");
  }, timeout);
  if (t.unref) {
    t.unref();
  }
};
var shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
var isSigterm = (signal) => signal === os2.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
var getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {
  if (forceKillAfterTimeout === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }
  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
    throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
  }
  return forceKillAfterTimeout;
};
var spawnedCancel = (spawned, context) => {
  const killResult = spawned.kill();
  if (killResult) {
    context.isCanceled = true;
  }
};
var timeoutKill = (spawned, signal, reject) => {
  spawned.kill(signal);
  reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
};
var setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
  if (timeout === 0 || timeout === undefined) {
    return spawnedPromise;
  }
  let timeoutId;
  const timeoutPromise = new Promise((resolve2, reject) => {
    timeoutId = setTimeout(() => {
      timeoutKill(spawned, killSignal, reject);
    }, timeout);
  });
  const safeSpawnedPromise = spawnedPromise.finally(() => {
    clearTimeout(timeoutId);
  });
  return Promise.race([timeoutPromise, safeSpawnedPromise]);
};
var validateTimeout = ({ timeout }) => {
  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
  }
};
var setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {
  if (!cleanup || detached) {
    return timedPromise;
  }
  const removeExitHandler = onExit(() => {
    spawned.kill();
  });
  return timedPromise.finally(() => {
    removeExitHandler();
  });
};

// node_modules/execa/lib/pipe.js
import { createWriteStream } from "node:fs";
import { ChildProcess } from "node:child_process";

// node_modules/is-stream/index.js
function isStream(stream) {
  return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isWritableStream(stream) {
  return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}

// node_modules/execa/lib/pipe.js
var isExecaChildProcess = (target) => target instanceof ChildProcess && typeof target.then === "function";
var pipeToTarget = (spawned, streamName, target) => {
  if (typeof target === "string") {
    spawned[streamName].pipe(createWriteStream(target));
    return spawned;
  }
  if (isWritableStream(target)) {
    spawned[streamName].pipe(target);
    return spawned;
  }
  if (!isExecaChildProcess(target)) {
    throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
  }
  if (!isWritableStream(target.stdin)) {
    throw new TypeError("The target child process's stdin must be available.");
  }
  spawned[streamName].pipe(target.stdin);
  return target;
};
var addPipeMethods = (spawned) => {
  if (spawned.stdout !== null) {
    spawned.pipeStdout = pipeToTarget.bind(undefined, spawned, "stdout");
  }
  if (spawned.stderr !== null) {
    spawned.pipeStderr = pipeToTarget.bind(undefined, spawned, "stderr");
  }
  if (spawned.all !== undefined) {
    spawned.pipeAll = pipeToTarget.bind(undefined, spawned, "all");
  }
};

// node_modules/execa/lib/stream.js
import { createReadStream, readFileSync } from "node:fs";
import { setTimeout as setTimeout2 } from "node:timers/promises";

// node_modules/get-stream/source/contents.js
var getStreamContents = async (stream, { init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
  if (!isAsyncIterable(stream)) {
    throw new Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");
  }
  const state2 = init();
  state2.length = 0;
  try {
    for await (const chunk of stream) {
      const chunkType = getChunkType(chunk);
      const convertedChunk = convertChunk[chunkType](chunk, state2);
      appendChunk({ convertedChunk, state: state2, getSize, truncateChunk, addChunk, maxBuffer });
    }
    appendFinalChunk({ state: state2, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer });
    return finalize(state2);
  } catch (error) {
    error.bufferedData = finalize(state2);
    throw error;
  }
};
var appendFinalChunk = ({ state: state2, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
  const convertedChunk = getFinalChunk(state2);
  if (convertedChunk !== undefined) {
    appendChunk({ convertedChunk, state: state2, getSize, truncateChunk, addChunk, maxBuffer });
  }
};
var appendChunk = ({ convertedChunk, state: state2, getSize, truncateChunk, addChunk, maxBuffer }) => {
  const chunkSize = getSize(convertedChunk);
  const newLength = state2.length + chunkSize;
  if (newLength <= maxBuffer) {
    addNewChunk(convertedChunk, state2, addChunk, newLength);
    return;
  }
  const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state2.length);
  if (truncatedChunk !== undefined) {
    addNewChunk(truncatedChunk, state2, addChunk, maxBuffer);
  }
  throw new MaxBufferError;
};
var addNewChunk = (convertedChunk, state2, addChunk, newLength) => {
  state2.contents = addChunk(convertedChunk, state2, newLength);
  state2.length = newLength;
};
var isAsyncIterable = (stream) => typeof stream === "object" && stream !== null && typeof stream[Symbol.asyncIterator] === "function";
var getChunkType = (chunk) => {
  const typeOfChunk = typeof chunk;
  if (typeOfChunk === "string") {
    return "string";
  }
  if (typeOfChunk !== "object" || chunk === null) {
    return "others";
  }
  if (globalThis.Buffer?.isBuffer(chunk)) {
    return "buffer";
  }
  const prototypeName = objectToString.call(chunk);
  if (prototypeName === "[object ArrayBuffer]") {
    return "arrayBuffer";
  }
  if (prototypeName === "[object DataView]") {
    return "dataView";
  }
  if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString.call(chunk.buffer) === "[object ArrayBuffer]") {
    return "typedArray";
  }
  return "others";
};
var { toString: objectToString } = Object.prototype;

class MaxBufferError extends Error {
  name = "MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
}

// node_modules/get-stream/source/utils.js
var identity = (value) => value;
var noop2 = () => {
  return;
};
var getContentsProp = ({ contents }) => contents;
var throwObjectStream = (chunk) => {
  throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
};
var getLengthProp = (convertedChunk) => convertedChunk.length;
// node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream, options2) {
  return getStreamContents(stream, arrayBufferMethods, options2);
}
var initArrayBuffer = () => ({ contents: new ArrayBuffer(0) });
var useTextEncoder = (chunk) => textEncoder.encode(chunk);
var textEncoder = new TextEncoder;
var useUint8Array = (chunk) => new Uint8Array(chunk);
var useUint8ArrayWithOffset = (chunk) => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
var truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length) => {
  const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
  new Uint8Array(newContents).set(convertedChunk, previousLength);
  return newContents;
};
var resizeArrayBufferSlow = (contents, length) => {
  if (length <= contents.byteLength) {
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var resizeArrayBuffer = (contents, length) => {
  if (length <= contents.maxByteLength) {
    contents.resize(length);
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
var SCALE_FACTOR = 2;
var finalizeArrayBuffer = ({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length);
var hasArrayBufferResize = () => ("resize" in ArrayBuffer.prototype);
var arrayBufferMethods = {
  init: initArrayBuffer,
  convertChunk: {
    string: useTextEncoder,
    buffer: useUint8Array,
    arrayBuffer: useUint8Array,
    dataView: useUint8ArrayWithOffset,
    typedArray: useUint8ArrayWithOffset,
    others: throwObjectStream
  },
  getSize: getLengthProp,
  truncateChunk: truncateArrayBufferChunk,
  addChunk: addArrayBufferChunk,
  getFinalChunk: noop2,
  finalize: finalizeArrayBuffer
};
// node_modules/get-stream/source/buffer.js
async function getStreamAsBuffer(stream, options2) {
  if (!("Buffer" in globalThis)) {
    throw new Error("getStreamAsBuffer() is only supported in Node.js");
  }
  try {
    return arrayBufferToNodeBuffer(await getStreamAsArrayBuffer(stream, options2));
  } catch (error) {
    if (error.bufferedData !== undefined) {
      error.bufferedData = arrayBufferToNodeBuffer(error.bufferedData);
    }
    throw error;
  }
}
var arrayBufferToNodeBuffer = (arrayBuffer) => globalThis.Buffer.from(arrayBuffer);
// node_modules/get-stream/source/string.js
async function getStreamAsString(stream, options2) {
  return getStreamContents(stream, stringMethods, options2);
}
var initString = () => ({ contents: "", textDecoder: new TextDecoder });
var useTextDecoder = (chunk, { textDecoder }) => textDecoder.decode(chunk, { stream: true });
var addStringChunk = (convertedChunk, { contents }) => contents + convertedChunk;
var truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var getFinalStringChunk = ({ textDecoder }) => {
  const finalChunk = textDecoder.decode();
  return finalChunk === "" ? undefined : finalChunk;
};
var stringMethods = {
  init: initString,
  convertChunk: {
    string: identity,
    buffer: useTextDecoder,
    arrayBuffer: useTextDecoder,
    dataView: useTextDecoder,
    typedArray: useTextDecoder,
    others: throwObjectStream
  },
  getSize: getLengthProp,
  truncateChunk: truncateStringChunk,
  addChunk: addStringChunk,
  getFinalChunk: getFinalStringChunk,
  finalize: getContentsProp
};
// node_modules/execa/lib/stream.js
var import_merge_stream = __toESM(require_merge_stream(), 1);
var validateInputOptions = (input) => {
  if (input !== undefined) {
    throw new TypeError("The `input` and `inputFile` options cannot be both set.");
  }
};
var getInputSync = ({ input, inputFile }) => {
  if (typeof inputFile !== "string") {
    return input;
  }
  validateInputOptions(input);
  return readFileSync(inputFile);
};
var handleInputSync = (options2) => {
  const input = getInputSync(options2);
  if (isStream(input)) {
    throw new TypeError("The `input` option cannot be a stream in sync mode");
  }
  return input;
};
var getInput = ({ input, inputFile }) => {
  if (typeof inputFile !== "string") {
    return input;
  }
  validateInputOptions(input);
  return createReadStream(inputFile);
};
var handleInput = (spawned, options2) => {
  const input = getInput(options2);
  if (input === undefined) {
    return;
  }
  if (isStream(input)) {
    input.pipe(spawned.stdin);
  } else {
    spawned.stdin.end(input);
  }
};
var makeAllStream = (spawned, { all: all2 }) => {
  if (!all2 || !spawned.stdout && !spawned.stderr) {
    return;
  }
  const mixed = import_merge_stream.default();
  if (spawned.stdout) {
    mixed.add(spawned.stdout);
  }
  if (spawned.stderr) {
    mixed.add(spawned.stderr);
  }
  return mixed;
};
var getBufferedData = async (stream, streamPromise) => {
  if (!stream || streamPromise === undefined) {
    return;
  }
  await setTimeout2(0);
  stream.destroy();
  try {
    return await streamPromise;
  } catch (error) {
    return error.bufferedData;
  }
};
var getStreamPromise = (stream, { encoding, buffer: buffer3, maxBuffer }) => {
  if (!stream || !buffer3) {
    return;
  }
  if (encoding === "utf8" || encoding === "utf-8") {
    return getStreamAsString(stream, { maxBuffer });
  }
  if (encoding === null || encoding === "buffer") {
    return getStreamAsBuffer(stream, { maxBuffer });
  }
  return applyEncoding(stream, maxBuffer, encoding);
};
var applyEncoding = async (stream, maxBuffer, encoding) => {
  const buffer3 = await getStreamAsBuffer(stream, { maxBuffer });
  return buffer3.toString(encoding);
};
var getSpawnedResult = async ({ stdout, stderr, all: all2 }, { encoding, buffer: buffer3, maxBuffer }, processDone) => {
  const stdoutPromise = getStreamPromise(stdout, { encoding, buffer: buffer3, maxBuffer });
  const stderrPromise = getStreamPromise(stderr, { encoding, buffer: buffer3, maxBuffer });
  const allPromise = getStreamPromise(all2, { encoding, buffer: buffer3, maxBuffer: maxBuffer * 2 });
  try {
    return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
  } catch (error) {
    return Promise.all([
      { error, signal: error.signal, timedOut: error.timedOut },
      getBufferedData(stdout, stdoutPromise),
      getBufferedData(stderr, stderrPromise),
      getBufferedData(all2, allPromise)
    ]);
  }
};

// node_modules/execa/lib/promise.js
var nativePromisePrototype = (async () => {})().constructor.prototype;
var descriptors = ["then", "catch", "finally"].map((property) => [
  property,
  Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]);
var mergePromise = (spawned, promise) => {
  for (const [property, descriptor] of descriptors) {
    const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
    Reflect.defineProperty(spawned, property, { ...descriptor, value });
  }
};
var getSpawnedPromise = (spawned) => new Promise((resolve2, reject) => {
  spawned.on("exit", (exitCode, signal) => {
    resolve2({ exitCode, signal });
  });
  spawned.on("error", (error) => {
    reject(error);
  });
  if (spawned.stdin) {
    spawned.stdin.on("error", (error) => {
      reject(error);
    });
  }
});

// node_modules/execa/lib/command.js
import { Buffer as Buffer2 } from "node:buffer";
import { ChildProcess as ChildProcess2 } from "node:child_process";
var normalizeArgs = (file, args = []) => {
  if (!Array.isArray(args)) {
    return [file];
  }
  return [file, ...args];
};
var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
var escapeArg = (arg2) => {
  if (typeof arg2 !== "string" || NO_ESCAPE_REGEXP.test(arg2)) {
    return arg2;
  }
  return `"${arg2.replaceAll('"', "\\\"")}"`;
};
var joinCommand = (file, args) => normalizeArgs(file, args).join(" ");
var getEscapedCommand = (file, args) => normalizeArgs(file, args).map((arg2) => escapeArg(arg2)).join(" ");
var SPACES_REGEXP = / +/g;
var parseExpression = (expression) => {
  const typeOfExpression = typeof expression;
  if (typeOfExpression === "string") {
    return expression;
  }
  if (typeOfExpression === "number") {
    return String(expression);
  }
  if (typeOfExpression === "object" && expression !== null && !(expression instanceof ChildProcess2) && "stdout" in expression) {
    const typeOfStdout = typeof expression.stdout;
    if (typeOfStdout === "string") {
      return expression.stdout;
    }
    if (Buffer2.isBuffer(expression.stdout)) {
      return expression.stdout.toString();
    }
    throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
  }
  throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
var concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
  ...tokens.slice(0, -1),
  `${tokens.at(-1)}${nextTokens[0]}`,
  ...nextTokens.slice(1)
];
var parseTemplate = ({ templates, expressions, tokens, index: index3, template }) => {
  const templateString = template ?? templates.raw[index3];
  const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
  const newTokens = concatTokens(tokens, templateTokens, templateString.startsWith(" "));
  if (index3 === expressions.length) {
    return newTokens;
  }
  const expression = expressions[index3];
  const expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
  return concatTokens(newTokens, expressionTokens, templateString.endsWith(" "));
};
var parseTemplates = (templates, expressions) => {
  let tokens = [];
  for (const [index3, template] of templates.entries()) {
    tokens = parseTemplate({ templates, expressions, tokens, index: index3, template });
  }
  return tokens;
};

// node_modules/execa/lib/verbose.js
import { debuglog } from "node:util";
import process7 from "node:process";
var verboseDefault = debuglog("execa").enabled;
var padField = (field, padding) => String(field).padStart(padding, "0");
var getTimestamp = () => {
  const date = new Date;
  return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
};
var logCommand = (escapedCommand, { verbose }) => {
  if (!verbose) {
    return;
  }
  process7.stderr.write(`[${getTimestamp()}] ${escapedCommand}
`);
};

// node_modules/execa/index.js
var DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;
var getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
  const env = extendEnv ? { ...process8.env, ...envOption } : envOption;
  if (preferLocal) {
    return npmRunPathEnv({ env, cwd: localDir, execPath });
  }
  return env;
};
var handleArguments = (file, args, options2 = {}) => {
  const parsed = import_cross_spawn.default._parse(file, args, options2);
  file = parsed.command;
  args = parsed.args;
  options2 = parsed.options;
  options2 = {
    maxBuffer: DEFAULT_MAX_BUFFER,
    buffer: true,
    stripFinalNewline: true,
    extendEnv: true,
    preferLocal: false,
    localDir: options2.cwd || process8.cwd(),
    execPath: process8.execPath,
    encoding: "utf8",
    reject: true,
    cleanup: true,
    all: false,
    windowsHide: true,
    verbose: verboseDefault,
    ...options2
  };
  options2.env = getEnv(options2);
  options2.stdio = normalizeStdio(options2);
  if (process8.platform === "win32" && path3.basename(file, ".exe") === "cmd") {
    args.unshift("/q");
  }
  return { file, args, options: options2, parsed };
};
var handleOutput = (options2, value, error) => {
  if (typeof value !== "string" && !Buffer3.isBuffer(value)) {
    return error === undefined ? undefined : "";
  }
  if (options2.stripFinalNewline) {
    return stripFinalNewline(value);
  }
  return value;
};
function execa(file, args, options2) {
  const parsed = handleArguments(file, args, options2);
  const command = joinCommand(file, args);
  const escapedCommand = getEscapedCommand(file, args);
  logCommand(escapedCommand, parsed.options);
  validateTimeout(parsed.options);
  let spawned;
  try {
    spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
  } catch (error) {
    const dummySpawned = new childProcess.ChildProcess;
    const errorPromise = Promise.reject(makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    }));
    mergePromise(dummySpawned, errorPromise);
    return dummySpawned;
  }
  const spawnedPromise = getSpawnedPromise(spawned);
  const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
  const processDone = setExitHandler(spawned, parsed.options, timedPromise);
  const context = { isCanceled: false };
  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
  spawned.cancel = spawnedCancel.bind(null, spawned, context);
  const handlePromise = async () => {
    const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
    const stdout = handleOutput(parsed.options, stdoutResult);
    const stderr = handleOutput(parsed.options, stderrResult);
    const all2 = handleOutput(parsed.options, allResult);
    if (error || exitCode !== 0 || signal !== null) {
      const returnedError = makeError({
        error,
        exitCode,
        signal,
        stdout,
        stderr,
        all: all2,
        command,
        escapedCommand,
        parsed,
        timedOut,
        isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
        killed: spawned.killed
      });
      if (!parsed.options.reject) {
        return returnedError;
      }
      throw returnedError;
    }
    return {
      command,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      all: all2,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  };
  const handlePromiseOnce = onetime_default(handlePromise);
  handleInput(spawned, parsed.options);
  spawned.all = makeAllStream(spawned, parsed.options);
  addPipeMethods(spawned);
  mergePromise(spawned, handlePromiseOnce);
  return spawned;
}
function execaSync(file, args, options2) {
  const parsed = handleArguments(file, args, options2);
  const command = joinCommand(file, args);
  const escapedCommand = getEscapedCommand(file, args);
  logCommand(escapedCommand, parsed.options);
  const input = handleInputSync(parsed.options);
  let result;
  try {
    result = childProcess.spawnSync(parsed.file, parsed.args, { ...parsed.options, input });
  } catch (error) {
    throw makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    });
  }
  const stdout = handleOutput(parsed.options, result.stdout, result.error);
  const stderr = handleOutput(parsed.options, result.stderr, result.error);
  if (result.error || result.status !== 0 || result.signal !== null) {
    const error = makeError({
      stdout,
      stderr,
      error: result.error,
      signal: result.signal,
      exitCode: result.status,
      command,
      escapedCommand,
      parsed,
      timedOut: result.error && result.error.code === "ETIMEDOUT",
      isCanceled: false,
      killed: result.signal !== null
    });
    if (!parsed.options.reject) {
      return error;
    }
    throw error;
  }
  return {
    command,
    escapedCommand,
    exitCode: 0,
    stdout,
    stderr,
    failed: false,
    timedOut: false,
    isCanceled: false,
    killed: false
  };
}
var normalizeScriptStdin = ({ input, inputFile, stdio }) => input === undefined && inputFile === undefined && stdio === undefined ? { stdin: "inherit" } : {};
var normalizeScriptOptions = (options2 = {}) => ({
  preferLocal: true,
  ...normalizeScriptStdin(options2),
  ...options2
});
function create$(options2) {
  function $(templatesOrOptions, ...expressions) {
    if (!Array.isArray(templatesOrOptions)) {
      return create$({ ...options2, ...templatesOrOptions });
    }
    const [file, ...args] = parseTemplates(templatesOrOptions, expressions);
    return execa(file, args, normalizeScriptOptions(options2));
  }
  $.sync = (templates, ...expressions) => {
    if (!Array.isArray(templates)) {
      throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
    }
    const [file, ...args] = parseTemplates(templates, expressions);
    return execaSync(file, args, normalizeScriptOptions(options2));
  };
  return $;
}
var $ = create$();

// node_modules/clipboardy/lib/termux.js
var handler = (error) => {
  if (error.code === "ENOENT") {
    throw new Error("Couldn't find the termux-api scripts. You can install them with: apt install termux-api");
  }
  throw error;
};
var clipboard = {
  async copy(options2) {
    try {
      await execa("termux-clipboard-set", options2);
    } catch (error) {
      handler(error);
    }
  },
  async paste(options2) {
    try {
      const { stdout } = await execa("termux-clipboard-get", options2);
      return stdout;
    } catch (error) {
      handler(error);
    }
  },
  copySync(options2) {
    try {
      execaSync("termux-clipboard-set", options2);
    } catch (error) {
      handler(error);
    }
  },
  pasteSync(options2) {
    try {
      return execaSync("termux-clipboard-get", options2).stdout;
    } catch (error) {
      handler(error);
    }
  }
};
var termux_default = clipboard;

// node_modules/clipboardy/lib/linux.js
import path4 from "node:path";
import { fileURLToPath as fileURLToPath4 } from "node:url";
var __dirname2 = path4.dirname(fileURLToPath4(import.meta.url));
var xsel = "xsel";
var xselFallback = path4.join(__dirname2, "../fallbacks/linux/xsel");
var copyArguments = ["--clipboard", "--input"];
var pasteArguments = ["--clipboard", "--output"];
var makeError2 = (xselError, fallbackError) => {
  let error;
  if (xselError.code === "ENOENT") {
    error = new Error("Couldn't find the `xsel` binary and fallback didn't work. On Debian/Ubuntu you can install xsel with: sudo apt install xsel");
  } else {
    error = new Error("Both xsel and fallback failed");
    error.xselError = xselError;
  }
  error.fallbackError = fallbackError;
  return error;
};
var xselWithFallback = async (argumentList, options2) => {
  try {
    const { stdout } = await execa(xsel, argumentList, options2);
    return stdout;
  } catch (xselError) {
    try {
      const { stdout } = await execa(xselFallback, argumentList, options2);
      return stdout;
    } catch (fallbackError) {
      throw makeError2(xselError, fallbackError);
    }
  }
};
var xselWithFallbackSync = (argumentList, options2) => {
  try {
    return execaSync(xsel, argumentList, options2).stdout;
  } catch (xselError) {
    try {
      return execaSync(xselFallback, argumentList, options2).stdout;
    } catch (fallbackError) {
      throw makeError2(xselError, fallbackError);
    }
  }
};
var clipboard2 = {
  async copy(options2) {
    await xselWithFallback(copyArguments, options2);
  },
  copySync(options2) {
    xselWithFallbackSync(copyArguments, options2);
  },
  paste: (options2) => xselWithFallback(pasteArguments, options2),
  pasteSync: (options2) => xselWithFallbackSync(pasteArguments, options2)
};
var linux_default = clipboard2;

// node_modules/clipboardy/lib/macos.js
var env = {
  LC_CTYPE: "UTF-8"
};
var clipboard3 = {
  copy: async (options2) => execa("pbcopy", { ...options2, env }),
  async paste(options2) {
    const { stdout } = await execa("pbpaste", { ...options2, env });
    return stdout;
  },
  copySync: (options2) => execaSync("pbcopy", { ...options2, env }),
  pasteSync: (options2) => execaSync("pbpaste", { ...options2, env }).stdout
};
var macos_default = clipboard3;

// node_modules/clipboardy/lib/windows.js
import path5 from "node:path";
import { fileURLToPath as fileURLToPath5 } from "node:url";

// node_modules/system-architecture/index.js
import { promisify } from "node:util";
import process9 from "node:process";
import childProcess2 from "node:child_process";
var execFilePromises = promisify(childProcess2.execFile);
function systemArchitectureSync() {
  const { arch, platform, env: env2 } = process9;
  if (platform === "darwin" && arch === "x64") {
    const stdout = childProcess2.execFileSync("sysctl", ["-inq", "sysctl.proc_translated"], { encoding: "utf8" });
    return stdout.trim() === "1" ? "arm64" : "x64";
  }
  if (arch === "arm64" || arch === "x64") {
    return arch;
  }
  if (platform === "win32" && Object.hasOwn(env2, "PROCESSOR_ARCHITEW6432")) {
    return "x64";
  }
  if (platform === "linux") {
    const stdout = childProcess2.execFileSync("getconf", ["LONG_BIT"], { encoding: "utf8" });
    if (stdout.trim() === "64") {
      return "x64";
    }
  }
  return arch;
}

// node_modules/is64bit/index.js
var archtectures64bit = new Set([
  "arm64",
  "x64",
  "ppc64",
  "riscv64"
]);
function is64bitSync() {
  return archtectures64bit.has(systemArchitectureSync());
}

// node_modules/clipboardy/lib/windows.js
var __dirname3 = path5.dirname(fileURLToPath5(import.meta.url));
var binarySuffix = is64bitSync() ? "x86_64" : "i686";
var windowBinaryPath = path5.join(__dirname3, `../fallbacks/windows/clipboard_${binarySuffix}.exe`);
var clipboard4 = {
  copy: async (options2) => execa(windowBinaryPath, ["--copy"], options2),
  async paste(options2) {
    const { stdout } = await execa(windowBinaryPath, ["--paste"], options2);
    return stdout;
  },
  copySync: (options2) => execaSync(windowBinaryPath, ["--copy"], options2),
  pasteSync: (options2) => execaSync(windowBinaryPath, ["--paste"], options2).stdout
};
var windows_default = clipboard4;

// node_modules/clipboardy/index.js
var platformLib = (() => {
  switch (process10.platform) {
    case "darwin": {
      return macos_default;
    }
    case "win32": {
      return windows_default;
    }
    case "android": {
      if (process10.env.PREFIX !== "/data/data/com.termux/files/usr") {
        throw new Error("You need to install Termux for this module to work on Android: https://termux.com");
      }
      return termux_default;
    }
    default: {
      if (is_wsl_default) {
        return windows_default;
      }
      return linux_default;
    }
  }
})();
var clipboard5 = {};
clipboard5.write = async (text5) => {
  if (typeof text5 !== "string") {
    throw new TypeError(`Expected a string, got ${typeof text5}`);
  }
  await platformLib.copy({ input: text5 });
};
clipboard5.read = async () => platformLib.paste({ stripFinalNewline: false });
clipboard5.writeSync = (text5) => {
  if (typeof text5 !== "string") {
    throw new TypeError(`Expected a string, got ${typeof text5}`);
  }
  platformLib.copySync({ input: text5 });
};
clipboard5.readSync = () => platformLib.pasteSync({ stripFinalNewline: false });
var clipboardy_default = clipboard5;

// node_modules/open/index.js
import process15 from "node:process";
import { Buffer as Buffer4 } from "node:buffer";
import path6 from "node:path";
import { fileURLToPath as fileURLToPath6 } from "node:url";
import { promisify as promisify6 } from "node:util";
import childProcess3 from "node:child_process";
import fs5, { constants as fsConstants2 } from "node:fs/promises";

// node_modules/wsl-utils/index.js
import process11 from "node:process";
import fs4, { constants as fsConstants } from "node:fs/promises";
var wslDrivesMountPoint = (() => {
  const defaultMountPoint = "/mnt/";
  let mountPoint;
  return async function() {
    if (mountPoint) {
      return mountPoint;
    }
    const configFilePath = "/etc/wsl.conf";
    let isConfigFileExists = false;
    try {
      await fs4.access(configFilePath, fsConstants.F_OK);
      isConfigFileExists = true;
    } catch {}
    if (!isConfigFileExists) {
      return defaultMountPoint;
    }
    const configContent = await fs4.readFile(configFilePath, { encoding: "utf8" });
    const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
    if (!configMountPoint) {
      return defaultMountPoint;
    }
    mountPoint = configMountPoint.groups.mountPoint.trim();
    mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
    return mountPoint;
  };
})();
var powerShellPathFromWsl = async () => {
  const mountPoint = await wslDrivesMountPoint();
  return `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;
};
var powerShellPath = async () => {
  if (is_wsl_default) {
    return powerShellPathFromWsl();
  }
  return `${process11.env.SYSTEMROOT || process11.env.windir || String.raw`C:\Windows`}\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`;
};

// node_modules/define-lazy-prop/index.js
function defineLazyProperty(object, propertyName, valueGetter) {
  const define = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get() {
      const result = valueGetter();
      define(result);
      return result;
    },
    set(value) {
      define(value);
    }
  });
  return object;
}

// node_modules/default-browser/index.js
import { promisify as promisify5 } from "node:util";
import process14 from "node:process";
import { execFile as execFile4 } from "node:child_process";

// node_modules/default-browser-id/index.js
import { promisify as promisify2 } from "node:util";
import process12 from "node:process";
import { execFile } from "node:child_process";
var execFileAsync = promisify2(execFile);
async function defaultBrowserId() {
  if (process12.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const { stdout } = await execFileAsync("defaults", ["read", "com.apple.LaunchServices/com.apple.launchservices.secure", "LSHandlers"]);
  const match2 = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);
  return match2?.groups.id ?? "com.apple.Safari";
}

// node_modules/run-applescript/index.js
import process13 from "node:process";
import { promisify as promisify3 } from "node:util";
import { execFile as execFile2, execFileSync } from "node:child_process";
var execFileAsync2 = promisify3(execFile2);
async function runAppleScript(script, { humanReadableOutput = true, signal } = {}) {
  if (process13.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const outputArguments = humanReadableOutput ? [] : ["-ss"];
  const execOptions = {};
  if (signal) {
    execOptions.signal = signal;
  }
  const { stdout } = await execFileAsync2("osascript", ["-e", script, outputArguments], execOptions);
  return stdout.trim();
}

// node_modules/bundle-name/index.js
async function bundleName(bundleId) {
  return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string
tell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}

// node_modules/default-browser/windows.js
import { promisify as promisify4 } from "node:util";
import { execFile as execFile3 } from "node:child_process";
var execFileAsync3 = promisify4(execFile3);
var windowsBrowserProgIds = {
  AppXq0fevzme2pys62n3e0fbqa7peapykr8v: { name: "Edge", id: "com.microsoft.edge.old" },
  MSEdgeDHTML: { name: "Edge", id: "com.microsoft.edge" },
  MSEdgeHTM: { name: "Edge", id: "com.microsoft.edge" },
  "IE.HTTP": { name: "Internet Explorer", id: "com.microsoft.ie" },
  FirefoxURL: { name: "Firefox", id: "org.mozilla.firefox" },
  ChromeHTML: { name: "Chrome", id: "com.google.chrome" },
  BraveHTML: { name: "Brave", id: "com.brave.Browser" },
  BraveBHTML: { name: "Brave Beta", id: "com.brave.Browser.beta" },
  BraveSSHTM: { name: "Brave Nightly", id: "com.brave.Browser.nightly" }
};

class UnknownBrowserError extends Error {
}
async function defaultBrowser(_execFileAsync = execFileAsync3) {
  const { stdout } = await _execFileAsync("reg", [
    "QUERY",
    " HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
    "/v",
    "ProgId"
  ]);
  const match2 = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
  if (!match2) {
    throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
  }
  const { id } = match2.groups;
  const browser2 = windowsBrowserProgIds[id];
  if (!browser2) {
    throw new UnknownBrowserError(`Unknown browser ID: ${id}`);
  }
  return browser2;
}

// node_modules/default-browser/index.js
var execFileAsync4 = promisify5(execFile4);
var titleize = (string3) => string3.toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x) => x.toUpperCase());
async function defaultBrowser2() {
  if (process14.platform === "darwin") {
    const id = await defaultBrowserId();
    const name = await bundleName(id);
    return { name, id };
  }
  if (process14.platform === "linux") {
    const { stdout } = await execFileAsync4("xdg-mime", ["query", "default", "x-scheme-handler/http"]);
    const id = stdout.trim();
    const name = titleize(id.replace(/.desktop$/, "").replace("-", " "));
    return { name, id };
  }
  if (process14.platform === "win32") {
    return defaultBrowser();
  }
  throw new Error("Only macOS, Linux, and Windows are supported");
}

// node_modules/open/index.js
var execFile5 = promisify6(childProcess3.execFile);
var __dirname4 = path6.dirname(fileURLToPath6(import.meta.url));
var localXdgOpenPath = path6.join(__dirname4, "xdg-open");
var { platform, arch } = process15;
async function getWindowsDefaultBrowserFromWsl() {
  const powershellPath = await powerShellPath();
  const rawCommand = String.raw`(Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice").ProgId`;
  const encodedCommand = Buffer4.from(rawCommand, "utf16le").toString("base64");
  const { stdout } = await execFile5(powershellPath, [
    "-NoProfile",
    "-NonInteractive",
    "-ExecutionPolicy",
    "Bypass",
    "-EncodedCommand",
    encodedCommand
  ], { encoding: "utf8" });
  const progId = stdout.trim();
  const browserMap = {
    ChromeHTML: "com.google.chrome",
    BraveHTML: "com.brave.Browser",
    MSEdgeHTM: "com.microsoft.edge",
    FirefoxURL: "org.mozilla.firefox"
  };
  return browserMap[progId] ? { id: browserMap[progId] } : {};
}
var pTryEach = async (array, mapper) => {
  let latestError;
  for (const item of array) {
    try {
      return await mapper(item);
    } catch (error) {
      latestError = error;
    }
  }
  throw latestError;
};
var baseOpen = async (options2) => {
  options2 = {
    wait: false,
    background: false,
    newInstance: false,
    allowNonzeroExitCode: false,
    ...options2
  };
  if (Array.isArray(options2.app)) {
    return pTryEach(options2.app, (singleApp) => baseOpen({
      ...options2,
      app: singleApp
    }));
  }
  let { name: app, arguments: appArguments = [] } = options2.app ?? {};
  appArguments = [...appArguments];
  if (Array.isArray(app)) {
    return pTryEach(app, (appName) => baseOpen({
      ...options2,
      app: {
        name: appName,
        arguments: appArguments
      }
    }));
  }
  if (app === "browser" || app === "browserPrivate") {
    const ids = {
      "com.google.chrome": "chrome",
      "google-chrome.desktop": "chrome",
      "com.brave.Browser": "brave",
      "org.mozilla.firefox": "firefox",
      "firefox.desktop": "firefox",
      "com.microsoft.msedge": "edge",
      "com.microsoft.edge": "edge",
      "com.microsoft.edgemac": "edge",
      "microsoft-edge.desktop": "edge"
    };
    const flags = {
      chrome: "--incognito",
      brave: "--incognito",
      firefox: "--private-window",
      edge: "--inPrivate"
    };
    const browser2 = is_wsl_default ? await getWindowsDefaultBrowserFromWsl() : await defaultBrowser2();
    if (browser2.id in ids) {
      const browserName = ids[browser2.id];
      if (app === "browserPrivate") {
        appArguments.push(flags[browserName]);
      }
      return baseOpen({
        ...options2,
        app: {
          name: apps[browserName],
          arguments: appArguments
        }
      });
    }
    throw new Error(`${browser2.name} is not supported as a default browser`);
  }
  let command;
  const cliArguments = [];
  const childProcessOptions = {};
  if (platform === "darwin") {
    command = "open";
    if (options2.wait) {
      cliArguments.push("--wait-apps");
    }
    if (options2.background) {
      cliArguments.push("--background");
    }
    if (options2.newInstance) {
      cliArguments.push("--new");
    }
    if (app) {
      cliArguments.push("-a", app);
    }
  } else if (platform === "win32" || is_wsl_default && !isInsideContainer() && !app) {
    command = await powerShellPath();
    cliArguments.push("-NoProfile", "-NonInteractive", "-ExecutionPolicy", "Bypass", "-EncodedCommand");
    if (!is_wsl_default) {
      childProcessOptions.windowsVerbatimArguments = true;
    }
    const encodedArguments = ["Start"];
    if (options2.wait) {
      encodedArguments.push("-Wait");
    }
    if (app) {
      encodedArguments.push(`"\`"${app}\`""`);
      if (options2.target) {
        appArguments.push(options2.target);
      }
    } else if (options2.target) {
      encodedArguments.push(`"${options2.target}"`);
    }
    if (appArguments.length > 0) {
      appArguments = appArguments.map((argument) => `"\`"${argument}\`""`);
      encodedArguments.push("-ArgumentList", appArguments.join(","));
    }
    options2.target = Buffer4.from(encodedArguments.join(" "), "utf16le").toString("base64");
  } else {
    if (app) {
      command = app;
    } else {
      const isBundled = !__dirname4 || __dirname4 === "/";
      let exeLocalXdgOpen = false;
      try {
        await fs5.access(localXdgOpenPath, fsConstants2.X_OK);
        exeLocalXdgOpen = true;
      } catch {}
      const useSystemXdgOpen = process15.versions.electron ?? (platform === "android" || isBundled || !exeLocalXdgOpen);
      command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
    }
    if (appArguments.length > 0) {
      cliArguments.push(...appArguments);
    }
    if (!options2.wait) {
      childProcessOptions.stdio = "ignore";
      childProcessOptions.detached = true;
    }
  }
  if (platform === "darwin" && appArguments.length > 0) {
    cliArguments.push("--args", ...appArguments);
  }
  if (options2.target) {
    cliArguments.push(options2.target);
  }
  const subprocess = childProcess3.spawn(command, cliArguments, childProcessOptions);
  if (options2.wait) {
    return new Promise((resolve2, reject) => {
      subprocess.once("error", reject);
      subprocess.once("close", (exitCode) => {
        if (!options2.allowNonzeroExitCode && exitCode > 0) {
          reject(new Error(`Exited with code ${exitCode}`));
          return;
        }
        resolve2(subprocess);
      });
    });
  }
  subprocess.unref();
  return subprocess;
};
var open = (target, options2) => {
  if (typeof target !== "string") {
    throw new TypeError("Expected a `target`");
  }
  return baseOpen({
    ...options2,
    target
  });
};
function detectArchBinary(binary) {
  if (typeof binary === "string" || Array.isArray(binary)) {
    return binary;
  }
  const { [arch]: archBinary } = binary;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
  if (wsl && is_wsl_default) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
var apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
  darwin: "google chrome",
  win32: "chrome",
  linux: ["google-chrome", "google-chrome-stable", "chromium"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
    x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
  }
}));
defineLazyProperty(apps, "brave", () => detectPlatformBinary({
  darwin: "brave browser",
  win32: "brave",
  linux: ["brave-browser", "brave"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe",
    x64: ["/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe", "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe"]
  }
}));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
  darwin: "firefox",
  win32: String.raw`C:\Program Files\Mozilla Firefox\firefox.exe`,
  linux: "firefox"
}, {
  wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
}));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
  darwin: "microsoft edge",
  win32: "msedge",
  linux: ["microsoft-edge", "microsoft-edge-dev"]
}, {
  wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
}));
defineLazyProperty(apps, "browser", () => "browser");
defineLazyProperty(apps, "browserPrivate", () => "browserPrivate");
var open_default = open;

// node_modules/commander/esm.mjs
var import__ = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  Command,
  Argument,
  Option,
  Help
} = import__.default;

// index.ts
var program2 = new Command;
function randomId(length = 6) {
  const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let result = "";
  for (let i = 0;i < length; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}
program2.name("todocx").description("Convert Markdown to DOCX").option("-i, --input <file>", "Input markdown file. If omitted, read from clipboard").option("-o, --output <file>", "Output DOCX file").parse(process.argv);
var options2 = program2.opts();
var inputFile = options2.input;
var outputFile = options2.output ?? `output-${randomId()}.docx`;
var markdownText;
if (inputFile) {
  if (!fs6.existsSync(inputFile)) {
    console.error(`Input file does not exist: ${inputFile}`);
    process.exit(1);
  }
  markdownText = fs6.readFileSync(inputFile, "utf-8");
} else {
  markdownText = clipboardy_default.readSync();
  if (!markdownText) {
    console.error("Clipboard is empty and no input file provided.");
    process.exit(1);
  }
}
var processor = unified().use(remarkParse).use(remarkGfm).use(plugin, { output: "buffer" });
(async () => {
  try {
    const doc = await processor.process(markdownText);
    const buffer3 = await doc.result;
    fs6.writeFileSync(outputFile, buffer3);
    console.log(`Word file generated: ${outputFile}`);
    await open_default(path7.resolve(outputFile));
  } catch (err) {
    console.error("Error processing markdown:", err);
    process.exit(1);
  }
})();
